import{_ as o,c as t,a2 as r,o as c}from"./chunks/framework.CKGreiRV.js";const u=JSON.parse('{"title":"Exposed Object.defineProperties()","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-defineproperties.md","filePath":"resource/duktape/doc/hobject-alg-defineproperties.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/hobject-alg-defineproperties.md"};function d(a,e,n,s,l,p){return c(),t("div",null,e[0]||(e[0]=[r(`<h1 id="exposed-object-defineproperties" tabindex="-1">Exposed Object.defineProperties() <a class="header-anchor" href="#exposed-object-defineproperties" aria-label="Permalink to &quot;Exposed Object.defineProperties()&quot;">​</a></h1><h2 id="implementation-approach-discussion" tabindex="-1">Implementation approach discussion <a class="header-anchor" href="#implementation-approach-discussion" aria-label="Permalink to &quot;Implementation approach discussion&quot;">​</a></h2><p>Since <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code> are such expensive functions (from a code footprint point of view), we&#39;d really like to have only one implementation with some wrappers. For instance, we could have an actual implementation of <code>Object.defineProperty()</code> and then have <code>Object.defineProperties()</code> call it as a helper (or vice versa).</p><p>Considering the case where <code>Object.defineProperties()</code> would use <code>Object.defineProperty()</code> as a helper, the <code>Object.defineProperties()</code> algorithm is unfortunate: it coerces all property descriptors with <code>ToPropertyDescriptor()</code> and puts them on an internal list (<code>descriptors</code>) <em>before</em> doing any operations on the target object. The coercion includes property descriptor validation, and implies some way of storing the internal descriptors (other than local variables).</p><p>Note that the <code>ToPropertyDescriptor()</code> coercion may also have arbitrary user visible side effects because it calls <code>[[Get]]</code> on the relevant properties. The <code>[[Get]]</code> may invoke a getter call, which may in pathological cases even <em>modify</em> the other descriptors -- creating both an ordering and a call count dependency. Consider the pathological case:</p><pre><code>var desc2 = { value: 0 };
var desc1 = {
  get value() {
    print(&quot;desc1 value getter&quot;);
    desc2.value++;  // increment for every call
    return &quot;test&quot;;
  }
};

var descs = { foo: desc1, bar: desc2 };

var o = {};
Object.defineProperties(o, descs);
print(o.foo);  // should print test
print(o.bar);  // should print 1, as getter is called exactly once
</code></pre><p>If the implementation were to, for instance, call <code>ToPropertyDescriptor()</code> twice (once to validate, discarding any results, and a second time when calling <code>Object.defineProperty()</code> internally as a helper), it would fail the above test.</p><p>On the other hand, if the implementation simply called <code>Object.defineProperty()</code> for each descriptor in turn, it would not be compliant if there is an invalid descriptor in the <code>Properties</code> argument list of <code>Object.defineProperties()</code>. No changes to the target object can be made if there is an invalid descriptor in the list.</p><p>There are other pathological cases too, e.g. a getter removing elements from the <code>Properties</code> argument of <code>Object.defineProperties()</code>.</p><p>Another implementation approach is to make <code>Object.defineProperties()</code> the main algorithm and have <code>Object.defineProperty()</code> be a wrapper around it. This works but still has issues:</p><ul><li><p><code>Object.defineProperties()</code> still needs to have a list of <em>coerced</em> descriptors internally, which implies some storage (other than local variables) for coerced (internal) descriptors.</p></li><li><p><code>Object.defineProperty()</code> would need to create a temporary object for containing the one property descriptor it gets as an input, e.g.:</p><pre><code>Object.defineProperty(o, &#39;foo&#39;, { value: &#39;bar&#39; });
</code></pre><p>needs to become:</p><pre><code>Object.defineProperties(o, { foo: { value: &#39;bar&#39; }});
</code></pre></li></ul><p>A way around creating an internal representation for partially populated descriptors is to use an internal ECMAScript object representing a validated and normalized descriptor with all property values already coerced and checked; any getter calls would be done during coercion and the final value would be a plain one. In the pathological example above, the internal descriptors could be:</p><pre><code>{
  foo: {
    value: &quot;test&quot;
  },
  bar: {
    value: 1
  }
}
</code></pre><p>The coercions could then be executed first, and the coerced descriptors then given one at a time (as ECMAScript objects) to <code>Object.defineProperty()</code>.</p><p>This would eliminate any side effects of the coercion and would allow validation of the descriptors before any object changes. The downside is the need for an additional helper, and creating temporary objects for each <code>Object.defineProperties()</code> (but not <code>Object.defineProperty()</code>) call.</p><p>This is the current implementation approach. The coercion helper is defined as <code>NormalizePropertyDescriptor</code> in the restatements section and will be inlined below. Note that this helper is not part of the E5 specification.</p><h2 id="original-algorithm" tabindex="-1">Original algorithm <a class="header-anchor" href="#original-algorithm" aria-label="Permalink to &quot;Original algorithm&quot;">​</a></h2><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>props</code> be <code>ToObject(Properties)</code>.</li><li>Let <code>names</code> be an internal list containing the names of each enumerable own property of <code>props</code>.</li><li>Let <code>descriptors</code> be an empty internal List.</li><li>For each element <code>P</code> of <code>names</code> in list order, a. Let <code>descObj</code> be the result of calling the <code>[[Get]]</code> internal method of <code>props</code> with <code>P</code> as the argument. b. Let <code>desc</code> be the result of calling <code>ToPropertyDescriptor</code> with <code>descObj</code> as the argument. (Note: this step may fail due for invalid property descriptors, and may have user visible side effects due to potential getter calls.) c. Append <code>desc</code> to the end of <code>descriptors</code>.</li><li>For each element <code>desc</code> of <code>descriptors</code> in list order, a. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> with arguments <code>P</code>, <code>desc</code>, and <code>true</code>.</li><li>Return <code>O</code>.</li></ol><p>Notes:</p><ul><li>In Step 6.a <code>P</code> should refer to the name related to the descriptor being processed, but there is no assignment for <code>P</code> after step 5. This seems like a small typo in the specification.</li></ul><h2 id="using-normalizepropertydescriptor" tabindex="-1">Using NormalizePropertyDescriptor <a class="header-anchor" href="#using-normalizepropertydescriptor" aria-label="Permalink to &quot;Using NormalizePropertyDescriptor&quot;">​</a></h2><p>Below, the standard algorithm has been changed to use <code>NormalizePropertyDescriptor()</code> and to call <code>Object.defineProperty()</code> instead of <code>[[DefineOwnProperty]]</code>:</p><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>props</code> be <code>ToObject(Properties)</code>.</li><li>Let <code>descriptors</code> be an empty internal Object. (Note: we assume that the object has enumeration order matching property insertion order.)</li><li>For each enumerable property <code>P</code> of <code>props</code> (in normal enumeration order), a. Let <code>descObj</code> be the result of calling the <code>[[Get]]</code> internal method of <code>props</code> with <code>P</code> as the argument. b. Let <code>desc</code> be the result of calling <code>NormalizePropertyDescriptor</code> with <code>descObj</code> as the argument. (Note: this step may fail due for invalid property descriptors, and may have user visible side effects due to potential getter calls.) c. Call the <code>[[Put]]</code> internal method of <code>descriptors</code> with <code>P</code>, <code>desc</code> and <code>true</code> as arguments.</li><li>For each enumerable property <code>P</code> of <code>descriptors</code> (in insertion order), a. Let <code>desc</code> be the result of calling the <code>[[Get]]</code> internal method of <code>descriptors</code> with <code>P</code> as the argument. (Note: this is guaranteed to succeed and yield a valid descriptor object.) b. Call the <code>Object.defineProperty()</code> built-in method with the arguments <code>O</code>, <code>P</code> and <code>desc</code>, ignoring its result value. (Note: this call may fail due to an exception.)</li><li>Return <code>O</code>.</li></ol><p>Changing <code>[[DefineOwnProperty]]</code> to <code>Object.defineProperty()</code> should be semantically correct. Consider the steps of <code>Object.defineProperty()</code> in E5 Section 15.2.3.6:</p><ul><li>Step 1: already covered by step 1 above.</li><li>Step 2: a no-op because all property names (<code>P</code>) above are naturally strings.</li><li>Step 3: guaranteed to succeed and be side-effect free, and to produce the same result as it normally would.</li><li>Step 4: makes a call to <code>[[DefineOwnProperty]]</code></li><li>Step 5: return value is ignored.</li></ul>`,25)]))}const f=o(i,[["render",d]]);export{u as __pageData,f as default};
