import{_ as t,c as o,a2 as a,o as i}from"./chunks/framework.CuCbyi2k.js";const p=JSON.parse('{"title":"Sandboxing Duktape","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/sandboxing.md","filePath":"resource/duktape/doc/sandboxing.md","lastUpdated":1732350347000}'),n={name:"resource/duktape/doc/sandboxing.md"};function r(s,e,c,l,d,u){return i(),o("div",null,e[0]||(e[0]=[a(`<h1 id="sandboxing-duktape" tabindex="-1">Sandboxing Duktape <a class="header-anchor" href="#sandboxing-duktape" aria-label="Permalink to &quot;Sandboxing Duktape&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Sandboxed environments allow execution of untrusted code with two broad goals in mind:</p><ol><li>Security: prevent untrusted code from doing unsafe operations such as accessing memory directly, causing segfaults, etc.</li><li>Availability: prevent untrusted code from hogging resources, e.g. consuming all available memory or entering an infinite loop.</li></ol><p>For some sandbox environments it&#39;s sufficient to protect against accidents, e.g. user code accidentally entering an infinite loop. In other environments the executed code may be potentially hostile, which is of course much more challenging to secure against.</p><p>Duktape provides mechanisms to allow these goals to be achieved for running untrusted ECMAScript code. All C code is expected to be trusted and must be carefully written with these sandboxing goals in mind.</p><p>This document describes best practices for Duktape sandboxing.</p><p>There&#39;s a YAML config file with some useful default options for sandboxing, and comments on what options you might consider:</p><ul><li><code>config/examples/security_sensitive.yaml</code></li></ul><p>::: note ::: title Note :::</p><p>This document described the current status of sandboxing features which is not yet a complete solution. :::</p><h2 id="suggested-measures" tabindex="-1">Suggested measures <a class="header-anchor" href="#suggested-measures" aria-label="Permalink to &quot;Suggested measures&quot;">​</a></h2><h3 id="isolation-approaches" tabindex="-1">Isolation approaches <a class="header-anchor" href="#isolation-approaches" aria-label="Permalink to &quot;Isolation approaches&quot;">​</a></h3><p>There are two basic alternatives to sandboxing ECMAScript code with Duktape:</p><ul><li>Use a separate Duktape heap for each sandbox.</li><li>Use a separate Duktape thread (with a separate global environment) for each sandbox.</li></ul><p>Pros and cons of using a Duktape heap for sandboxing:</p><ul><li>Duktape heaps cannot exchange values or object references except through explicit serialization, so values or references don&#39;t accidentally leak from one heap to another.</li><li>Each Duktape heap can be assigned its own memory pool, which allows separate memory limits to be placed for each sandbox.</li><li>Multiple native threads can be used in parallel to execute code in different heaps. Only one native thread may be active at a time for each particular heap, however.</li><li>One downside is that there is some per-heap overhead which accumulates for each sandbox; ROM built-ins can mitigate some of that effect. If the memory pool for a heap is pre-allocated and not shared between heaps (in a thread safe manner), some of the pool will be unused. If memory is not pre-allocated, actual memory usage is quite tightly bound because of reference counting.</li></ul><p>Pros and cons of using a Duktape thread for sandboxing:</p><ul><li>Duktape threads can exchange values and object references. This can be useful at times, but is also a risk for sandboxing.</li><li>If you create a thread with a separate global environment (<code>duk_push_thread_new_globalenv()</code>), two threads can be isolated to a large extent. It&#39;s still possible to leak values and references between threads through Duktape/C functions, carelessly written finalizers, and so on.</li><li>All threads in a certain heap share the same memory pool which means that one sandbox can starve other sandboxes of memory.</li><li>Only a single native thread can execute ECMAScript code at a time.</li></ul><p>These two approaches can of course be mixed: you can have multiple heaps, each with one or more sandboxed threads.</p><h3 id="define-a-native-stack-check-macro-duk-use-native-stack-check" tabindex="-1">Define a native stack check macro (DUK_USE_NATIVE_STACK_CHECK) <a class="header-anchor" href="#define-a-native-stack-check-macro-duk-use-native-stack-check" aria-label="Permalink to &quot;Define a native stack check macro (DUK_USE_NATIVE_STACK_CHECK)&quot;">​</a></h3><p>This macro allows a sandbox environment to minimize chances of a native stack overrun more accurately than plain stack depth limits (such as DUK_USE_NATIVE_CALL_RECLIMIT). See:</p><ul><li>Config option description: <a href="https://github.com/svaarala/duktape/blob/master/config/config-options/DUK_USE_NATIVE_STACK_CHECK.yaml" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/config/config-options/DUK_USE_NATIVE_STACK_CHECK.yaml</a></li><li>Example stack check call in (duk_cmdline_stack_check): <a href="https://github.com/svaarala/duktape/blob/master/examples/cmdline/duk_cmdline.c" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/examples/cmdline/duk_cmdline.c</a></li></ul><h3 id="disable-verbose-errors" tabindex="-1">Disable verbose errors <a class="header-anchor" href="#disable-verbose-errors" aria-label="Permalink to &quot;Disable verbose errors&quot;">​</a></h3><p>Verbose error messages may cause sandboxing security issues:</p><ul><li>When <code>DUK_USE_PARANOID_ERRORS</code> is not set, offending object/key is summarized in an error message of some rejected property operations. If object keys contain potentially sensitive information, you should enable this option. Disable <code>DUK_USE_PARANOID_ERRORS</code>.</li><li>When stack traces are enabled an attacker may gain useful information from the stack traces. Further, access to the internal <code>_Tracedata</code> property provides access to call chain functions even when references to them are not available directly. Disable <code>DUK_USE_TRACEBACKS</code>.</li></ul><h3 id="replace-the-global-object" tabindex="-1">Replace the global object <a class="header-anchor" href="#replace-the-global-object" aria-label="Permalink to &quot;Replace the global object&quot;">​</a></h3><p>The first thing you should do is replace the global object with a minimal replacement, providing only those bindings that are absolutely necessary for the sandboxed environment. Sometimes this means the full E5 bindings; sometimes it means just a few bindings that sandboxed code is expecting.</p><p>In general you should be confident that every exposed binding is safe from both security and availability viewpoints.</p><p>Risky bindings:</p><ul><li>The <code>Duktape</code> object provides access to Duktape internals in several ways which is not ideal. It may also gain new properties in new Duktape versions, which may be easy to accidentally overlook, so the safest default is to hide it from sandboxed code. You can still cherry pick individual functions to be exposed directly or through a wrapper. You can copy a reference to the <code>Duktape</code> object e.g. to the global stash which will then be accessible for C code.</li><li><code>Duktape.act()</code> provides access to calling functions which may matter to some sandboxing environments.</li><li><code>Duktape.fin()</code> provides access to setting and getting a finalizer. Since a finalizer may run in a different thread than where it was created, finalizers are a sandboxing risk. It&#39;s also possible to override or unset a finalizer which the sandbox relies on.</li><li>Since Duktape 2.x buffer bindings no longer provide a way create hidden Symbols (called &quot;internal strings&quot; in Duktape 1.x) which allow access to internal properties. See separate section on internal properties.</li></ul><p>You should also:</p><ul><li>Remove the <code>require</code> module loading function in the global object (since Duktape 2.x it&#39;s no longer present by default). If you need module loading in the sandbox, it&#39;s better to write a specific, constrained module loader for that environment.</li></ul><h3 id="restrict-access-to-internal-properties" tabindex="-1">Restrict access to internal properties <a class="header-anchor" href="#restrict-access-to-internal-properties" aria-label="Permalink to &quot;Restrict access to internal properties&quot;">​</a></h3><p>Internal properties are used by Duktape and user C code to store &quot;hidden properties&quot; in objects. The mechanism currently relies on &quot;hidden Symbols&quot; (called &quot;internal keys&quot; or &quot;internal strings&quot; in Duktape 1.x). These are strings whose internal representation contains invalid UTF-8/CESU-8 data (see <code>doc/symbols.rst</code> for description of the current formats). Because all standard ECMAScript strings are represented as CESU-8, such strings cannot normally be created by ECMAScript code. The properties are also never enumerated or otherwise exposed to ECMAScript code (not even by <code>Object.getOwnPropertySymbols()</code>) so that the only way to access them from ECMAScript code is to have access to a hidden Symbol acting as the property key.</p><p>C code can create hidden Symbols very easily, which can provide a way to access internal properties. For example:</p><pre><code>// Assume an application native binding returns an internal key pushed
// using duk_push_string(ctx, &quot;\\xff&quot; &quot;Value&quot;):
var key = getDangerousKey();

// Access a Date instance&#39;s internal value, not normally accessible.
print(&#39;Date internal value is:&#39;, new Date()[key]);
</code></pre><p>The risk in being able to access a certain internal property depends on the internal property in question. Some internal properties are non-writable and non-configurable, so the sandboxed code can only read the property value; quite often this is not an issue by itself. If the value of an internal property can be modified, concrete security issues may arise. For instance, if an internal property stores a raw pointer to a native handle (such as a <code>FILE *</code>), changing its value can lead to a potentially exploitable segfault.</p><p>Since Duktape 2.x ECMAScript code cannot create hidden Symbols using standard ECMAScript code and the built-in bindings alone. To prevent access to hidden Symbols, ensure that no native bindings provided by the sandboxing environment accidentally return such strings. The easiest way to ensure this is to make sure all strings pushed on the value stack are properly CESU-8 encoded.</p><p>It&#39;s also good practice to ensure that sandboxed code has minimal access to objects with potentially dangerous properties like raw pointers.</p><p>::: note ::: title Note :::</p><p>There&#39;s a future work issue, potentially included in Duktape 3.x, for preventing access to internal properties from ECMAScript code even when using the correct hidden Symbol as a lookup key. :::</p><h3 id="restrict-access-to-function-instances" tabindex="-1">Restrict access to function instances <a class="header-anchor" href="#restrict-access-to-function-instances" aria-label="Permalink to &quot;Restrict access to function instances&quot;">​</a></h3><p>In some environments giving the user code access to calling functions can be dangerous. For instance, if user code gets access to a function it cannot normally see through bindings in the global object, it can call that function and perhaps sidestep sandboxing.</p><p>Prevent access to function references in the call stack:</p><ul><li>Prevent access to <code>Duktape.act()</code> which provides programmatic access to the call stack and its function references.</li><li>If <code>DUK_USE_NONSTD_FUNC_CALLER_PROPERTY</code> is enabled, the <code>caller</code> property provides access to calling functions. Don&#39;t use this option with sandboxing, or at least carefully control the <code>caller</code> property values seen by the sandboxed code.</li><li>The <code>_Tracedata</code> internal property of error objects contains references to calling functions. Because this property is internal, sandboxed code has no access to it as long as access to internal properties is prevented in general.</li></ul><h3 id="restrict-access-to-finalizers" tabindex="-1">Restrict access to finalizers <a class="header-anchor" href="#restrict-access-to-finalizers" aria-label="Permalink to &quot;Restrict access to finalizers&quot;">​</a></h3><p>Allowing user to code to run a finalizer is dangerous: a finalizer can execute in another thread than where it was created, so it can potentially breach sandboxing.</p><p>Suggestions for sandboxing:</p><ul><li>Don&#39;t give user code access to <code>Duktape.fin()</code>.</li><li>Don&#39;t give user code access to internal properties: with access to internal properties, user code can read/write the internal finalizer reference directly.</li><li>Write finalizers very carefully. Make minimal assumptions on which thread they run, i.e. which global object they see. It&#39;s also best practice to tolerate re-entry (although Duktape 1.4.0 and above has a guarantee of no re-entry unless object is rescued).</li><li>For sandboxed environments it may be sensible to make all finalizers native code so that they can access the necessary thread contexts regardless of the finalizer thread.</li></ul><h3 id="sanitize-built-in-prototype-objects" tabindex="-1">Sanitize built-in prototype objects <a class="header-anchor" href="#sanitize-built-in-prototype-objects" aria-label="Permalink to &quot;Sanitize built-in prototype objects&quot;">​</a></h3><p>Plain values inherit implicitly from built-in prototype objects. For instance, string values inherit from <code>String.prototype</code>, which allows one to access string methods with a plain base value:</p><pre><code>print(&quot;foo&quot;.toUpperCase());
</code></pre><p>Duktape uses the original built-in prototype functions in these inheritance situations. There is currently no way to replace these built-ins so that the replacements would be used for instead (see <code>test-dev-sandbox-prototype-limitation.js</code>).</p><p>As a result, sandboxed code will always have access to the built-in prototype objects which participate in implicit inheritance:</p><ul><li><code>Boolean.prototype</code>: through plain booleans such as <code>true</code></li><li><code>Number.prototype</code>: through numbers such as <code>123</code></li><li><code>String.prototype</code>: through strings such as <code>&quot;foo&quot;</code></li><li><code>Object.prototype</code>: through object literals such as <code>{}</code></li><li><code>Array.prototype</code>: through array literals such as <code>[]</code></li><li><code>Function.prototype</code>: through function expressions and declarations, such as <code>function(){}</code></li><li><code>RegExp.prototype</code>: through RegExp literals such as <code>/foo/</code></li><li><code>Error.prototype</code> and all subclasses like <code>URIError.prototype</code>: through explicit construction (if constructors visible) or implicitly through internal errors, e.g. <code>/foo\\123/</code> which throws a SyntaxError</li><li><code>Uint8Array.prototype</code>: through buffer values (if available); since there is no buffer literal, user cannot construct buffer values directly</li><li><code>Duktape.Pointer.prototype</code> through pointer values (if available); since there is no pointer literal, user cannot construct pointer values directly</li></ul><p>It&#39;s not sufficient to avoid exposing these prototype objects in a replacement global object: Duktape will use the original built-in prototype objects regardless when dealing with plain value inheritance. It is possible, however, to delete individual properties of the prototype objects, e.g.:</p><pre><code>delete String.prototype.toUpperCase
</code></pre><p>This will cause the original example to fail:</p><pre><code>delete String.prototype.toUpperCase
print(&quot;foo&quot;.toUpperCase());  // TypeError: call target not an object
</code></pre><p>Suggestions for sandboxing:</p><ul><li>Be aware that user code can access built-in prototypes through implicit inheritance through various plain values.</li><li>Sanitize built-in prototype objects by deleting unnecessary methods.</li></ul><p><strong>XXX: This will probably need improvement. There may need to be API to replace all built-in values. They are kept in an internal array so perhaps just exposing a primitive to set arbitrary values in the array would be sufficient (though cryptic). Some work in <a href="https://github.com/svaarala/duktape/pull/566." target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/pull/566.</a></strong></p><h3 id="use-the-bytecode-execution-timeout-mechanism" tabindex="-1">Use the bytecode execution timeout mechanism <a class="header-anchor" href="#use-the-bytecode-execution-timeout-mechanism" aria-label="Permalink to &quot;Use the bytecode execution timeout mechanism&quot;">​</a></h3><p>Duktape 1.1 added a simple bytecode execution timeout mechanism, see <code>DUK_USE_EXEC_TIMEOUT_CHECK</code> in <a href="http://wiki.duktape.org/ConfigOptions.html" target="_blank" rel="noreferrer">http://wiki.duktape.org/ConfigOptions.html</a>.</p><p>The mechanism and its limitations is described in a separate section below.</p><h3 id="use-a-fixed-size-memory-pool-for-the-sandbox" tabindex="-1">Use a fixed size memory pool for the sandbox <a class="header-anchor" href="#use-a-fixed-size-memory-pool-for-the-sandbox" aria-label="Permalink to &quot;Use a fixed size memory pool for the sandbox&quot;">​</a></h3><p>You should usually restrict the amount of memory that the sandbox can use.</p><p>One common approach is to use a pooled memory allocator to impose a hard limit on the memory available to the sandbox. The memory can be split into memory areas of a fixed size or a free-list based approach can be used.</p><p>Another approach is to use wrappers around standard <code>malloc</code>, <code>realloc</code>, and <code>free</code> and keep track of total allocated memory. One difficulty with this is that <code>realloc</code> calls are not given the original allocation size so you need to track that separately e.g. by prepending a small header to every allocated memory block.</p><h3 id="review-your-c-bindings-for-safety" tabindex="-1">Review your C bindings for safety <a class="header-anchor" href="#review-your-c-bindings-for-safety" aria-label="Permalink to &quot;Review your C bindings for safety&quot;">​</a></h3><p>Review every C binding exposed to the sandbox. There should be no way to violate the safety goals through the C binding. In particular, it shouldn&#39;t be possible to:</p><ul><li>Cause memory unsafe behavior regardless of call arguments.</li><li>Execute for an unreasonable amount of time.</li><li>Access internal properties directly or indirectly.</li><li>Push internal strings directly or indirectly.</li></ul><p>Particular issues to look out for:</p><ul><li>Check typing of all arguments. Avoid <code>NULL</code> pointers by using the &quot;require&quot; variants of getters (e.g. <code>duk_require_lstring()</code> instead of <code>duk_require_string()</code>).</li><li>Check every loop for termination. Add a sanity termination limit if a loop is suspect. Your goal is to return to the bytecode executor so that bytecode execution timeout can happen.</li><li>When creating string values, ensure they&#39;re properly CESU-8 (or UTF-8) encoded. This ensures internal strings, providing access to internal properties, are not created by accident.</li><li>When calling platform APIs, ensure they can never block indefinitely.</li><li>Also ensure that native code doesn&#39;t compromise sandboxing goals at a higher level. For instance, an API call must not allow sandboxed code to perform unauthenticated database writes or breach memory safety through file I/O on a Unix device file.</li></ul><h3 id="use-bytecode-dump-load-carefully" tabindex="-1">Use bytecode dump/load carefully <a class="header-anchor" href="#use-bytecode-dump-load-carefully" aria-label="Permalink to &quot;Use bytecode dump/load carefully&quot;">​</a></h3><p>Because Duktape doesn&#39;t validate bytecode being loaded, loading invalid bytecode may lead to memory unsafe behavior -- even exploitable vulnerabilities. To avoid such issues:</p><ul><li>Use bytecode dump/load only when it is really necessary e.g. for performance. An alternative to bytecode dump/load is to compile on-the-fly which is usually not a performance bottleneck. You can use e.g. minification to obfuscate code.</li><li>Ensure bytecode being loaded has been compiled with the same Duktape version and same Duktape configuration options. Major and minor versions must match; patch version may vary as bytecode format doesn&#39;t change in patch versions.</li><li>Ensure integrity of bytecode being loaded e.g. by checksumming or signing.</li><li>If bytecode is transported over the network or other unsafe media, use cryptographic means (keyed hashing, signatures, or similar) to ensure an attacker cannot cause crafted bytecode to be loaded.</li></ul><p>Bytecode dump/load is only available through the C API, so there are no direct sandboxing considerations for executing ECMAScript code. However, if a Duktape/C function uses bytecode dump/load, ensure that it doesn&#39;t accidentally expose the facility to ECMAScript code.</p><p>See <code>bytecode.rst</code> for more discussion on bytecode limitations and best practices.</p><h2 id="bytecode-execution-timeout-details" tabindex="-1">Bytecode execution timeout details <a class="header-anchor" href="#bytecode-execution-timeout-details" aria-label="Permalink to &quot;Bytecode execution timeout details&quot;">​</a></h2><p>This section describes the bytecode execution timeout mechanism in detail, and illustrates the limitations in the current Duktape 1.1 version of the mechanism.</p><p>The current mechanism provides some protection against accidental errors like infinite loops, but is not a reliable mechanism against deliberately malicious code.</p><h3 id="current-implementation" tabindex="-1">Current implementation <a class="header-anchor" href="#current-implementation" aria-label="Permalink to &quot;Current implementation&quot;">​</a></h3><ul><li>The bytecode executor calls the user callback whenever it goes into the bytecode executor interrupt handler. The interval between interrupts varies from one bytecode instruction (e.g. when debugging) to several hundred thousand bytecode instructions (e.g. when running normally).</li><li>When the user callback indicates a timeout the bytecode executor throws a <code>RangeError</code>. This error is propagated like any other error.</li><li>ECMAScript code (try-catch-finally) may catch the error, but before a catch/finally clause actually executes, another <code>RangeError</code> is thrown by the bytecode executor. The executor makes sure an execution interrupt happens before the catch/finally (or any other ECMAScript code) executes. For this approach to work, it&#39;s important that the user callback keeps indicating a timeout until the <code>RangeError</code> has fully bubbled through to the original protected call.</li><li>Duktape/C functions can catch the error by using a protected call. They have a chance to clean up any native resources, with the limitation that if they make any ECMAScript calls, they will immediatelly throw a new <code>RangeError</code>. When a Duktape/C function returns control to Duktape, a <code>RangeError</code> is thrown as soon as ECMAScript code would be executed.</li><li>ECMAScript finalizers are triggered but will always immediately throw a <code>RangeError</code> so they cannot be reliably used in case of execution timeouts. Duktape/C finalizers work normally; however, if they invoke the bytecode executor by running ECMAScript code, a <code>RangeError</code> is immediately thrown.</li></ul><h3 id="using-the-mechanism-from-application-code" tabindex="-1">Using the mechanism from application code <a class="header-anchor" href="#using-the-mechanism-from-application-code" aria-label="Permalink to &quot;Using the mechanism from application code&quot;">​</a></h3><p>The concrete application code to use this mechanism can be e.g. as follows:</p><ul><li>Before entering untrusted code, record a start timestamp. Then call the untrusted code using e.g. <code>duk_pcall()</code>.</li><li>On each execution timeout macro call, check if too much time has elapsed since the start timestamp. If so, return 1. Keep returning 1 until the original protected call exits.</li><li>Once the protected call has exited, clear the execution timeout state.</li></ul><p>The <code>duk</code> command line tool illustrates this approach.</p><h3 id="limitation-c-code-must-not-block-during-cleanup" tabindex="-1">Limitation: C code must not block during cleanup <a class="header-anchor" href="#limitation-c-code-must-not-block-during-cleanup" aria-label="Permalink to &quot;Limitation: C code must not block during cleanup&quot;">​</a></h3><p>The timeout mechanism allows C code to clean up resources, e.g.:</p><pre><code>FILE *f = fopen(&quot;file.txt&quot;, &quot;rb&quot;);

ret = duk_pcall(ctx, 0 /*nargs*);
/* ... */

if (f) {
    fclose(f);
}
</code></pre><p>This is a useful feature to allow C code to reliably free non-memory resources not tracked by finalizers. Finalizers can only be used, but are only executed if they&#39;re Duktape/C functions: ECMAScript finalizers will immediately throw a <code>RangeError</code> because of the execution timeout.</p><p>C code must be careful to avoid entering an infinite loop (or blocking for an unreasonable amount of time) to avoid subverting the timeout mechanism:</p><pre><code>ret = duk_pcall(ctx, 0 /*nargs*);
/* ... */

/* Infinite loop, prevents propagating RangeError outwards. */
for(;;) {}
</code></pre><p>This limitation is not easy to fix because allowing C code to clean up is a basic guarantee offered at the moment.</p><h3 id="limitation-timeout-checks-are-only-made-when-executing-ecmascript-code" tabindex="-1">Limitation: timeout checks are only made when executing ECMAScript code <a class="header-anchor" href="#limitation-timeout-checks-are-only-made-when-executing-ecmascript-code" aria-label="Permalink to &quot;Limitation: timeout checks are only made when executing ECMAScript code&quot;">​</a></h3><p>Execution timeout checks are only made by the bytecode executor, i.e. when executing ECMAScript code. No timeout checks are made when executing C code. Any C code that goes into an infinite loop or blocks for an unreasonable amount of time will essentially subvert the timeout mechanism.</p><p>Relevant C code includes:</p><ul><li>Application Duktape/C functions.</li><li>Duktape internals, such as built-in functions, regexp compiler and executor, etc.</li></ul><p>As an example, the following ECMAScript code would cause a Duktape internal to run for a very long time:</p><pre><code>var a = []; a[1e9] = &#39;x&#39;;

// Results in a huge string: [ null, null, ..., null, &quot;x&quot; ]
var tmp = JSON.stringify();
</code></pre><p>Duktape places on internal sanity limit for some operations, such as regexp execution taking too many steps. When that happens a <code>RangeError</code> is thrown. Although user code can catch such an error, it returns control to the executor so that the bytecode execution timeout can kick in if necessary.</p><p>However, not all internal algorithms are currently protected like this. For instance, many Array built-ins can be abused to execute for a very long time.</p><p>To fix this limitation quite a lot of work is needed. Every built-in must be made to cooperate with the execution timeout mechanism, either by applying its own sanity timeout or by calling the user execution timeout callback to see if it&#39;s time to abort.</p><h3 id="limitation-timeout-check-is-made-only-every-nth-bytecode-instruction" tabindex="-1">Limitation: timeout check is made only every Nth bytecode instruction <a class="header-anchor" href="#limitation-timeout-check-is-made-only-every-nth-bytecode-instruction" aria-label="Permalink to &quot;Limitation: timeout check is made only every Nth bytecode instruction&quot;">​</a></h3><p>Execution timeout is only checked after every Nth bytecode instruction. Technically, it is only checked when a Duktape executor interrupt happens, which usually happens e.g. very few hundred thousand opcodes. In special cases like when a debugger is attached the interval can be much higher.</p><p>When doing heavy operations like matching regexps or some Array operations, it may take very long (measured in wall clock time) for the opcode interval to be triggered and a timeout be noticed.</p><h3 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h3><ul><li>Add an API call for execution timeout instead of a macro. The API timeout can be applied to the entire heap, or perhaps just a single call.</li><li>Allow stacking of timeouts, so that some internal operation may apply a local timeout.</li><li>Allow ECMAScript code to execute a function with a timeout.</li><li>Better finalizer support, e.g. execute finalizers normally or avoid executing finalizers at all until the timeout error has been handled. This requires the ability to postpone finalizer execution, which is also a useful feature for timing sensitive environments.</li><li>Improve built-ins so that they can cooperate with the timeout mechanism for operations that take a very long time (like regexp execution, some Array algorithms, etc).</li><li>Allow user Duktape/C code to cooperate with the timeout mechanism in a similar fashion.</li><li>Make timeout callback handling a bit more intelligent so that the callback is called e.g. when returning from a risky built-in (or perhaps any function call).</li></ul>`,110)]))}const m=t(n,[["render",r]]);export{p as __pageData,m as default};
