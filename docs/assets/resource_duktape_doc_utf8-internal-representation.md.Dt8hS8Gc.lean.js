import{_ as t,c as n,a2 as i,o as a}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"Using UTF-8 as internal representation","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/utf8-internal-representation.md","filePath":"resource/duktape/doc/utf8-internal-representation.md","lastUpdated":1732350347000}'),r={name:"resource/duktape/doc/utf8-internal-representation.md"};function o(s,e,l,c,u,d){return a(),n("div",null,e[0]||(e[0]=[i('<h1 id="using-utf-8-as-internal-representation" tabindex="-1">Using UTF-8 as internal representation <a class="header-anchor" href="#using-utf-8-as-internal-representation" aria-label="Permalink to &quot;Using UTF-8 as internal representation&quot;">​</a></h1><p>Some notes on using UTF-8 as internal representation for ECMAScript strings when surrogate pairs can be combined.</p><h2 id="current-representation" tabindex="-1">Current representation <a class="header-anchor" href="#current-representation" aria-label="Permalink to &quot;Current representation&quot;">​</a></h2><p>Current internal representation is a union of:</p><ul><li>CESU-8: to support full 16-bit codepoint sequences without limitations. In particular, individual and unpaired surrogates must work without interpretation or conversion.</li><li>UTF-8: to support non-BMP characters, if they are created from C code or e.g. using String.fromCharCode(0x12345).</li><li>Extended UTF-8: to support codepoints up to U+FFFFFFFF. This is now only needed by the regexp bytecode, which uses extended UTF-8 as its internal representation and needs to represent long offsets as codepoints.</li></ul><h2 id="c-api-problem-with-current-representation" tabindex="-1">C API problem with current representation <a class="header-anchor" href="#c-api-problem-with-current-representation" aria-label="Permalink to &quot;C API problem with current representation&quot;">​</a></h2><p>One concrete problem with this arrangement is that non-BMP strings are internally represented as CESU-8:</p><ul><li>If source code contains a non-BMP character, the ECMAScript specification requires that such a character is decoded into surrogates, from <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-6" target="_blank" rel="noreferrer">https://www.ecma-international.org/ecma-262/5.1/#sec-6</a>: <ul><li>If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16.</li></ul></li><li>This means that <code>x = &#39;\\u{12345}&#39;</code> and <code>x = &#39;\\ud808\\udf45&#39;</code> MUST be treated identically. For example, for both inputs: <ul><li>The string&#39;s <code>.length</code> must be 2.</li><li><code>x[0]</code> must be 0xd808, and <code>x[1]</code> must be 0xdf45.</li><li>RegExps must be able to match the individual surrogates, and one must be able to e.g. backtrack each surrogate separately.</li><li>It must be possible to take a substring whose one end is between the surrogate codepoints.</li></ul></li><li>In the current C API such a string will appear CESU-8 encoded because that&#39;s the internal representation used for surrogate codepoints.</li><li>Applications dealing natively with UTF-8 would often prefer to see UTF-8 rather than CESU-8, thus avoiding the need to transcode CESU-8 to UTF-8.</li></ul><p>The ECMAScript specification doesn&#39;t (and cannot) mandate any specific internal representation, nor does it provide any requirements on how a C API must represent strings. The current convention of using CESU-8 for standard ECMAScript strings is thus not really mandatory. However, if an alternative representation is used, it MUST behave identically as far as script code is concerned.</p><h2 id="automatically-combining-surrogates-in-internal-representation" tabindex="-1">Automatically combining surrogates in internal representation <a class="header-anchor" href="#automatically-combining-surrogates-in-internal-representation" aria-label="Permalink to &quot;Automatically combining surrogates in internal representation&quot;">​</a></h2><p>One alternative to the current internal representation is to:</p><ul><li>Keep the current CESU-8 + UTF-8 + extended UTF-8 as the base representation.</li><li>When conceptual ECMAScript strings contain correctly paired surrogates, combine the surrogates into the actual non-BMP codepoint. The resulting codepoint is then valid UTF-8 and not CESU-8.</li><li>When a non-paired surrogate is found, encode it as CESU-8 as before.</li><li>This process must be applied to all inputs, both script code and C code, so that a certain conceptual ECMAScript string has a unique duk_hstring representation. (If this is not the case, string comparison using an interned string pointer would no longer be valid which leads to a lot of complications.)</li></ul><p>This would have the upside that:</p><ul><li>Valid Unicode strings in UTF-8 codepoint range (U+0000 to U+10FFFF without surrogate range U+D800 to U+DFFF) would appear as valid UTF-8 (not CESU-8) in the C API.</li><li>Pushing UTF-8 strings would produce strings that behaved like standard ECMAScript strings, i.e. they would conceptually have surrogate pairs in place of non-BMP.</li></ul><p>And a few downsides:</p><ul><li>All the internal code would need to maintain an &quot;as if&quot; illusion: such strings must appear as uninterpreted 16-bit codepoint sequences, and all 16-bit codepoint sequences must still work without difference as far as script code is concerned. This is not trivial, more on this below.</li><li>One would no longer be able to push an arbitrary byte sequence as a string (duk_push_string()) and then read it back as is. The automatic surrogate combination would mean the output might be different, with surrogates represented in CESU-8 combined into UTF-8. This is a loss of current functionality which has been useful for some applications; one can e.g. push ISO-8859-1 strings as is, and read them back. Script code will see such strings as being somewhat broken, but they have previously passed through without modification.</li></ul><p>Some internals where the &quot;as if&quot; illusion must be maintained:</p><ul><li>String <code>.length</code> must count non-BMP codepoints as 2 codepoints to get the standard length.</li><li>String.charCodeAt() and all other String functions must use an index scheme that references the conceptual 16-bit codepoint sequence index (where each non-BMP counts as two indices), and allow reading, substringing, etc, both of the surrogate pairs individually.</li><li>There&#39;s no longer an easy &quot;char offset to byte offset&quot; internal primitive. Currently such a conversion maps an integer to an integer (or error). For non-BMP characters the result would now be a tuple: an integer pointing to the start of the codepoint, and a flag indicating whether we want the high or the low surrogate. All places maintaining &quot;current offset&quot; must track that additional flag somehow (it could maybe be encoded as the high bit of a 32-bit unsigned value?).</li><li>When doing string replacements, code must always check whether the replacements created valid surrogate pairs from previously unpaired surrogates. They must be merged, to maintain a unique strnig representation. Such surrogates may appear at the edges of replacement strings.</li><li>When combining strings, must check for previously unpaired surrogates at string join point.</li><li>RegExp matching must match non-BMP codepoints as two surrogates individually as far as patterns are concerned. It must be possible to capture only one of the surrogates, backtrack each surrogate individually, match start offset must try both surrogates as starting points, etc.</li><li>RegExp /u mode would work trivially with this internal representation, as the codepoints are already combined.</li></ul>',18)]))}const g=t(r,[["render",o]]);export{h as __pageData,g as default};
