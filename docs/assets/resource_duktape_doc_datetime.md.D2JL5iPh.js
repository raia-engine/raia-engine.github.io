import{_ as t,c as a,a2 as i,o as n}from"./chunks/framework.DzmM640o.js";const u=JSON.parse('{"title":"Date and time handling","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/datetime.md","filePath":"resource/duktape/doc/datetime.md","lastUpdated":1732350347000}'),o={name:"resource/duktape/doc/datetime.md"};function r(l,e,s,d,c,p){return n(),a("div",null,e[0]||(e[0]=[i(`<h1 id="date-and-time-handling" tabindex="-1">Date and time handling <a class="header-anchor" href="#date-and-time-handling" aria-label="Permalink to &quot;Date and time handling&quot;">​</a></h1><p>This document describes the Duktape <code>Date</code> built-in implementation.</p><p>Date/time handling is a major portability concern. This document describes how to implement an external Date provider and configure Duktape to use it through the <code>duk_config.h</code> header. An external Date provider allows Duktape to be compiled on exotic platforms without change to Duktape internals.</p><h2 id="overview-of-ecmascript-date-time-concepts" tabindex="-1">Overview of ECMAScript date/time concepts <a class="header-anchor" href="#overview-of-ecmascript-date-time-concepts" aria-label="Permalink to &quot;Overview of ECMAScript date/time concepts&quot;">​</a></h2><h3 id="ecmascript-time-value" tabindex="-1">ECMAScript time value <a class="header-anchor" href="#ecmascript-time-value" aria-label="Permalink to &quot;ECMAScript time value&quot;">​</a></h3><p>An ECMAScript time value is essentially a UNIX/Posix (UTC) time value measured in milliseconds without fractions:</p><ul><li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1</a></li><li><a href="http://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Unix_time</a></li></ul><p>A time value has a simple arithmetic relationship with UTC datetime (calendar) values; leap years are taken into account but leap seconds are not (as a side effect, when a leap second is inserted the ECMAScript time value conceptually jumps backwards by one second). This simple relationship allows easy, platform independent conversion between the two representations.</p><p>The definition for a valid ECMAScript time value is very strict, and an implementation is required to treat anything outside that range as an invalid time value (NaN / &quot;Invalid Date&quot;). The valid time range is 100 million days backwards and forwards from Jan 1, 1970. The minimum and maximum values are:</p><pre><code>&gt; new Date(-100e6 * 24 * 60 * 60 * 1000).toISOString()
&#39;-271821-04-20T00:00:00.000Z&#39;
&gt; new Date(+100e6 * 24 * 60 * 60 * 1000).toISOString()
&#39;+275760-09-13T00:00:00.000Z&#39;
</code></pre><p>No fractions may be present in the internal millisecond value. Even if an implementation maintained sub-millisecond time values, all return values go through the internal <code>TimeClip()</code> algorithm which coerces the value with <code>ToInteger()</code>, so there is no standard way to access sub-millisecond values.</p><h3 id="broken-down-datetime" tabindex="-1">Broken down datetime <a class="header-anchor" href="#broken-down-datetime" aria-label="Permalink to &quot;Broken down datetime&quot;">​</a></h3><p>A datetime broken down into year, month, day-of-month, hour, minute, second, millisecond, and weekday. Components can be read or written with setter and getter API calls. Broken down datetime values can be UTC time or local time, depending on the API call.</p><h3 id="string-representation-parsing-and-formatting" tabindex="-1">String representation: parsing and formatting <a class="header-anchor" href="#string-representation-parsing-and-formatting" aria-label="Permalink to &quot;String representation: parsing and formatting&quot;">​</a></h3><p>The specification provides an ISO 8601 subset to provide a platform neutral format for expressing date/time values as strings, and parsing them back from strings. Platform specific issues come into play when converting between UTC time and local time, and when formatting or parsing date values in additional platform specific formats.</p><p>To simplify, the parsing/formatting requirements are:</p><ul><li>The implementation is required to parse the ECMAScript ISO 8601 subset but may parse any other formats as well, including a larger ISO 8601 subset.</li><li>The implementation is allowed to serialize time values into arbitrary strings, as long as it can parse them back into matching time values. (This is required only if milliseconds amount is zero; a reasonable implementation will still, of course, guarantee that other components are parsed back correctly.)</li><li><code>toISOString()</code> is required to use the ECMAScript ISO 8601 subset exactly, and the resulting string must parse back to the same time value (again, only technically required if milliseconds is zero). This is the platform neutral string format which is guaranteed to work even across implementations.</li></ul><h2 id="external-date-providers" tabindex="-1">External Date providers <a class="header-anchor" href="#external-date-providers" aria-label="Permalink to &quot;External Date providers&quot;">​</a></h2><h3 id="external-date-provider-vs-direct-support" tabindex="-1">External date provider vs. direct support <a class="header-anchor" href="#external-date-provider-vs-direct-support" aria-label="Permalink to &quot;External date provider vs. direct support&quot;">​</a></h3><p>Duktape provides built-in support for Unix/Windows date/time APIs and should work out-of-the-box on these common platforms. On more exotic platforms you may need to either:</p><p>a. Implement an external &quot;Date provider&quot; and configure Duktape to use it through <code>duk_config.h</code>. You don&#39;t need to modify Duktape source. b. Modify Duktape internals to support the new platform directly, which requires changes to Duktape source/headers.</p><p>Using an external Date provider is a good default to start with. If the target platform might interest other users, you can contribute both an external Date provider (it can be packaged into Duktape examples/ directory) and Duktape changes to support the target directly.</p><h3 id="implementing-an-external-date-provider" tabindex="-1">Implementing an external Date provider <a class="header-anchor" href="#implementing-an-external-date-provider" aria-label="Permalink to &quot;Implementing an external Date provider&quot;">​</a></h3><p>To implement an external Date provider you must use the <code>duk_config.h</code> configuration model and provide the following config options:</p><ul><li><code>DUK_USE_DATE_GET_NOW</code>: mandatory, provides current ECMAScript time.</li><li><code>DUK_USE_DATE_GET_LOCAL_TZOFFSET</code>: mandatory, provides offset between UTC and local time for a given timestamp. Can always map to zero, i.e. pretend that local time matches UTC time.</li><li><code>DUK_USE_DATE_PARSE_STRING</code>: optional, parse a platform specific string into ECMAScript time.</li><li><code>DUK_USE_DATE_FORMAT_STRING</code>: optional, format ECMAScript time into a platform specific string.</li></ul><p>You also need to make sure <code>duk_config.h</code> won&#39;t use any of the Duktape built-in Date provider functions:</p><ul><li>Ensure <code>DUK_USE_DATE_{NOW,TZO,PRS,FMT}_*</code> defines are unset.</li></ul><p>There&#39;s an example dummy provider in:</p><ul><li><code>examples/dummy-date-provider/</code></li></ul><p>You can also look into the Unix/Windows Date providers built into Duktape:</p><ul><li><code>src-input/duk_bi_date_unix.c</code></li><li><code>src-input/duk_bi_date_windows.c</code></li></ul><h2 id="platform-dependencies" tabindex="-1">Platform dependencies <a class="header-anchor" href="#platform-dependencies" aria-label="Permalink to &quot;Platform dependencies&quot;">​</a></h2><h3 id="porting-requirements" tabindex="-1">Porting requirements <a class="header-anchor" href="#porting-requirements" aria-label="Permalink to &quot;Porting requirements&quot;">​</a></h3><p>The minimum requirement for porting the Date implementation to a new platform is:</p><ul><li>A function to get the current (UTC) time as an ECMAScript time value, preferably with a millisecond precision. <ul><li>In many cases the current time can be obtained directly, as is the case with <code>gettimeofday()</code> for instance.</li><li>An implementation can also get a broken down datetime for the current UTC instant, and then use the ECMAScript timevalue conversion functions to convert it to an ECMAScript time value. The conversion is entirely platform neutral, because the ECMAScript time model enforces a simple relationship between time values and calendar dates.</li></ul></li></ul><p>Without additional porting effort, string formatting and parsing will be somewhat limited (but compliant), and the local time will always be UTC. The following is thus very nice:</p><ul><li>A function to get the time offset between local time and UTC on a certain UTC instant. The E5.1 specification has separate concepts for the local time zone adjustment (LocalTZA) and daylight saving time adjustment (DaylightSavingTA(t)). The ECMAScript conversion semantics, especially with respect to handling of daylight savings, must be followed.</li></ul><p>Finally, these are nice-to-have to provide support for Date string formats other than ISO 8601 (which is always supported):</p><ul><li>A function to format a Date value in a platform dependent manner.</li><li>A function to parse a Date value from a string in a platform dependent manner.</li></ul><h3 id="platform-specific-formatting-and-parsing" tabindex="-1">Platform specific formatting and parsing <a class="header-anchor" href="#platform-specific-formatting-and-parsing" aria-label="Permalink to &quot;Platform specific formatting and parsing&quot;">​</a></h3><p>The current approach to using platform specific formatting/parsing APIs is as follows:</p><ul><li>The primary requirement is to provide a portable base implementation which is as platform neutral as possible. Timestamps can be formatted in a ISO 8601-like manner, and local time can be assumed to be UTC if no timezone and/or DST information is available.</li><li>Platform specific local time and locale mechanisms can be used, as long as they don&#39;t restrict the ECMAScript time range. For instance, if the valid platform datetime range is smaller than ECMAScript&#39;s, the implementation must either fall back to default handling if the range is exceeded, or extrapolate in a reasonable manner.</li></ul><p>The ECMAScript valid datetime range is huge, and may be larger than what the underlying platform supports. This poses challenges to detect e.g. daylight savings time reliably. For instance, if the platform has a Y2038 limit, how does one query for daylight savings time for the year 200000?</p><p>The E5.1 specification provides explicit guidance for this; Section 15.9.1.8:</p><blockquote><p>If the host environment provides functionality for determining daylight saving time, the implementation of ECMAScript is free to map the year in question to an equivalent year (same leap-year-ness and same starting week day for the year) for which the host environment provides daylight saving time information. The only restriction is that all equivalent years should produce the same result.</p></blockquote><p>However, the equivalent year mapping approach is not necessarily preferred in the long term see e.g. the following discussion:</p><ul><li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=351066" target="_blank" rel="noreferrer">https://bugzilla.mozilla.org/show_bug.cgi?id=351066</a></li></ul><p>Note that using a platform specific API to get timezone offset and DST information makes programs behave slightly differently across platforms, even when they are running with the same locale. There&#39;s no way around this unless the locale information needed by Duktape is provided by a portable or pluggable provider (e.g. user callback for tzoffset/DST information).</p><h3 id="linux" tabindex="-1">Linux <a class="header-anchor" href="#linux" aria-label="Permalink to &quot;Linux&quot;">​</a></h3><p>Current implementation uses:</p><ul><li><code>gettimeofday()</code></li><li><code>strptime()</code></li><li><code>strftime()</code></li></ul><p>APIs available for formatting datetime values:</p><ul><li><code>ctime_r()</code></li><li><code>asctime_r()</code></li><li><code>strftime()</code></li></ul><p>APIs available for parsing datetime values:</p><ul><li><code>strptime()</code>: quite portable, but requires an explicit format string</li><li><code>getdate_r()</code>: GNU specific, more generic, but requires <code>DATEMSK</code> to be set</li></ul><p>See also:</p><ul><li><a href="http://www.gnu.org/software/libc/manual/html_node/Date-and-Time.html#Date-and-Time" target="_blank" rel="noreferrer">http://www.gnu.org/software/libc/manual/html_node/Date-and-Time.html#Date-and-Time</a></li></ul><h3 id="macos-darwin" tabindex="-1">macOS / Darwin <a class="header-anchor" href="#macos-darwin" aria-label="Permalink to &quot;macOS / Darwin&quot;">​</a></h3><p>Current implementation uses the same functions as on Linux.</p><h3 id="windows" tabindex="-1">Windows <a class="header-anchor" href="#windows" aria-label="Permalink to &quot;Windows&quot;">​</a></h3><p>Current implementation uses time functions documented in:</p><ul><li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725473(v=vs.85" target="_blank" rel="noreferrer">http://msdn.microsoft.com/en-us/library/windows/desktop/ms725473(v=vs.85</a>).aspx</li></ul><p>The same implementation works for WIN32 and WIN64.</p><p>See also:</p><ul><li><a href="http://www.suacommunity.com/dictionary/gettimeofday-entry.php" target="_blank" rel="noreferrer">http://www.suacommunity.com/dictionary/gettimeofday-entry.php</a></li></ul><h2 id="parsing-the-e5-iso-8601-subset" tabindex="-1">Parsing the E5 ISO 8601 subset <a class="header-anchor" href="#parsing-the-e5-iso-8601-subset" aria-label="Permalink to &quot;Parsing the E5 ISO 8601 subset&quot;">​</a></h2><p>E5.1 Section 15.9.1.15 describes the subset, with the following possible parts:</p><pre><code>YYYY         T       HH:mm           empty
YYYY-MM              HH:mm:ss        Z
YYYY-MM-DD           HH:mm:ss.sss    +HH:mm
+YYYYYY                                 -HH:mm
+YYYYYY-MM
+YYYYYY-MM-DD
-YYYYYY
-YYYYYY-MM                                ^
-YYYYYY-MM-DD                             |
                                       |
   |   may skip time part              |
   \`-----------------------------------&#39;
</code></pre><p>A valid date time string may contain only a date part or both a date and a time part, followed by an optional timezone part. A missing timezone is interpreted the same as a &#39;Z&#39;.</p><p>An implementation is allowed to parse a wider set of strings, so an implementation can actually be made simpler by checking the input format less rigidly. Some reasonable relaxations:</p><ul><li>Allow an arbitrary number of digits for any date part, including leading zeroes. Millisecond digits after the third one can be ignored (which is the same as truncation towards zero).</li><li>Allow year to be signed regardless of the number of year digits.</li><li>Allow date/time separator to be a space in addition to &#39;T&#39;.</li><li>Allow a timezone offset to be specified without colon (e.g. <code>+1234</code> in addition to <code>+12:34</code>).</li><li>Allow unnormalized components. In fact, the specification actually requires accepting these two as equivalent: <code>1995-02-04T24:00</code> and <code>1995-02-05T00:00</code>. Other unnormalized cases could be accepted too, like <code>1995-02-123T11:2345:99</code>.</li><li>Allow whitespace in additional places; in particular, before and after the string.</li></ul><p>V8 seems to relax the rules if the date/time separator is a space but will be strict if the separator is &#39;T&#39;:</p><pre><code>&gt; new Date(&#39;+0001979-0001-0000002T00003:0004:00005.006123123Z&#39;).toISOString()
RangeError: Invalid time value

&gt; new Date(&#39;+0001979-0001-0000002 00003:0004:00005.006123123Z&#39;).toISOString()
&#39;1979-01-02T03:04:05.006Z&#39;

&gt; new Date(&#39;  +0001979-0001-0000002 00003:0004:00005.006123123 +01:00  &#39;).toISOString()
&#39;1979-01-02T02:04:05.006Z&#39;
</code></pre><p>Some options for implementation a compact parser:</p><ul><li>Use an internal regexp to match the parts, then convert them to integers (accepting leading zeroes).</li><li>Use a set of partial <code>sscanf()</code> calls.</li><li>Use a custom char-by-char parser.</li></ul><p>With a relaxed format a custom char-by-char parser is relatively simple and is the current implementation approach:</p><ol><li>Strip the input string (remove leading and trailing whitespace). (Currently not done.)</li><li>Initialize a broken down timestamp with default values. Initialize part_index to 0. Check first character to handle year sign.</li><li>Parse a decimal number of 1...n digits. When it is finished, write it to part_index.</li><li>Check the next character to determine what to do next: update part_index (either by one or skip directly to &quot;hour&quot; part) and parse next part, or accept/reject. The separator for timezone offset may be &#39;+&#39; or &#39;-&#39;, which needs to be recorded.</li><li>If accepted, subtract timezone hours and minutes from the hours and minutes part (to convert to UTC), and then convert the (possibly unnormalized) components into an ECMAScript time value.</li></ol><p>The parser will produce the following &quot;parts&quot;:</p><ul><li>Year, default: 1970 (actually arbitrary, because a year is always required)</li><li>Month, default: 1</li><li>Day-of-month, default: 1</li><li>Hour, default: 0</li><li>Minute, default: 0</li><li>Second, default: 0</li><li>Millisecond, default: 0</li><li>Timezone hours, default: 0</li><li>Timezone seconds, default: 0</li></ul><p>The current implementation is a rule-driven parser based on this basic model.</p><h2 id="misc-notes" tabindex="-1">Misc notes <a class="header-anchor" href="#misc-notes" aria-label="Permalink to &quot;Misc notes&quot;">​</a></h2><ul><li>Almost all API calls require a Date instance as the &#39;this&#39; binding (a TypeError is thrown otherwise). Exceptions are noted in the specification; concretely, <code>toJSON()</code>.</li><li>The internal time value always exists for a Date instance, and is always a number. The number value is either NaN, or a finite number in the valid E5 range, with no millisecond fractions. The internal component representation uses zero-based day and month, while ECMAScript API uses one-based day and zero-based month.</li><li>When the internal time value is broken into components, each component will be normalized, and will fit into a 32-bit signed integer. When using setter calls, one or more components are replaced with unnormalized values, which will not necessarily fit into a 32-bit signed integer, before converting back to an internal time value. The setter values may be huge (even out of 64-bit range) without resulting in an invalid result date, if multiple cancelling values are given (e.g. 1e100 seconds and -1e103 milliseconds, cancelling to zero).</li><li>Setters and getters are optimized for size, to use a single helper with a set of flags and arguments to keep each getter and setter itself very small. This makes them a bit cryptic; see e.g. handling of setters with optional parameters.</li></ul>`,82)]))}const h=t(o,[["render",r]]);export{u as __pageData,h as default};
