import{_ as a,c as t,a2 as n,o as r}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"Duktape threading","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/threading.md","filePath":"resource/duktape/doc/threading.md","lastUpdated":1732350347000}'),o={name:"resource/duktape/doc/threading.md"};function s(i,e,c,l,d,h){return r(),t("div",null,e[0]||(e[0]=[n('<h1 id="duktape-threading" tabindex="-1">Duktape threading <a class="header-anchor" href="#duktape-threading" aria-label="Permalink to &quot;Duktape threading&quot;">​</a></h1><h1 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h1><p>This document describes native threading options that can be used with Duktape.</p><p>The basic threading rules are as follows.</p><h2 id="only-one-active-native-thread-at-a-time-per-duktape-heap" tabindex="-1">Only one active native thread at a time per Duktape heap <a class="header-anchor" href="#only-one-active-native-thread-at-a-time-per-duktape-heap" aria-label="Permalink to &quot;Only one active native thread at a time per Duktape heap&quot;">​</a></h2><p>A Duktape heap can only be accessed by one native thread at a time. There are no concurrency protection mechanisms inside Duktape so whenever two threads call into Duktape, even when seemingly not interacting with the same objects, the results are unpredictable and memory unsafe behavior may happen.</p><p>The simplest way to use multiple threads is for only one native thread to call into Duktape API at a time. If a call is made, e.g. using <code>duk_call()</code>, control flow is transferred to Duktape for the duration of the call. Within that call further ECMAScript and Duktape/C function calls can be made, and multiple Duktape threads (coroutines, not to be confused with native threads) can execute. Once the initial call returns it&#39;s safe to call into the Duktape API from another native thread, as long as there&#39;s some application mechanism (e.g. a mutex) in place to ensure only one thread does so.</p><h2 id="a-native-thread-can-be-suspended-and-resumed-later" tabindex="-1">A native thread can be suspended and resumed later <a class="header-anchor" href="#a-native-thread-can-be-suspended-and-resumed-later" aria-label="Permalink to &quot;A native thread can be suspended and resumed later&quot;">​</a></h2><p>It&#39;s also possible for a Duktape/C call inside an active call stack to be temporarily suspended using <code>duk_suspend()</code> and later resumed using <code>duk_resume()</code>. Between the two API calls the suspended native thread must not make any other Duktape API calls. The application must ensure that no other thread is using Duktape when <code>duk_resume()</code> is called, e.g. using a mutex.</p><p>The suspend/resume mechanism allows a blocking Duktape/C function to release control of the Duktape heap so that other native threads can execute other code within the same heap (also suspending if they encounter blocking operations).</p><h2 id="multiple-native-threads-can-execute-code-on-separate-duktape-heaps" tabindex="-1">Multiple native threads can execute code on separate Duktape heaps <a class="header-anchor" href="#multiple-native-threads-can-execute-code-on-separate-duktape-heaps" aria-label="Permalink to &quot;Multiple native threads can execute code on separate Duktape heaps&quot;">​</a></h2><p>Multiple threads can use different Duktape heaps: each heap is entirely independent.</p><p>Although Duktape itself is fully re-entrant, there are some situations (discussed separately below) which can limit re-entrancy and prevent running multiple threads at the same time, even when they run code in separate Duktape heaps.</p><h1 id="platform-limitations-on-re-entrancy" tabindex="-1">Platform limitations on re-entrancy <a class="header-anchor" href="#platform-limitations-on-re-entrancy" aria-label="Permalink to &quot;Platform limitations on re-entrancy&quot;">​</a></h1><h2 id="lack-of-variadic-preprocessor-macros" tabindex="-1">Lack of variadic preprocessor macros <a class="header-anchor" href="#lack-of-variadic-preprocessor-macros" aria-label="Permalink to &quot;Lack of variadic preprocessor macros&quot;">​</a></h2><p>When variadic preprocessor macros are not available, Duktape currently passes some fields through globals in that case. This creates a race condition where error information (<code>__FILE__</code> and <code>__LINE__</code>, for instance) can be corrupted for errors thrown in different Duktape heaps.</p><p>This should not cause unsafe behavior but may corrupt error messages or tracebacks.</p><p>::: note ::: title Note :::</p><p>This limitation can be fixed by passing these values through duk_context (duk_hthread) instead of globals, but at the moment Duktape public API macros don&#39;t access duk_hthread directly. There is no longer a reason for this limitation because duktape.h sees the internal structures (even when compiling application code). A fix is scheduled for Duktape 1.1 release. :::</p><h2 id="non-re-entrant-system-calls" tabindex="-1">Non-re-entrant system calls <a class="header-anchor" href="#non-re-entrant-system-calls" aria-label="Permalink to &quot;Non-re-entrant system calls&quot;">​</a></h2><p>Duktape uses some system calls which don&#39;t always have re-entrant variants (or perhaps the re-entrant variants don&#39;t work). This mainly impacts the Date built-in, which uses <code>gmtime_r()</code> and <code>localtime_r()</code> on UNIX when they are available, but falls back to <code>gmtime()</code> and <code>localtime()</code> if the platform doesn&#39;t support them.</p><p>The impact on multithreading behavior depends on the non-re-entrant system calls in question.</p><p>A few workarounds:</p><ul><li>Implement your own re-entrant native functions (e.g. date/time functions) for those not provided by your platform. You&#39;ll need to change Duktape internals to make Duktape use the replacements.</li><li>Replace the built-ins (such as <code>Date</code>) entirely with a replacement written specifically for your platform. This approach may allow you to avoid changes to Duktape internals as the non-re-entrant calls won&#39;t be used.</li></ul>',24)]))}const m=a(o,[["render",s]]);export{u as __pageData,m as default};
