import{_ as t,c as o,a2 as n,o as a}from"./chunks/framework.CuCbyi2k.js";const u=JSON.parse('{"title":"Duktape ES5.1コンパイラ","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/compiler.md","filePath":"resource/duktape/doc/compiler.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/compiler.md"};function r(s,e,l,c,d,p){return a(),o("div",null,e[0]||(e[0]=[n(`<h1 id="duktape-es5-1コンパイラ" tabindex="-1">Duktape ES5.1コンパイラ <a class="header-anchor" href="#duktape-es5-1コンパイラ" aria-label="Permalink to &quot;Duktape ES5.1コンパイラ&quot;">​</a></h1><h2 id="はじめに" tabindex="-1">はじめに <a class="header-anchor" href="#はじめに" aria-label="Permalink to &quot;はじめに&quot;">​</a></h2><p>本書では、Duktape ES5.1コンパイラの構造、基本的なコンパイルプロセス、およびコンパイルが困難な構成要素に関する注意事項を説明します。レキサーとコンパイラの設計上の注意点については、特定の順序によらず、別のセクションで説明します（これらは、最初の実装パスで収集した生のメモです）。今後の課題として、既知の改善点を挙げています（網羅的ではありません）。</p><p>主な変更点は、何らかの形で中間表現（IR）を追加することで、おそらく文レベルの表現ツリーか完全な表現ツリーになるでしょう。IRを持つことで、いくつかの最適化も可能になります。</p><p>このドキュメントは、設計上の問題点のスナップショットであり、コンパイラを正確に最新に保つことはできません。この文書はDuktape 1.0用に書かれたものなので、古くなっている部分があるかもしれません。</p><h2 id="compilation-overview" tabindex="-1">Compilation overview <a class="header-anchor" href="#compilation-overview" aria-label="Permalink to &quot;Compilation overview&quot;">​</a></h2><h3 id="basics" tabindex="-1">Basics <a class="header-anchor" href="#basics" aria-label="Permalink to &quot;Basics&quot;">​</a></h3><p>The compiler converts source code containing global code, eval code, or function code into an executable form. The most important parts of that form are bytecode, constants, function metadata, and inner function templates. Compilation can also end in a <code>SyntaxError</code>, which are mandated to be &quot;early errors&quot; in ECMAScript, or some internal error, such as out of memory error.</p><p>The end result of compilation is more specifically a <em>function template</em>. A function template does not yet have a lexical environment, it merely refers to symbols outside of its own scope by name. A function template is instantiated into a closure which supplies the missing lexical environment. Inner functions are also function templates, and multiple closures may be created from a certain template:</p><pre><code>// For each invocation of f(), a separate closure of g() is created
function f(x) {
  function g() {
    print(x);
  }
  return g;
}
</code></pre><p>Compilation depends on two major components:</p><ul><li>A <em>lexer</em>, which generates tokens from an underlying input stream on request. The lexer supports backtracking and reparsing to allow multi-pass parsing, at the cost of not currently supporting streamed parsing (adding support for chunked streaming would be possible, see future work).</li><li>A <em>compiler</em>, which generates bytecode from a token stream. The compiler uses two (or more) passes over a function, and generates bytecode directly, avoiding an explicit intermediate representation. An <em>intermediate value</em> (ivalue) concept is used instead for managing expression values.</li></ul><p>Code and memory footprint concern originally lead to the decision to avoid a comprehensive intermediate representation in the compiler; a limited intermediate value concept is used instead. This complicates compilation somewhat but reduces memory footprint. A more comprehensive intermediate representation will be needed in future versions to fully support ES2015.</p><h3 id="lexer" tabindex="-1">Lexer <a class="header-anchor" href="#lexer" aria-label="Permalink to &quot;Lexer&quot;">​</a></h3><p>The lexer has a straightforward design:</p><ul><li>Source code is decoded from UTF-8 into a window of Unicode codepoints, with an infinite number of virtual EOF codepoints following the end-of-input. The decoder supports rewinding: the current position in the source stream can be saved and restored at a later time.</li><li>The main lexing function decodes individual tokens like keywords, numbers, identifiers, etc, using the codepoint window for a safe lookup. The lexing function keeps track of token line number and source byte offset information, and the eligibility of tokens for automatic semicolon insertion.</li></ul><p>The upside of the codepoint window is that character encoding is effectively hidden and normalized in the process, and that the main lexing function can safely do forward lookups up to a certain limit without explicit end-of-input checks. It would also be possible to support encodings other than UTF-8 quite easily. The downside is a small performance impact over hardcoding the lexer for UTF-8 input, which would also be a viable design.</p><h3 id="compiler" tabindex="-1">Compiler <a class="header-anchor" href="#compiler" aria-label="Permalink to &quot;Compiler&quot;">​</a></h3><p>The compiler component uses a hand crafted recursive descent statement parser, with somewhat tricky handling of a few ECMAScript constructs (like the &quot;for/for-in&quot; statement). In contrast, top-down operator parsing is used for parsing expressions (see <a href="https://www.crockford.com/javascript/tdop/tdop.html" target="_blank" rel="noreferrer">https://www.crockford.com/javascript/tdop/tdop.html</a>) which is nice in that it allows single pass parsing while generating mostly nice bytecode.</p><p>Compilation is triggered by Duktape C API compilation/eval calls, <code>eval()</code> calls, or <code>Function</code> constructor calls. The calling context provides the necessary flags to indicate whether global code, eval code, or function code is being compiled. The global compiler state is set up, and a &quot;current function&quot; is set up with matching the requested compilation context. The function body is then parsed with a multi-pass parser, resulting in final bytecode, constants, inner functions, and a lot of other state (for example, flags indicating whether the function accesses <code>argument</code> or <code>eval</code>; this state is needed to optimize functions). Finally, the &quot;current function&quot; is converted from the compiler representation to the run-time function (template) format used by the executor.</p><p>Statement parsing is straightforward: a function body is parsed as a sequence of &quot;source elements&quot; which are otherwise the same as statements but function declarations are also allowed (Duktape allows function declarations anywhere in a function for compatibility with existing code and other engines, however). For global code and eval code there&#39;s a need to support an &quot;implicit return value&quot; which requires tracking of statement values; implicit return value is not needed for function code.</p><p>Expressions are parsed into <em>intermediate values</em> (ivalues) which are one step from being concrete, fully referenced values. This missing step allows ivalues to be used both as left-hand-side values (assignment targets) and right-hand-side values (evaluated values), and allows limited constant folding at compile time. An ivalue may, for example, represent:</p><ul><li>A constant value which is not yet registered to the function constant table (e.g. the string <code>&quot;foo&quot;</code>).</li><li>A constant registered to the function constant table (denoted e.g. <code>C18</code> for constant 18).</li><li>A register in the function register frame (denoted e.g. <code>R23</code> for register 23).</li><li>A variable access using a variable name.</li><li>A property access with a base value and a key, with the base value and key being registers or constants.</li><li>A unary or binary arithmetic operation.</li></ul><p>One way to characterize ivalues is that instead of using a full expression tree as an intermediate representation, the compiler uses small, local fragments of that tree without ever constructing the full tree. Each ivalue is either a leaf node or an internal node with two leaf node children.</p><p>When parsing an expression the compiler typically creates an ivalue to represent the value of the expression; some bytecode may be emitted in the process to prepare registers/constants for the ivalue but this is not always the case. The ivalue may then be used as an input to another expression, converted from one form to another if necessary. This conversion process may allocate new constants or registers, and emit bytecode as necessary. For example, the result of a previously parsed ivalue representing an addition operation may be needed in a single register/constant. The compiler converts the ivalue by allocating a temporary register and emitting the ADD opcode to compute the result. The temporary register can then be used as an input in another ivalue as needed.</p><p>Creating ivalues for expressions and converting ivalues from one form to another drives much of the code generation process. The ivalue conversion helpers can also perform limited optimization, such as constant folding for numbers and strings.</p><p>Bytecode emission is conceptually quite simple: expression and ivalue handling code simply request opcodes to be emitted as needed. However, the bytecode emission functions transparently handle <em>register shuffling</em> to extend the range of addressable registers. For example, the binary <code>ADD X, Y, Z</code> opcodes can directly only address an 8-bit target register (X) and two 8-bit source registers or constants (Y and Z). If any arguments exceed their allowed range, the bytecode emission functions emit the necessary opcodes to shuffle source and/or target values through temporary registers. While such code is not optimal, it is necessary to support very large functions (for example those produced by Emscripten).</p><p>Two (or more) passes are made over every parsed function. On the first pass we don&#39;t know which variables and inner functions the function will declare, as such declarations are conceptually &quot;hoisted&quot; to the top of the function. One purpose of the first pass is to gather this information for the second pass. Even so, to keep the code simple, the first pass also generates &quot;broken&quot; throw-away bytecode so that the same parsing code can be used for all passes.</p><p>On the second pass all the necessary information has been gathered and actual bytecode can be emitted. A simple in-place peephole optimizer is applied to the bytecode before generating final bytecode. The peephole optimizer currently only straightens out JUMPs (JUMP-&gt;JUMP-&gt;X is converted to JUMP-&gt;X).</p><p>The temporary registers needed for shuffling are only allocated when they&#39;re actually needed. Typically this is noticed on the first pass, but in some cases it is only detected on the second pass; in such cases a third pass is needed to generate the final bytecode.</p><p>This multi-pass approach has several downsides: (1) it requires a lexer which can backtrack to the beginning of the function; and (2) time is wasted in lexing and compiling the function twice (in an initial design inner functions would also get parsed <em>four times</em> in total, their inner functions <em>eight times</em> in total, etc, but there&#39;s a specific solution to this problem in the current compiler). The upside of multi-pass parsing is that there is no need for an intermediate representation which saves on memory footprint.</p><p>The statement parser keeps track of a &quot;statement number&quot; within the current function. This is not needed for any critical purpose, but it allows the first compilation pass to stash information related to a certain statement for the second pass, perhaps allowing more optimal code generation. For instance, the first pass could note that a loop statement has no relevant break/continue statements, so a label site is not actually needed. Similar expression counts, token counts, or source offsets could be used to address constructs to help in multi-pass parsing. However, no such optimizations are currently used by the compiler.</p><p>Recursive expression parsing, statement parsing, and function parsing may happen during parsing; for example, a function expression may appear almost anywhere and trigger recursive function compilation. To fully support recursion in function parsing, all compilation state is kept in the &quot;current function&quot; state rather than the global compiler state.</p><p>Both the lexer and compiler need to deal with the fact that garbage collection may occur almost anywhere (which may even lead to nested compilation if a finalizer is invoked), errors may be thrown almost anywhere, and so on. All resources must thus be visible to the garbage collector and correctly reference counted at nearly all times. The current approach to deal with this is to use the current thread&#39;s value stack to stash token values, intermediate values, identifier names, etc. Slots are allocated from the value stack as necessary. This is a bit complicated; some alternatives:</p><ul><li>Finalization (and possibly mark-and-sweep) could be prevented during compilation.</li><li>Make the compiler state a traversable object type visible to garbage collection.</li></ul><h3 id="ivalue-example" tabindex="-1">Ivalue example <a class="header-anchor" href="#ivalue-example" aria-label="Permalink to &quot;Ivalue example&quot;">​</a></h3><p>Expression parsing and ivalue manipulation drives most of the code generation process. Let&#39;s look at a concrete example how these work together to generate bytecode.</p><p>Consider the statement:</p><pre><code>x.y.z = 1 + 2;
</code></pre><p>The steps taken to compile the statement are roughly:</p><ul><li>The &quot;x&quot; expression generates ivalue I1 of type &quot;variable access&quot; with the variable name &quot;x&quot;, which is not yet allocated a constant identifier. No code is emitted.</li><li>The &quot;.y&quot; part generates ivalue I2 of type &quot;property access&quot;: <ul><li>The base value (I1) needs to be a register or a constant, so a constant C0 is allocated for the variable name (<code>&quot;x&quot;</code>) and a temporary register R0 for the value, and bytecode to read the variable is emitted (<code>GETVAR R0, C0</code>).</li><li>The key needs to be a register or constant, so a constant C1 is allocated for the key (<code>&quot;y&quot;</code>). No bytecode needs to be emitted.</li><li>I2 base value is R0, key is C1.</li></ul></li><li>The &quot;.z&quot; part generates ivalue I3 of type &quot;property access&quot;: <ul><li>The base value (I2) is coerced into a new temporary register R1 by emitting bytecode for the property load (<code>GETPROP R1, R0, C1</code>).</li><li>A constant C2 is allocated for the key (<code>&quot;z&quot;</code>).</li><li>I3 base value is R1, key is C2.</li></ul></li><li>The compiler notices an assignment operator and parses the right side. The constants 1 and 2 are compiled into ivalues I4 and I5 initially, and the combined into an ivalue I6 representing the addition of two constants. No code is emitted for the addition yet.</li><li>To perform the assignment the right-hand side (I6) needs to be coerced into a single register/constant. For this specific ivalue the compiler notices that two integer constants are being added so constant folding is used. The compiler allocates a temporary register R2 and emits bytecode to load the integer (<code>LDINT R2, 3</code>). The ivalue I7 represents the result in R2. (The compiler could also register a new constant instead of using an integer load, but (some) integers are more efficiently handled using direct integer loads.)</li><li>Finally, the assignment operation uses I3 as its target and I7 as its source, emitting a property write (<code>PUTPROP R1, C2, R2</code>). Here I3 is used as a left-hand side value (write target) rather than as a right-hand side value.</li></ul><p>While there are multiple steps and ivalues, the bytecode emitted from this process is relatively short (the opcodes here are for illustration only and don&#39;t match 1:1 with the actual opcodes used by Duktape):</p><pre><code>; Constant C0: &quot;x&quot;
; Constant C1: &quot;y&quot;
; Constant C2: &quot;z&quot;

GETVAR R0, C0        ; read variable &quot;x&quot; to R0
GETPROP R1, R0, C1   ; read property R0[&quot;y&quot;] (= x.y) to R1
LDINT R2, 3          ; load integer 3 to R2
PUTPROP R1, C2, R2   ; write property R1[&quot;z&quot;] (= x.y.z), value R2 (integer 3)
</code></pre><p>As can be seen from the example, ivalues are convenient in that the final result of a property expression has a single format (an ivalue) which is one step removed from the final value. This allows them to be used both as left-hand-side and right-hand-side values; the decision is made by the caller in the final conversion. Optimizations are also possible when converting ivalues from one form to the next.</p><p>Ivalue conversion also provides a lot of flexibility: if the result of a previous expression isn&#39;t directly compatible with the needs of the expression being parsed, ivalues can be converted to the required form. Because ivalues are one step away from being completed, inefficient conversions are mostly (but certainly not always) avoided. For example, an ivalue representing an integer can be converted either to a register or a constant, with the necessary bytecode only emitted when it&#39;s known which one is preferred.</p><p>Several details are omitted from this description; for example:</p><ul><li>The compiler tries to reuse temporary registers where possible to reduce the number of temporaries needed.</li><li>Local variables (including arguments) are assigned to registers and are accessed directly without an explicit variable read/write operation (GETVAR or PUTVAR).</li><li>Register shuffling might be needed; it is currently handled transparently by the bytecode emission functions.</li></ul><h3 id="bytecode" tabindex="-1">Bytecode <a class="header-anchor" href="#bytecode" aria-label="Permalink to &quot;Bytecode&quot;">​</a></h3><p>The bytecode opcodes used by Duktape are chosen simply to work well for both compilation and execution. The bytecode is not version compatible, and may change arbitrarily in even minor versions. The role of Duktape bytecode is not to be a code distribution format like e.g. Java bytecode.</p><p>The bytecode executor is the best source for documentation on exact bytecode semantics at any given time. Opcode information must be sync in:</p><ul><li><code>src-input/duk_js_bytecode.h</code> defines opcode names and various constants</li><li><code>src-input/duk_js_compiler.c</code> emits bytecode</li><li><code>src-input/duk_js_executor.c</code> interprets bytecode</li><li><code>debugger/duk_opcodes.yaml</code> provides opcode metadata in a programmatic format, used by the debugger Web UI for bytecode dumping</li></ul><h3 id="code-organization" tabindex="-1">Code organization <a class="header-anchor" href="#code-organization" aria-label="Permalink to &quot;Code organization&quot;">​</a></h3><p>The main entry point to compilation is <code>duk_js_compile()</code> in <code>duk_js_compiler.c</code>.</p><p><code>duk_lexer.c</code> and <code>duk_lexer.h</code> contain the entire lexer implementation. Tokens are represented by <code>duk_token</code>. Two slots are reserved from the value stack for token values (regexp literals need two slots: pattern and flags) to keep the values reference counted.</p><p><code>duk_js_compiler.c</code> and <code>duk_js_compiler.h</code> contain the entire compiler implementation: function, statement and expression parsers, bytecode emission, ivalue manipulation, and assorted support functionality like label and constant management. The compiler was originally written as a single file for efficient inlining, before source files were combined into a single file in the dist process.</p><p>Compilation state is encapsulated into <code>duk_compiler_ctx</code>, which includes:</p><ul><li>Tokenization state</li><li>Control structure for the current function being compiled; the function structure includes: <ul><li>Code generation state: bytecode, identifier bindings, constants, temporary register state, label state, etc</li><li>Control variables for the current expression being parsed</li></ul></li><li>Various control flags which operate at the entry point level</li></ul><p>Intermediate values are represented by <code>duk_ivalue</code> and <code>duk_ispec</code>. These need value stack slots for storing values such as strings.</p><p>A function being compiled is represented by the inner representation <code>duk_compiler_func</code> which is converted into an actual function object (a template) once compilation is finished. The intermediate function refers to a number of allocated value stack locations for storing compilation data such as label information, known identifiers, bytecode emitted, etc. There are also support state and structures like <code>duk_labelinfo</code>.</p><p>Bytecode is generated as a sequence of <code>duk_compiler_instr</code> structs. These contain an actual instruction (<code>duk_instr_r</code>) and line information. Line information is compressed into a compact bit-packed run-time format (pc2line) at the end of function compilation.</p><h2 id="general-design-notes" tabindex="-1">General design notes <a class="header-anchor" href="#general-design-notes" aria-label="Permalink to &quot;General design notes&quot;">​</a></h2><p>This section lists miscellaneous issues affecting lexer and compiler design.</p><h3 id="c-recursion-depth" tabindex="-1">C recursion depth <a class="header-anchor" href="#c-recursion-depth" aria-label="Permalink to &quot;C recursion depth&quot;">​</a></h3><p>C recursion depth or C stack size needs to be reasonably limited for compatibility with some embedded environments with small stacks.</p><h3 id="avoiding-memory-churn" tabindex="-1">Avoiding memory churn <a class="header-anchor" href="#avoiding-memory-churn" aria-label="Permalink to &quot;Avoiding memory churn&quot;">​</a></h3><p>Minimizing the number of alloc/realloc/free operations is desirable for all environments. Memory churn has a performance impact and also increases the chance that memory gets fragmented which is an issue for some (but not all) allocators.</p><p>A few examples on how to avoid memory churn:</p><ul><li>Use fixed size buffers when possible, e.g. for codepoint decode window.</li><li>Use a shared temporary buffer for parsing string valued tokens, reusing the buffer. Most keywords and literal strings will easily fit into a few hundred without ever needing to resize the temporary buffer.</li><li>Minimize resizes of the bytecode emission buffer. For example, when starting second compilation pass, keep the current bytecode buffer without resizing it to a smaller size.</li></ul><h3 id="memory-usage-patterns-for-pooled-allocators" tabindex="-1">Memory usage patterns for pooled allocators <a class="header-anchor" href="#memory-usage-patterns-for-pooled-allocators" aria-label="Permalink to &quot;Memory usage patterns for pooled allocators&quot;">​</a></h3><p>For low memory environments using pool allocation, any large allocations that grow without bounds are awkward to handle because selecting the pool sizes becomes difficult. It is preferable to do a lot of smaller allocations with a bounded size instead; typical pool configurations provide a lot of small buffers from 4 to 64 bytes, and a reasonable number of buffers up to 256 bytes. Above that buffer counts are smaller and tightly reserved.</p><p>There are a few unbounded allocations in the current solution, such as current bytecode being emitted.</p><h2 id="lexer-design-notes" tabindex="-1">Lexer design notes <a class="header-anchor" href="#lexer-design-notes" aria-label="Permalink to &quot;Lexer design notes&quot;">​</a></h2><p>This section has small lexer design notes in no specific order. Larger issues are covered in dedicated sections below.</p><h3 id="tokenization-is-stateful" tabindex="-1">Tokenization is stateful <a class="header-anchor" href="#tokenization-is-stateful" aria-label="Permalink to &quot;Tokenization is stateful&quot;">​</a></h3><p>Tokenization is affected by:</p><ul><li>Strictness of the current context, which affects the set of recognized keywords (reserved words, to be more precise).</li><li>Regexp mode, i.e. whether a literal regexp is allowed in the current context. This is the case because regexp literals use the forward slash which is easily confused with a division expression. Currently handled by having a table indicating which tokens may not be followed by a RegExp literal.</li><li>In some contexts reserved words are recognized but in others they must be interpreted as identifiers: an <code>Identifier</code> production accepts any <code>IdentifierName</code> except for <code>ReservedWord</code>. Both <code>Identifier</code> and <code>IdentifierName</code> appear in constructs. The current approach is to supply both the raw identifier name and a possible reserved word in <code>duk_token</code>. The caller can then decide which is appropriate in the caller&#39;s context.</li></ul><h3 id="source-code-encoding-is-not-specified" tabindex="-1">Source code encoding is not specified <a class="header-anchor" href="#source-code-encoding-is-not-specified" aria-label="Permalink to &quot;Source code encoding is not specified&quot;">​</a></h3><p>The E5.1 specification does not mandate any specific source code encoding. Instead, source code is assumed to be a 16-bit codepoint sequence for specification purposes (E5.1 Section 6). Current choice is for the source code to be decoded in UTF-8. Changing the supported encoding(s) would be easy because of the codepoint decoding window approach, but it&#39;s preferred that calling code transcode non-UTF-8 inputs into UTF-8.</p><p>Source code may contain non-BMP characters but ECMAScript does not support such characters directly. For instance, if codepoint U+12345 would appear (without escaping) inside a string constant, it would need to be interpreted as two 16-bit codepoint surrogate codepoints (surrogate pair), if such characters are supported at all.</p><p>Duktape strings support non-BMP characters though, but they cannot be created using source literals.</p><h3 id="use-strict-directive" tabindex="-1">Use strict directive <a class="header-anchor" href="#use-strict-directive" aria-label="Permalink to &quot;Use strict directive&quot;">​</a></h3><p>The &quot;use strict&quot; and other directives have somewhat odd semantics (see E5.1 Section 14.1):</p><ul><li><code>&quot;use strict&quot;</code> is a valid &quot;use strict directive&quot; and triggers strict mode.</li><li><code>&quot;use\\u0020strict&quot;</code> is a valid directive but <strong>not</strong> a &quot;use strict directive&quot;.</li><li><code>(&quot;use strict&quot;)</code> is not a valid directive.</li></ul><p>The lexer and the expression parser coordinate to provide enough information (character escaping, expression &quot;depth&quot;) to allow these cases to be distinguished properly.</p><h2 id="compiler-design-notes" tabindex="-1">Compiler design notes <a class="header-anchor" href="#compiler-design-notes" aria-label="Permalink to &quot;Compiler design notes&quot;">​</a></h2><p>This section has small compiler design notes in no specific order. Larger issues are covered in dedicated sections below.</p><h3 id="expression-parsing-algorithm" tabindex="-1">Expression parsing algorithm <a class="header-anchor" href="#expression-parsing-algorithm" aria-label="Permalink to &quot;Expression parsing algorithm&quot;">​</a></h3><p>The expression parsing algorithm is based on:</p><ul><li><a href="http://javascript.crockford.com/tdop/tdop.html" target="_blank" rel="noreferrer">http://javascript.crockford.com/tdop/tdop.html</a></li><li><a href="http://effbot.org/zone/simple-top-down-parsing.htm" target="_blank" rel="noreferrer">http://effbot.org/zone/simple-top-down-parsing.htm</a></li><li><a href="http://effbot.org/zone/tdop-index.htm" target="_blank" rel="noreferrer">http://effbot.org/zone/tdop-index.htm</a></li></ul><p>The <code>nud()</code> function considers a token as a &quot;value&quot; token. It also parses unary expressions (such as <code>!x</code>).</p><p>The <code>led()</code> function considers a token as an &quot;operator&quot; token, which operates on a preceding value.</p><p>Some tokens operate in both roles but with different semantics. For instance, opening bracket (<code>[</code>) may either begin an array literal in <code>nud()</code>, or a property access in <code>led()</code>.</p><p>The simplified algorithm is as follows. The &#39;rbp&#39; argument defines &quot;right binding power&quot;, which governs when the expression is considered to be finished. The &#39;lbp()&#39; value provides token binding power, &quot;left binding power&quot;. The higher &#39;rbp&#39; is, the more tightly bound expression we&#39;re parsing:</p><pre><code>nud()                ; parse current token as &quot;value&quot;
while rbp &lt; lbp():   ; while token binds more tightly than rbp...
  led()              ; combine previous value with operator
</code></pre><p>The <code>led()</code> function may parse an expression recursively, with a higher &#39;rbp&#39;, i.e. a more tightly bound expression.</p><p>In addition to this basic algorithm, some special features are needed:</p><ul><li><p>Keep track of led() and nud() counts. This allows directives in a function &quot;directive prologue&quot; (E5.1 Section 14.1) to be detected correctly. For instance:</p><pre><code>function f() {
  &#39;use strict&#39;;       // valid directive for strict mode
  &#39;use\\u0020strict&#39;;  // valid directive, but not for strict mode (!)
  (&#39;use strict&#39;);     // not a valid directive, terminates directive prologue
</code></pre></li><li><p>Keep track of parenthesis nesting count during expression parsing. This allows &quot;top level&quot; to be distinguished from nested levels.</p></li><li><p>Keep track of whether the expression is a valid LeftHandSideExpression, i.e. the top level contains only LeftHandSideExpression level operators.</p></li><li><p>Allow a caller to specify that expression parsing should be terminated at a top-level <code>in</code> token. This is needed for the &quot;NoIn&quot; variants, which are used in for/for-in statements.</p></li><li><p>Allow a caller to specify whether or not an empty expression is allowed.</p></li></ul><p>The expression parses uses both the &quot;previous token&quot; and &quot;current token&quot; in making parsing decisions. Which token is considered at each point is not always trivial, and the responsibilities between compiler internal helper functions are not always obvious; token state assumptions are thus documented in most functions.</p><h3 id="parsing-statements" tabindex="-1">Parsing statements <a class="header-anchor" href="#parsing-statements" aria-label="Permalink to &quot;Parsing statements&quot;">​</a></h3><p>Statement parsing is a traditional top-down recursive process which is relatively straightforward. Some complicated issues are:</p><ul><li>Specific statement types which are difficult to parse without lookahead</li><li>Label site handling</li><li>Tail calls</li><li>Implicit return values</li></ul><h3 id="parsing-functions" tabindex="-1">Parsing functions <a class="header-anchor" href="#parsing-functions" aria-label="Permalink to &quot;Parsing functions&quot;">​</a></h3><p>At the end of function parsing, the compiler needs to determine what flags to set for the function. Some flags have an important performance impact. In particular, the creation of an <code>arguments</code> object can be skipped if the compiler can guarantee that it will never be accessed.</p><p>This is not trivial because e.g. the presence of a direct <code>eval()</code> call may allow indirect access to <code>arguments</code>. The compiler must always make a conservative choice to ensure compliance and safety.</p><h3 id="distinguishing-for-for-in" tabindex="-1">Distinguishing for/for-in <a class="header-anchor" href="#distinguishing-for-for-in" aria-label="Permalink to &quot;Distinguishing for/for-in&quot;">​</a></h3><p>There are a total of four <code>for</code> / <code>for-in</code> statement variants. Each variant requires slightly different bytecode output. Detecting the correct variant is difficult, but possible, without multiple passes or arbitrary length token lookup. See separate discussion below.</p><h3 id="expressions-involving-new" tabindex="-1">Expressions involving &quot;new&quot; <a class="header-anchor" href="#expressions-involving-new" aria-label="Permalink to &quot;Expressions involving \\&quot;new\\&quot;&quot;">​</a></h3><p>Expression involving <code>new</code> are not trivial to parse without lookahead. The grammar rules for <code>LeftHandSideExpression</code>, <code>CallExpression</code>, <code>NewExpression</code>, and <code>MemberExpression</code> are a bit awkward. See separate discussion below.</p><h3 id="directive-detection" tabindex="-1">Directive detection <a class="header-anchor" href="#directive-detection" aria-label="Permalink to &quot;Directive detection&quot;">​</a></h3><p>The &quot;use strict&quot; and other directives are part of a directive prologue which is the sequence of initial ExpressionStatements producing only a string literal (E5.1 Section 14.1).</p><p>The expression parser provides a nud/led call count which allows the statement parser to determine that an expression is a valid directive. The first non-valid directive terminates the directive prologue, and no more directives are processed. The lexer provides character escape metadata in token information to allow &quot;use strict&quot; to be detected correctly.</p><p>The transition to strict mode occurs in the directive prologue of the first compilation pass. Function strictness is already known at the beginning of the second pass. This is important because strict mode affects function argument parsing, for instance, so it must be known before parsing the function body.</p><h3 id="declaration-hoisting" tabindex="-1">Declaration &quot;hoisting&quot; <a class="header-anchor" href="#declaration-hoisting" aria-label="Permalink to &quot;Declaration \\&quot;hoisting\\&quot;&quot;">​</a></h3><p>Variable and function declarations affect code generation even before the declarations themselves appear in the source code: in effect, declarations are &quot;hoisted&quot; to the top of the function. To be able to generate reasonable code, compile-time identifier resolution requires multi-pass parsing or some intermediate representation. Current solution is multi-pass function parsing.</p><h3 id="some-token-lookahead-is-needed" tabindex="-1">Some token lookahead is needed <a class="header-anchor" href="#some-token-lookahead-is-needed" aria-label="Permalink to &quot;Some token lookahead is needed&quot;">​</a></h3><p>Because we need some lookahead, the compiler currently keeps track of two tokens at a time, a &quot;current token&quot; and a &quot;previous token&quot;.</p><h3 id="implicit-return-values" tabindex="-1">Implicit return values <a class="header-anchor" href="#implicit-return-values" aria-label="Permalink to &quot;Implicit return values&quot;">​</a></h3><p>Global and eval code have an implicit return value, see separate section below.</p><h3 id="guaranteed-side-effects" tabindex="-1">Guaranteed side effects <a class="header-anchor" href="#guaranteed-side-effects" aria-label="Permalink to &quot;Guaranteed side effects&quot;">​</a></h3><p>Sometimes code must be generated even when it might seem intuitive it is not necessary. For example, the argument to a <code>void</code> operator must be coerced to a &quot;plain&quot; register/constant so that any side effects are generated. Side effects might be caused by e.g. getter calls:</p><pre><code>// If foo.x is an accessor, it must be called
void foo.x
</code></pre><h3 id="evaluation-order-requirements" tabindex="-1">Evaluation order requirements <a class="header-anchor" href="#evaluation-order-requirements" aria-label="Permalink to &quot;Evaluation order requirements&quot;">​</a></h3><p>Evaluation order requirements complicate one-pass code generation somewhat because there&#39;s little leeway in reordering emitted bytecode without a larger IR.</p><h3 id="dynamic-lexical-contexts" tabindex="-1">Dynamic lexical contexts <a class="header-anchor" href="#dynamic-lexical-contexts" aria-label="Permalink to &quot;Dynamic lexical contexts&quot;">​</a></h3><p>ECMAScript lexical contexts can be dynamically altered even after a function call exits. For example, if a function makes a direct <code>eval()</code> call with a variable argument, it is possible to declare new variables when the function is called:</p><pre><code>var foo = 123;
var myfunc;

function f(x) {
    eval(x);

    return function () { print(foo); }
}

// declare &#39;foo&#39; in f(), returned closure sees this &#39;foo&#39; instead
// of the global one

myfunc = f(&#39;var foo = 321&#39;);
myfunc();  // prints 321, not 123

// don&#39;t declare &#39;foo&#39; in f(), returned closure sees the global &#39;foo&#39;
// instead of the global one

myfunc = f(&#39;var quux = 432&#39;);
myfunc();  // prints 123
</code></pre><p>For execution efficiency we should, for example, avoid creation of environment records and the <code>arguments</code> object. The compiler thus needs to conservatively estimate what optimizations are possible.</p><h3 id="compilation-may-trigger-a-gc-or-recursive-compilation" tabindex="-1">Compilation may trigger a GC or recursive compilation <a class="header-anchor" href="#compilation-may-trigger-a-gc-or-recursive-compilation" aria-label="Permalink to &quot;Compilation may trigger a GC or recursive compilation&quot;">​</a></h3><p>At first glance it might seem that the compiler cannot be invoked recursively. This is not the case however: the compiler may trigger a garbage collection or a refzero, which triggers a finalizer execution, which in turn can use e.g. <code>eval()</code> to cause a recursive ECMAScript compilation. Compiler recursion is not a problem as such, as it is a normal recursive C call which respects value stack policy.</p><p>There are a few practical issues to note with regards to GC and recursion:</p><ul><li>All heap values must be correctly reference counted and reachable. The compiler needs heap values to represent token values, compiler intermediate values, etc. All such values must be reachable through the valstack, a temporary object, or GC must explicitly support compiler state.</li><li>There should be no global (heap- or thread-wide) compiler state that would get clobbered by a recursive compilation call. If there is such state, it must be saved and restored by the compiler.</li><li>At the moment there is a &quot;current compiler context&quot; variable in <code>duk_hthread</code> which is used to augment SyntaxErrors with a line number. This state is saved and restored in recursive compilation to avoid clobbering.</li></ul><h3 id="unary-minus-and-plus" tabindex="-1">Unary minus and plus <a class="header-anchor" href="#unary-minus-and-plus" aria-label="Permalink to &quot;Unary minus and plus&quot;">​</a></h3><p>Quite interestingly, the minus sign in <code>-123</code> is <strong>not</strong> a part of the number token in ECMAScript syntax. Instead, <code>-123</code> is parsed as a unary minus followed by a number literal.</p><p>The current compiler follows this required syntax, but constant folding ensures no extra code or constants are generated for unary minus or unary plus.</p><h3 id="compile-time-vs-run-time-errors" tabindex="-1">Compile-time vs. run-time errors <a class="header-anchor" href="#compile-time-vs-run-time-errors" aria-label="Permalink to &quot;Compile-time vs. run-time errors&quot;">​</a></h3><p>Compilation may fail with an error only if the cause is an &quot;early error&quot;, specified in E5.1 Section 16, or an internal error such as out of memory occurs. Other errors must only occur when the result of the compilation is executed. Sometimes this includes constructs that we know can never be executed without an error (such as a function call being in a left-hand-side position of an assignment), but perhaps that code is never reached or the error is intentional.</p><h3 id="label-statement-handling" tabindex="-1">Label statement handling <a class="header-anchor" href="#label-statement-handling" aria-label="Permalink to &quot;Label statement handling&quot;">​</a></h3><p>Label statements essentially prefix actual statements:</p><pre><code>mylabel:
  while (true) { ... }
</code></pre><p>Labels are currently handled directly by the internal function which parses a single statement. This is useful because all labels preceding an actual statement are coalesced into a single &quot;label site&quot;. All labels, including an implicit empty label for iteration statements, point to the same label site:</p><pre><code>// only a single label site is established for labels:
// &quot;label1&quot;, &quot;label2&quot;, &quot;&quot;
label1:
label2:
  for (;;) { ... }
</code></pre><p>Technically, a label looks like an expression statement initially, as a label begins with an identifier. The current parsing approach avoids backtracking by parsing an expression statement normally, and then noticing that (1) it consisted of a single identifier token, and (2) is followed by a colon.</p><p>No code is emitted by the expression parser for such a terminal single token expression (an intermediate value is generated, but it is not coerced to any code yet), so this works without emitting any invalid code.</p><p>Note that some labels cannot accept break or continue (e.g. label for an expression statement), some can accept a break only (switch) while others can accept both (iteration statements: do-while, for, while). All the label names are registered while processing explicit labels, and an empty label is registered for an iteration/switch statement. When the final statement type is known, all labels in the set of labels are updated to indicate whether they accept break and/or continue.</p><h3 id="backtracking" tabindex="-1">Backtracking <a class="header-anchor" href="#backtracking" aria-label="Permalink to &quot;Backtracking&quot;">​</a></h3><p>There is currently only a need to backtrack at the function level, to restart function compilation when moving from one parsing pass to the next. The &quot;current function&quot; state needs to be carefully reinitialized during this transition.</p><p>More fine-grained backtracking is not needed right now, but would involve resetting:</p><ul><li>Emitted bytecode</li><li>Highest used (temp) register</li><li>Emitted constants and inner functions</li><li>Active label set</li></ul><h3 id="temporary-register-allocation" tabindex="-1">Temporary register allocation <a class="header-anchor" href="#temporary-register-allocation" aria-label="Permalink to &quot;Temporary register allocation&quot;">​</a></h3><p>Temporary registers are allocated as a strictly increasing sequence from a specified starting register. The &quot;next temp&quot; is reset back to a smaller value whenever we know that none of the higher temp values are no longer needed. This can be done safely because temporaries are always allocated with a strict stack discipline, and any fixed identifier-to-register bindings are below the initial temp reg.</p><p>The current expression parsing code does not always produce optimal register allocations. It would be preferable for expression result values to be in as low register numbers as possible, which maximizes the amount of temporaries available for later expression code. This is currently done on a case-by-case basis as need arises.</p><p>The backstop is at the statement level: after every statement is complete, the &quot;next temp&quot; can be reset to the same value it was before parsing the statement. However, it&#39;s beneficial to reset &quot;next temp&quot; to a smaller value whenever possible (inside expression parsing), to minimize function register count and avoid running out of temp registers.</p><p>Unused temporary registers are not set to undefined, and are reachable for garbage collection. Unless they&#39;re overwritten by temporary values needed by another expression, they may cause a &quot;silent leak&quot;. This is usually not a concrete concern because a function exit will always decref all such temporaries. This may be an issue for forever-running functions though.</p><h3 id="register-shuffling" tabindex="-1">Register shuffling <a class="header-anchor" href="#register-shuffling" aria-label="Permalink to &quot;Register shuffling&quot;">​</a></h3><p>The compiler needs to handle the case where it runs out of &quot;easy access&quot; registers or constants (usually 256 or 512 registers/constants). Either this needs to be handled correctly in one pass, or the compiler must fall back to a different strategy. Current solution is to use register shuffling through temporary registers. Shuffling is handled by the bytecode emitters.</p><h3 id="pc2line-debug-data-creation" tabindex="-1">Pc2line debug data creation <a class="header-anchor" href="#pc2line-debug-data-creation" aria-label="Permalink to &quot;Pc2line debug data creation&quot;">​</a></h3><p>The &quot;pc2line&quot; debug data is a bit-packed format for converting a bytecode PC into an approximate source line number at run time.</p><p>Although almost all of the bytecode is emitted in a linear fashion (appending to earlier code), some tricky structures insert bytecode instructions in the middle of already emitted bytecode. These insertions prohibit the emission of debug data in a streaming fashion during code emission. Instead, it needs to be implemented as a post-step. This unfortunately doubles the memory footprint of bytecode during compilation.</p><p>The current solution is to keep track of (instruction, line number) pairs for each bytecode instruction during compile time. When the intermediate representation of the compiled function is converted to an actual run-time representation, this representation is converted into a plain opcode list and bit-packed pc2line data.</p><p>There is currently some inaccuracy in the line numbers assigned to opcodes: the bytecode emitter associates the line number of the previous token because this matches how expression parsing consumes tokens. However, in some other call sites the relevant line number would be in the current token. Fixing this needs a bit more internal book-keeping.</p><h3 id="peephole-optimization" tabindex="-1">Peephole optimization <a class="header-anchor" href="#peephole-optimization" aria-label="Permalink to &quot;Peephole optimization&quot;">​</a></h3><p>Currently a simple in-place peephole optimizer is applied at the end of function compilation to straighten out jumps. Consider for instance:</p><pre><code>a:
  JUMP c      -.
b:             |      &lt;--.
  JUMP d       |   -.    |
c:          &lt;--&#39;    |    |
  JUMP b            |   -&#39;
d:               &lt;--&#39;
</code></pre><p>The peephole optimizer runs over the bytecode looking for JUMP-to-JUMP cases until the bytecode no longer changes. On the first peephole pass these jumps are straightened to:</p><pre><code>a:
  JUMP b      -.
b:          &lt;--&#39;
  JUMP d           -.
c:                  |
  JUMP d            |  -.
d:               &lt;--&#39; &lt;-&#39;
</code></pre><p>(The JUMPs are modified in place, so some changes may be visible to later jumps on the same pass.)</p><p>On the next pass this is further optimized to:</p><pre><code>a:
  JUMP d      -.
b:             |
  JUMP d       |   -.
c:             |    |
  JUMP d       |    |  -.
d:          &lt;--&#39; &lt;--&#39; &lt;-&#39;
</code></pre><p>The peephole pass doesn&#39;t eliminate any instructions, but it makes some JUMP chains a bit faster. JUMP chains are generated by the current compiler in many cases, so this simple pass cheaply improves generated code slightly.</p><h3 id="avoiding-c-recursion" tabindex="-1">Avoiding C recursion <a class="header-anchor" href="#avoiding-c-recursion" aria-label="Permalink to &quot;Avoiding C recursion&quot;">​</a></h3><p>C recursion happens in multiple ways. These should suffice to control it:</p><ul><li>Recursive expression parsing</li><li>Recursive statement parsing (e.g. <code>if</code> statement parses another statement)</li><li>Recursive function parsing (e.g. function expression or function declaration inside another function)</li></ul><p>Recursion controls placed in these key functions should suffice to guarantee an upper limit on C recursion, although it is difficult to estimate how much stack is consumed before the limit is reached.</p><h3 id="es2015-constructs-need-an-intermediate-representation" tabindex="-1">ES2015 constructs need an intermediate representation <a class="header-anchor" href="#es2015-constructs-need-an-intermediate-representation" aria-label="Permalink to &quot;ES2015 constructs need an intermediate representation&quot;">​</a></h3><p>ES2015 constructs such as destructuring assignment will need an intermediate representation (or at least a much larger fragment of the expression tree) to compile in a reasonable manner.</p><h2 id="operator-precedences-binding-powers" tabindex="-1">Operator precedences (binding powers) <a class="header-anchor" href="#operator-precedences-binding-powers" aria-label="Permalink to &quot;Operator precedences (binding powers)&quot;">​</a></h2><p>Operator precedences (binding powers) are required by the expression parser for tokens acting as &quot;operators&quot; for <code>led()</code> calls. This includes tokens for binary operators (such as <code>+</code> and <code>instanceof</code>).</p><p>A higher binding power binds more strongly, e.g. <code>*</code> has a higher binding power than <code>+</code>. The binding power of operators can be determined from the syntax. Operators of different precedence are apparent from production nesting level; outer productions have lower binding power.</p><p>Operators at the same level have the same binding power if left-associative. A production can be determined to be left-associative by its production. For instance:</p><pre><code>AdditiveExpression:
    MultiplicativeExpression
    AdditiveExpression &#39;+&#39; MultiplicativeExpression
    AdditiveExpression &#39;-&#39; MultiplicativeExpression
</code></pre><p>Abbreviated:</p><pre><code>AE:
    ME
    AE &#39;+&#39; ME
    AE &#39;-&#39; ME
</code></pre><p>The expression <code>1 + 2 + 3 + 4 * 5</code> would be derived as (with parentheses for emphasizing order):</p><pre><code>AE -&gt; AE &#39;+&#39; ME
   -&gt; (AE &#39;+&#39; ME) &#39;+&#39; ME
   -&gt; ((AE &#39;+&#39; ME) &#39;+&#39; ME) &#39;+&#39; ME
   -&gt; ((ME &#39;+&#39; ME) &#39;+&#39; ME) &#39;+&#39; ME
   -&gt; ((1 &#39;+&#39; 2) &#39;+&#39; 3) &#39;+&#39; (4 &#39;*&#39; 5)
</code></pre><p>Operators at the same level which are right-associative can be determined from its production. For instance:</p><pre><code>AssignmentExpression:
    ConditionalExpression
    LeftHandSideExpression &#39;=&#39; AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentOperator:
    &#39;*=&#39;
    (... others omitted)
</code></pre><p>Abbreviated:</p><pre><code>AE:
    CE
    LE &#39;=&#39; AE
    LE AO AE

AO:
    &#39;*=&#39;
</code></pre><p>The expression <code>a = b = c *= 4</code> would be produced as (using parentheses for emphasis):</p><pre><code>AE -&gt; LE &#39;=&#39; AE
   -&gt; LE &#39;=&#39; (LE &#39;=&#39; AE)
   -&gt; LE &#39;=&#39; (LE &#39;=&#39; (LE &#39;*=&#39; AE)
   -&gt; LE &#39;=&#39; (LE &#39;=&#39; (LE &#39;*=&#39; CE)
   -&gt; a &#39;=&#39; (b &#39;=&#39; (c &#39;*=&#39; 4))
</code></pre><p>Right associative productions are parsed by using a tweaked &#39;rbp&#39; argument to the recursive expression parsing. For the example above:</p><ul><li><code>a</code> is parsed with <code>nud()</code> and evaluates into a variable reference.</li><li>The first <code>=</code> operator is parsed with <code>led()</code>, which calls the expression parser recursively, with a &#39;rbp&#39; argument which causes the recursive call to consume all further assignment operations.</li></ul><p>What is a proper &#39;rbp&#39; for the recursive <code>led()</code> call? It must be lower than the binding power for the <code>=</code> operator, but higher or equal than any operator whose binding power is less than that of <code>=</code>. For example, if the binding power of <code>=</code> was 10, the &#39;rbp&#39; used could be 9. The current compiler uses multiples of 2 for binding powers so that subtracting 1 from the binding power of an operator results in a binding power below the current operator but never equal to any other operator. Technically this is not necessary, because it&#39;s OK for the &#39;rbp&#39; to be equal to a lower binding operator.</p><p>In addition to binary operators, binding powers need to be assigned to:</p><ul><li>Unary operators</li><li>Some tokens which are not strictly operators. For example, <code>(</code>, <code>[</code>, and <code>{</code> which begin certain expressions (function calls, property access, and object</li></ul><p>Token precedences for <code>lbp()</code>, from highest (most tightly bound) to lowest are summarized in the list below. Operators of equal binding power are on the same line. The list is determined based on looking at the <code>Expression</code> production. Operators are left associative unless indicated otherwise:</p><ul><li>(IdentifierName, literals, <code>this</code>, etc. Parsed by <code>nud()</code> and don&#39;t need binding powers.)</li><li><code>.</code> <code>[</code> (Note: MemberExpression parsed by <code>led</code>.)</li><li><code>new</code> (Note: unary expression parsed by <code>nud()</code>. Right-associative.)</li><li><code>(</code> (Note: CallExpression parsed by <code>led()</code>.)</li><li><code>++</code> <code>--</code> (Note: postfix expressions which are parsed by <code>led()</code> but which are &quot;unary like&quot;. The expression always terminates in such a case.)</li><li><code>delete</code> <code>void</code> <code>typeof</code> <code>++</code> <code>--</code> <code>+</code> <code>-</code> <code>~</code> <code>!</code> (Note: unary expressions which are parsed by <code>nud()</code> and don&#39;t thus actually need a binding power. All of these are also right-associative. <code>++</code> and <code>--</code> are preincrement here; <code>+</code> and <code>-</code> are unary plus and minus.)</li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>instanceof</code> <code>in</code></li><li><code>==</code> <code>!=</code> <code>===</code> <code>!==</code></li><li><code>&amp;</code></li><li><code>^</code></li><li><code>|</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li><li><code>?</code> (Note: starting a &quot;a ? b : c&quot; expression)</li><li><code>=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>+=</code> <code>-=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> (Note: right associative.)</li><li><code>,</code></li><li><code>)</code> <code>]</code> (Note: when parsed with <code>led()</code>; see below.)</li><li>EOF (Note: when parsed with <code>led()</code>; see below.)</li></ul><p>The precedence list is clear starting from the lowest binding up to binary <code>+</code> and <code>-</code>. Binding powers higher than that get a bit tricky because some of them are unary (parsed by <code>nud()</code>) and some or parsed by <code>led()</code> but are not binary operators.</p><p>When parsing an expression beginning with <code>(</code> using <code>nud()</code>, the remainder of the expression is parsed with a recursive call to the expression parser and a &#39;rbp&#39; which guarantees that parsing stops at the closing <code>)</code>. The <code>rbp</code> here must NOT stop at the comma operator (<code>,</code>) so technically <code>)</code> is considered to have a binding power lower than comma. The same applies to <code>]</code>. Similarly, EOF is considered to have a binding power lowest of all. These have been appended to the list above.</p><h2 id="parsing-regexp-literals" tabindex="-1">Parsing RegExp literals <a class="header-anchor" href="#parsing-regexp-literals" aria-label="Permalink to &quot;Parsing RegExp literals&quot;">​</a></h2><p>The Ecmacsript lexer has two goal symbols for its lexical grammar: <code>InputElementDiv</code> and <code>InputElementRegExp</code>. The former is used in all lexical contexts where a division (<code>/</code>) or a division-assignment (<code>/=</code>) is allowed; the latter is used elsewhere. The E5.1 specification does not really say anything else on the matter (see E5.1 Section 7, 2nd paragraph).</p><p>In the implementation of the compiler, the <code>advance()</code> set of helpers knows the current token, and consults a token table which indicates whether a regexp literal is prohibited after the current token. Thus, this detail is hidden from ordinary parsing code.</p><p>The <code>advance()</code> helper knows the current token type and consults a token table which has a flag indicating whether or not a RegExp can ever follow that particular token. Unfortunately parsing Identifier (which prohibits keywords) vs. IdentifierName (which allows them) is context sensitive. The current lexer handles this by providing a token type for both interpretations: <code>t</code> indicates token type with reserved words being recognized (e.g. &quot;return&quot; yields a token type DUK_TOK_RETURN) while <code>t_nores</code> indicates token type ignoring reserved words (e.g. &quot;return&quot; yields a token type DUK_TOK_IDENTIFIER).</p><p><code>IdentifierName</code> occurs only in:</p><pre><code>PropertyName -&gt; IdentifierName   (object literal)
MemberExpression -&gt; MemberExpression &#39;.&#39; IdentifierName
CallExpression -&gt; CallExpression &#39;.&#39; IdentifierName
</code></pre><p>Using <code>t_nores</code> for determing whether or not a RegExp is allowed does not work. For instance, <code>return</code> statement allows a return value so a RegExp must be allowed to follow:</p><pre><code>return /foo/;
</code></pre><p>On the other hand, a RegExp cannot follow <code>return</code> here:</p><pre><code>t = foo.return/2;
</code></pre><p>Using <code>t</code> has the inverse problem; if DUK_TOK_RETURN allows a RegExp to follow, this parses correctly:</p><pre><code>return /foo/;
</code></pre><p>but this will fail:</p><pre><code>t = foo.return/2;
</code></pre><p>The IdentifierName cases require special handling:</p><ul><li>The <code>PropertyName</code> in object literal is not really an issue. It cannot be followed by either a division or a RegExp literal.</li><li>The <code>MemberExpression</code> case: a RegExp can never follow. A special one-time flag can be used to reject RegExp literals on the next <code>advance()</code> call.</li><li>The <code>CallExpression</code> case: can be handled similarly.</li></ul><p>Currently this special handling is implemented using the <code>reject_regexp_in_adv</code> flag in the current compiler function state. It is only set when handling <code>DUK_TOK_PERIOD</code> in <code>expr_led()</code>, and is automatically cleared by the next <code>advance()</code> call.</p><p>See test case: <code>test-dev-regexp-parse.js</code>.</p><h2 id="automatic-semicolon-insertion" tabindex="-1">Automatic semicolon insertion <a class="header-anchor" href="#automatic-semicolon-insertion" aria-label="Permalink to &quot;Automatic semicolon insertion&quot;">​</a></h2><p>Semicolons need to be automatically inserted at certain points of the token stream. Only the parser/compiler can handle automatic semicolon insertion, because automatic semicolons are only allowed in certain contexts. Only some statement types have a terminating semicolon and thus participate in automatic semicolon insertion.</p><p>Automatic semicolon insertion is implemented almost completely at the statement parsing level, the only exception being handling of post-increment/decrement.</p><p>After the longest valid statement (usually containing an expression) has been parsed, the statement is either terminated by an explicit semicolon or is followed by an offending token which permits automatic semicolon insertion. In other words, the offending token is preceded by a newline, or is either the EOF or the <code>}</code> token, whichever is appropriate for the statement list in question. The actual specification for &quot;longest valid statement&quot; is that an automatic semicolon can only be inserted if a parse error would otherwise occur.</p><p>Some statements also have grammar which prohibits automatic semicolon insertion in certain places, such as: <code>return [no LineTerminator here] Expression;</code>. These need to be handled specially.</p><p>Some statements have a semicolon terminator while others do not. Automatic semicolons are naturally only processed for statements with a semicolon terminator.</p><p>The current implementation:</p><ul><li>The statement list parser parses statements.</li><li>Individual statement type parsers need to have a capability of parsing until an offending token is encountered (either a semicolon, or some other unexpected token), and to indicate whether that specific statement type requires a semicolon terminator.</li><li>The general statement parsing wrapper then checks whether a semicolon termination is needed, and if so, whether an explicit semicolon or an automatically inserted semicolon terminates the statement.</li><li>Statements which prohibit line terminators in some cases have a special check in the parsing code for that statement type. If the token following the restriction has a &quot;lineterm&quot; flag set, the token is considered offending and the statement is terminated. For instance, &quot;return\\n1;&quot; is parsed as an empty return because the token <code>&quot;1&quot;</code> has a lineterm preceding it. The <code>duk_token</code> struct has a flag indicating whether the token was preceded by whitespace which included one or more line terminators.</li><li>Checking whether an automatic semicolon is allowed depends on a token which is potentially part of the next statement (the first token of the next statement). In the current implementation the statement parsing function is expected to &quot;pull in&quot; the token <em>following</em> the statement into the &quot;current token&quot; slot anyway, so the token can be examined for automatic semicolon insertion without backtracking.</li><li>Post-increment/decrement has a restriction on LineTerminator occurring between the preceding expression and the <code>++</code>/<code>--</code> token (note that pre-increment/decrement has no such restriction). This is currently handled by <code>expr_lbp()</code> which will return an artificially low binding power if a <code>++</code>/<code>--</code> occurs in a post-increment/decrement position (which is always the case if they&#39;re encountered on the <code>expr_led()</code> context) and the token was preceded by a line terminator. This effectively terminates the preceding expression, treating e.g. &quot;a+b\\n++&quot; as &quot;a+b;++;&quot; which causes a SyntaxError.</li></ul><p>There is a custom hack for an errata related to a statement like:</p><pre><code>do{print(&#39;loop&#39;)}while(false)false
</code></pre><p>Strictly speaking this is a syntax error, but is allowed by most implementations in the field. A specific hack is needed to handle this case. See <code>test-stmt-dowhile-bug.js</code>.</p><h2 id="implicit-return-value-of-global-code-and-eval-code" tabindex="-1">Implicit return value of global code and eval code <a class="header-anchor" href="#implicit-return-value-of-global-code-and-eval-code" aria-label="Permalink to &quot;Implicit return value of global code and eval code&quot;">​</a></h2><p>Global code and eval code have an &quot;implicit return value&quot; which comes from the last non-empty statement executed. Function code has no implicit return value. Statements returning a completion with type &quot;empty&quot; do not change the implicit return value. For instance: <code>eval(&quot;1;;var x=2;&quot;)</code> returns <code>1</code> because the empty statement and the <code>var</code> statement have an empty completion. This affects code generation, which is a bit different at the statement level for global/eval code and function code.</p><p>When in a context requiring an implicit return value (eval code or global code), a register is allocated for the last non-empty statement value. When such a statement is parsed, its value is coerced to the allocated register. Other statements are coerced into a plain value (which is then ignored) which ensures all side effects have been generated (e.g. property access is generated for the expression statement <code>x.y;</code>) without affecting the implicit return value.</p><p>Statement types generating an empty value directly:</p><ul><li>Empty statement (12.3)</li><li>Debugger statement (12.15)</li></ul><p>Statement types generating an empty value indirectly:</p><ul><li>Block statement (12.1): may generate an empty statement indirectly if all statements inside the block are empty.</li><li><code>if</code> statement (12.5): may generate empty statement either if a clause has an empty value (e.g. <code>eval(&quot;if (true) {} else {1}&quot;)</code> returns <code>undefined</code>) or a clause is missing (e.g. <code>eval(&quot;if (false) {1}&quot;)</code> returns <code>undefined</code>).</li><li><code>do-while</code>, <code>while</code>, <code>for</code>, <code>for in</code> statements (12.6): statement value is the value of last non-empty statement executed within loop body; may be empty if only empty statements or no statements are executed.</li><li><code>continue</code> and <code>break</code> statements (12.7, 12.8): have an empty value but <code>continue</code> and <code>break</code> are handled by their catching iteration statement, so they are a bit special.</li><li><code>with</code> statement (12.10): like block statements</li><li><code>switch</code> statement (12.11): return value is the value of the last non-empty statement executed (in whichever clause).</li><li>Labelled statement (12.12): returns whatever the statement following them returns.</li><li><code>try</code> statement (12.14): return value is the value of the last non-empty statement executed in try and/or catch blocks.</li></ul><p>Some examples:</p><hr><p>Eval argument Eval Notes result</p><hr><p>&quot;1+2;&quot; 3 Normal case, expression statement generates implicit return value.</p><p>&quot;1+2;;&quot; 3 An empty statement generates an empty value.</p><p>&quot;1+2; var 3 A variable declaration generates an empty a;&quot; value.</p><p>&quot;1+2; var 3 A variable declaration, even with assignment, a=5;&quot; generates an empty value.</p><h2 id="_1-2-a-5-5-a-normal-assignment-generates-a-value" tabindex="-1">&quot;1+2; a=5; 5 A normal assignment generates a value. <a class="header-anchor" href="#_1-2-a-5-5-a-normal-assignment-generates-a-value" aria-label="Permalink to &quot;\\&quot;1+2; a=5;   5         A normal assignment generates a value.&quot;">​</a></h2><h2 id="tail-call-detection-and-handling" tabindex="-1">Tail call detection and handling <a class="header-anchor" href="#tail-call-detection-and-handling" aria-label="Permalink to &quot;Tail call detection and handling&quot;">​</a></h2><p>A tail call can be used when:</p><ol><li>the value of a CALL would become the argument for an explicit <code>return</code> statement or an implicit return value (for global or eval code); and</li><li>there are no active TCF catchers between the return and the function entrypoint.</li></ol><p>A trivial example is:</p><pre><code>function f(x) {
  return f(x+1);
}
</code></pre><p>The generated code would look something like:</p><pre><code>CSREG r0, c0    ; c0 = &#39;f&#39;
GETVAR r1, c1   ; c1 = &#39;x&#39;
ADD r0, r1, c2  ; c2 = 1
CALL r0, 2      ; TAILCALL flag not set
RETURN r0       ;
</code></pre><p>This could be emitted as a tail call instead:</p><pre><code>CSREG r0, c0    ; c0 = &#39;f&#39;
GETVAR r1, c1   ; c1 = &#39;x&#39;
ADD r0, r1, c2  ; c2 = 1
CALL r0, 2      ; TAILCALL flag set
RETURN r0       ; kept in case tail call isn&#39;t allowed at run time
</code></pre><p>There are more complex cases, like:</p><pre><code>function f(x) {
  return (g(x) ? f(x+1) : f(x-1));
}
</code></pre><p>Here, just before executing a RETURN, both paths of execution end up with a function call. Both calls can be converted to tail calls.</p><p>The following is not a candidate for a tail call because of a catcher:</p><pre><code>function f(x) {
  try {
    return f(x+1);
  } finally {
    print(&#39;cleaning up...&#39;);
  }
}
</code></pre><p>Detecting anything other than the very basic case is probably not worth the complexity, especially because E5.1 does not require efficient tail calls at all (in fact, as of this writing, neither V8 nor Rhino support tail calls). ES2015 <em>does</em> require tail calls and provides specific guarantees for them. Adding support for ES2015 tail calls will require compiler changes.</p><p>The current approach is very simplistic and only detects the most common cases. First, it is only applied to compiling function code, not global or eval code, which restricts consideration to explicit <code>return</code> statements only. When parsing a <code>return</code> statement:</p><ul><li>First request the expression parser to parse the expression for the return value normally.</li><li>If the last bytecode instruction generated by the expression parser is a CALL whose value would then become the RETURN argument and there is nothing preventing a tail call (such as TCF catchers), convert the last CALL to a tail call. (There are a few more details to this; see <code>duk_js_compiler.c</code> for comments.)</li><li>The RETURN opcode is kept in case the tail call is not allowed at run time. This is possible e.g. if the call target is a native function (which are never tail called) or has a <code>&quot;use duk notail&quot;</code> directive.</li><li>Note that active label sites are not a barrier to tail calls; they are unwound by the tail call logic.</li></ul><p>See <code>test-dev-tail-recursion.js</code>.</p><h2 id="parsing-callexpression-newexpression-memberexpression" tabindex="-1">Parsing CallExpression / NewExpression / MemberExpression <a class="header-anchor" href="#parsing-callexpression-newexpression-memberexpression" aria-label="Permalink to &quot;Parsing CallExpression / NewExpression / MemberExpression&quot;">​</a></h2><p>The grammar for <code>CallExpression</code>, <code>NewExpression</code>, and <code>MemberExpression</code> is interesting; they&#39;re not in a strict binding power sequence. Instead, there is a branch, starting from LeftHandSideExpression:</p><pre><code>LeftHandSideExpression
        |               .--.
        |               v  |
        |  .---&gt; NewExpression ----.
        |  |                       |
        \`--+                       +---&gt; MemberExpression
           |                       |
           \`---&gt; CallExpression ---&#39;
                        ^  |
                        \`--&#39;
</code></pre><p>Both NewExpression and CallExpression contain productions containing themselves and MemberExpressions. However, a NewExpression never produces a CallExpression and vice versa.</p><p>This is unfortunately difficult to parse. For instance, both productions (CallExpression and NewExpression) may begin with a &#39;new&#39; token, so without lookahead we don&#39;t know which we&#39;re parsing.</p><p>Consider the two productions:</p><pre><code>Production 1:

  LeftHandSideExpression -&gt; NewExpression
                         -&gt; &#39;new&#39; MemberExpression
                         -&gt; &#39;new&#39; &#39;Foo&#39;

Production 2:

  LeftHandSideExpression -&gt; CallExpression
                         -&gt; MemberExpression Arguments
                         -&gt; &#39;new&#39; &#39;Foo&#39; &#39;(&#39; &#39;)&#39;
</code></pre><p>These two are syntactically different but semantically identical: they both cause a constructor call with no arguments. However, they derive through different productions.</p><p>Miscellaneous notes:</p><ul><li><p>A NewExpression is the only production capable of generating &quot;unbalanced&quot; &#39;new&#39; tokens, i.e. &#39;new&#39; tokens without an argument list. A NewExpression essentially generates 0...N &#39;new&#39; tokens before generating a MemberExpression.</p></li><li><p>A MemberExpression can generate a &quot;&#39;new&#39; MemberExpression Arguments&quot; production. These can nest, generating e.g. &quot;new new Foo () ()&quot; which parses as &quot;(new (new Foo ()) ())&quot;.</p></li><li><p>If a LeftHandSideExpression generates a NewExpression, it is no longer possible to generate more argument lists (open and close parenthesis) than there are &#39;new&#39; tokens. However, it is possible to generate more &#39;new&#39; tokens than argument lists.</p></li><li><p>If a LeftHandSideExpression generates a CallExpression, it is no longer possible to generate &#39;new&#39; tokens without argument list (MemberExpression only allows &#39;new&#39; with argument list). However, it is possible to generate more argument lists than &#39;new&#39; tokens; any argument lists not matching a &#39;new&#39; token are for function calls generated by CallExpression. For instance (with angle brackets for illustration):</p><pre><code>new new Foo () () () == &lt;(new &lt;new Foo ()&gt; ()&gt; ()
</code></pre><p>where the last parenthesis are for a function call.</p></li><li><p>Parentheses match innermost &#39;new&#39; expressions generated by MemberExpression, innermost first. There can then be either additional &#39;new&#39; tokens on the left or additional argument lists on the right, but not both.</p><p>Any additional &#39;new&#39; tokens on the left are generated by NewExpression. Any additional argument lists on the right are generated by CallExpression.</p></li></ul><p>For instance:</p><pre><code>new new new new Foo () ()
</code></pre><p>parses as (with angle brackets used for illustration):</p><pre><code>new new new &lt;new Foo ()&gt; ()
new new &lt;new &lt;new Foo ()&gt; ()&gt;
new &lt;new &lt;new &lt;new Foo ()&gt; ()&gt;&gt;
</code></pre><p>whereas:</p><pre><code>new new Foo () () () ()
</code></pre><p>parses as (with angle brackets used for illustration):</p><pre><code>&lt;&lt;&lt;new &lt;new Foo ()&gt; ()&gt; ()&gt; ()&gt;
:::    |==========|   :   :   :
:::    constr. call   :   :   :
:::                   :   :   :
::|====================   :   :
::     constr. call       :   :
::                        :   :
:|========================|   :
:      function call          :
:                             :
|=============================|
       function call
</code></pre><p>Current parsing approach:</p><ul><li>When a &#39;new&#39; token is encountered by <code>nud()</code>, eat the &#39;new&#39; token.</li><li>Parse a MemberExpression to get the call target. This expression parsing must terminate if a left parenthesis &#39;(&#39; is encountered. The expression parsing must not terminate if a property access is encountered (i.e. the <code>.</code> or <code>[</code> token in <code>led()</code>). This is achieved by a suitable binding power given to expression parser.</li><li>Finally, look ahead to see whether the next token is a left parenthesis (&#39;(&#39;). If so, the &#39;new&#39; token has an argument list; parse the argument list. If the next token is not a left parenthesis, the &#39;new&#39; expression is complete, and <code>nud()</code> can return.</li><li>There are many tests in <code>test-dev-new.js</code> which attempt to cover the different cases.</li></ul><h2 id="compiling-try-catch-finally-statements" tabindex="-1">Compiling &quot;try-catch-finally&quot; statements <a class="header-anchor" href="#compiling-try-catch-finally-statements" aria-label="Permalink to &quot;Compiling \\&quot;try-catch-finally\\&quot; statements&quot;">​</a></h2><p>Compiling the try-catch-statement statement is not very complicated. However, what happens during execution is relatively complex:</p><ul><li>The catch stack is involved with a &quot;TCF catcher&quot;.</li><li>A new declarative environment record, containing the &quot;catch variable&quot;, may need to be used during the catch part.</li></ul><p>The execution control flow is described in <code>execution.rst</code>.</p><p>The catch variable has a local scope (&quot;let&quot; scope) which differs from the way variables are normally declared -- they are usually &quot;hoisted&quot; to the top level of the function.</p><p>Implementing the local scope in the general case requires the creation of a declarative lexical environment which only maps the catch variable and uses the previous lexical environment as its parent. This has the effect of temporarily &quot;masking&quot; a variable of the same name, e.g.:</p><pre><code>var e = &quot;foo&quot;; print(e);

try { throw new Error(&quot;error&quot;); }
catch (e) { print(e); }

print(e);
</code></pre><p>prints:</p><pre><code>foo
Error: error
foo
</code></pre><p>We would like to avoid emitting code for creating and tearing down such an environment, as it is very often not needed at all. Instead, the error caught can be bound to a register (only) at compile time.</p><p>To do so, the compiler would need to record some information about the contents of the catch clause in pass 1, so that the compiler would know in pass 2 if the environment record will be needed and emit the necessary opcodes only when necessary. (The &quot;statement number&quot; would be enough to identify the statement on the second pass.)</p><p>The current compiler does not have the necessary intelligence to avoid creating a lexical environment, so the environment is currently always established when the catch-clause activates.</p><p>There is a small footprint impact in having the declarative environment established for the duration of the catch clause. The TRYCATCH flags indicate that the environment is needed, and supplies the variable name through a constant. There is a run-time penalty for this to (1) establish the lexical environment and associated book-keeping, and (2) access to the variable within the catch clause will happen through the slow path primitives (GETVAR, PUTVAR, etc). The latter is a limitation in the current lexical environment model, where an identifier is either bound as a normal property of the lexical environment object, or is bound to a <em>function-wide</em> register. (This will need to change anyway for ES2015 where &quot;let&quot; statements are supported.)</p><h2 id="compiling-with-statements" tabindex="-1">Compiling &quot;with&quot; statements <a class="header-anchor" href="#compiling-with-statements" aria-label="Permalink to &quot;Compiling \\&quot;with\\&quot; statements&quot;">​</a></h2><p>A <code>with</code> statement requires that an object environment record is established on entry, and cleaned up on exit.</p><p>There is no separate catch stack entry for handling <code>with</code> statements. Instead, the &quot;TCF&quot; catcher (which implements try-catch-finally) has enough functionality to implement the semantics of <code>with</code> statement, including the automatic handling of the object environment record.</p><p>For example:</p><pre><code>with (A)
  B
</code></pre><p>Generates code:</p><pre><code>(code for A, loading result to rX)

TRYCATCH reg_catch=rN
         var_name=none
         with_object=rX
         have_catch=false
         have_finally=false
         catch_binding=false
         with_binding=true
INVALID
JUMP done

(code for B)
ENDTRY

done:
</code></pre><p>Note that neither a &quot;catch&quot; nor a &quot;finally&quot; part is needed: all the cleanup handles either when the catcher is unwound by an error, or by ENDTRY (which of course performs an unwind).</p><h2 id="compiling-for-for-in-statements" tabindex="-1">Compiling &quot;for&quot;/&quot;for-in&quot; statements <a class="header-anchor" href="#compiling-for-for-in-statements" aria-label="Permalink to &quot;Compiling \\&quot;for\\&quot;/\\&quot;for-in\\&quot; statements&quot;">​</a></h2><h3 id="four-variants" tabindex="-1">Four variants <a class="header-anchor" href="#four-variants" aria-label="Permalink to &quot;Four variants&quot;">​</a></h3><p>Parsing a for/for-in statement is a bit complicated because there are four variants which need different code generation:</p><ol><li>for (ExpressionNoIn_opt; Expression_opt; Expression_opt) Statement</li><li>for (var VariableDeclarationListNoIn; Expression_opt; Expression_opt) Statement</li><li>for (LeftHandSideExpression in Expression) Statement</li><li>for (var VariableDeclarationNoIn in Expression) Statement</li></ol><p>Distinguishing the variants from each other is not easy without back-tracking. If back-tracking is avoided, any code generated before the variant is determined needs to be valid for all potential variants being considered. Also, no SyntaxErrors can be thrown in cases where one variant would parse correctly.</p><p>There are also tricky control flow issues related to each variant. Because code is generated while parsing, control flow often needs to be implemented rather awkwardly.</p><p>Note that the <code>in</code> token serves two independent roles in ECMAScript: (1) as a membership test in <code>&quot;foo&quot; in y</code> and (2) as part of the for-in iterator syntax. These two uses have entirely different semantics and compile entirely different code.</p><h3 id="semantics-notes-on-variant-1" tabindex="-1">Semantics notes on variant 1 <a class="header-anchor" href="#semantics-notes-on-variant-1" aria-label="Permalink to &quot;Semantics notes on variant 1&quot;">​</a></h3><p>Nothing special.</p><h3 id="semantics-notes-on-variant-2" tabindex="-1">Semantics notes on variant 2 <a class="header-anchor" href="#semantics-notes-on-variant-2" aria-label="Permalink to &quot;Semantics notes on variant 2&quot;">​</a></h3><p>Like all ECMAScript variable declarations, the declaration is &quot;hoisted&quot; to the top of the function while a possible initializer assignment only happens when related code is executed.</p><p>There can be multiple variable declarations variant 2, but only one in variant 4.</p><h3 id="semantics-notes-on-variant-3" tabindex="-1">Semantics notes on variant 3 <a class="header-anchor" href="#semantics-notes-on-variant-3" aria-label="Permalink to &quot;Semantics notes on variant 3&quot;">​</a></h3><p>Variants 1 and 3 cannot be trivially distinguished by looking ahead a fixed number of tokens, which seems counterintuitive at first. This is the case because a LeftHandSideExpression production in E5.1 allows for e.g. function calls, &#39;new&#39; expressions, and parenthesized arbitrary expressions.</p><p>Although pure E5.1 functions cannot return left-hand-side values, native functions are allowed to do so if the implementation wishes to support it. Hence the syntax supports such cases, e.g.:</p><pre><code>for (new Foo().bar() in quux) { ... }
</code></pre><p>This MUST NOT cause a SyntaxError during parsing, but rather a ReferenceError at runtime.</p><p>A valid left-hand-side expression (such as an identifier) may also be wrapped in one or more parentheses (i.e., an arbitrary number of tokens):</p><pre><code>for ( (((i))) in [ &#39;foo&#39;, &#39;bar&#39; ] ) { }
print(i);

// -&gt; prints 1
</code></pre><p>The comma expression semantics requires that every comma expression part is coerced with <code>GetValue()</code>, hence a comma expression is <em>not</em> normally a valid left-hand-side expression:</p><pre><code>for ( (&quot;foo&quot;, i) in [ &#39;foo&#39;, &#39;bar&#39; ] ) { }

// -&gt; ReferenceError (not a SyntaxError, though)
</code></pre><p>Again, if a native function is allowed to return a Reference, a comma expression could be a valid left-hand-side expression, but we don&#39;t support that.</p><p>A valid left-hand-side expression may also involve multiple property reference steps with side effects. The E5.1 specification allows some leeway in implementing such expressions. Consider, e.g.:</p><pre><code>y = { &quot;z&quot;: null };
x = {
  get y() { print(&quot;getter&quot;); return y; }
}
for (x.y.z in [0,1]) {}
</code></pre><p>Such an expression may (apparently) print &quot;getter&quot; either once or multiple times: see E5.1 Section 12.6.4, step 6.b which states that the left-hand-side expression &quot;may be evaluated repeatedly&quot;. This probably also implies that &quot;getter&quot; can also be printed zero times, if the loop body is executed zero times. At least V8 and Rhino both print &quot;getter&quot; two times for the example above, indicating that the full code for the left-hand-side expression (if it requires any code emission beyond a property/variable assignment) is evaluated on every loop.</p><p>Another example of the evaluation order for a &quot;for-in&quot; statement:</p><pre><code>function f() { throw new Error(&quot;me first&quot;); }
for (&quot;foo&quot; in f()) {}
</code></pre><p>The code must throw the &quot;me first&quot; Error before the ReferenceError related to an invalid left-hand-side.</p><p>A valid left-hand-side expression must ultimately be either a variable or a property reference. Because we don&#39;t allow functions to return references, any left-hand-side expression involving a function call or a &#39;new&#39; expression should cause a ReferenceError (but not a compile time SyntaxError). In fact, the only acceptable productions for LeftHandSideExpression are:</p><pre><code>LeftHandSideExpression -&gt; NewExpression
NewExpression          -&gt; MemberExpression
MemberExpression       -&gt; MemberExpression [ Expression ]
                        | MemberExpression . Expression
                        | PrimaryExpression
PrimaryExpression      -&gt; this
                        | Identifier
                        | ( Expression )
</code></pre><p>Actual implementations seem to vary with respect to checking the syntax validity of the LeftHandSideExpression. For instance, V8 accepts an Expression which is not necessarily a valid LeftHandSideExpression without throwing a SyntaxError, but then throws a ReferenceError at run time:</p><pre><code>&gt; function f() { for (a+b in [0,1]) {} }
undefined
&gt; f()
ReferenceError: Invalid left-hand side in for-in
</code></pre><p>This is technically incorrect.</p><p>Rhino gives a SyntaxError:</p><pre><code>js&gt; function f() { for (a+b in [0,1]) {} }
js: line 1: Invalid left-hand side of for..in loop.
</code></pre><p>So, a passable loose implementation is to parse the LeftHandSideExpression as just a normal expression, and then check the final intermediate value. If it is a property or variable reference, generate the respective iteration code. Otherwise generate a fixed ReferenceError throw.</p><h3 id="semantics-notes-on-variant-4" tabindex="-1">Semantics notes on variant 4 <a class="header-anchor" href="#semantics-notes-on-variant-4" aria-label="Permalink to &quot;Semantics notes on variant 4&quot;">​</a></h3><p>There can be only one declared variable. However, the variable may have an initializer:</p><pre><code>for (var i = 8 in [ 0, 1 ]) { ... }
</code></pre><p>The initializer cannot be safely omitted. There may be side effects and the initialized value <em>can</em> be accessed in some cases, e.g.:</p><pre><code>function f() {
  function g() { print(i); return [0,1] };
  for (var i = 8 in g()) { print(i); }
}

f();  // -&gt; prints 8, 0, 1
</code></pre><h3 id="control-flow-for-variant-1" tabindex="-1">Control flow for variant 1 <a class="header-anchor" href="#control-flow-for-variant-1" aria-label="Permalink to &quot;Control flow for variant 1&quot;">​</a></h3><p>Control flow for <code>for (A; B; C) D</code>:</p><pre><code>LABEL N
JUMP L4  ; break
JUMP L2  ; continue

(code for A)

L1:
(code for B)
(if ToBoolean(B) is false, jump to L4)
JUMP L3

L2:
(code for C)
JUMP L1

L3:
(code for D)
JUMP L2

L4:
; finished
</code></pre><p>If A is an empty expression, no code is omitted. If B is an empty expression, it is considered &quot;true&quot; for loop termination (i.e. don&#39;t terminate loop) and can be omitted (&quot;JUMP L3&quot; will occur at L1). If C is empty it can be omitted (&quot;JUMP L1&quot; will occur at L2); more optimally, the &quot;JUMP L2&quot; after L3 can be changed to a direct &quot;JUMP L1&quot;.</p><h3 id="control-flow-for-variant-2" tabindex="-1">Control flow for variant 2 <a class="header-anchor" href="#control-flow-for-variant-2" aria-label="Permalink to &quot;Control flow for variant 2&quot;">​</a></h3><p>Control flow for variant 2 is the same as for variant 1: &quot;code for A&quot; is replaced by the variable list assignment code for 1 or more variables.</p><h3 id="control-flow-for-variant-3" tabindex="-1">Control flow for variant 3 <a class="header-anchor" href="#control-flow-for-variant-3" aria-label="Permalink to &quot;Control flow for variant 3&quot;">​</a></h3><p>Control flow for <code>for (A in C) D</code>:</p><pre><code>; Allocate Rx as temporary register for loop value
; Allocate Re as enumerator register

JUMP L2

L1:
(code for A)
(assign Rx to the variable/property of the left-hand-side expression A)
JUMP L3

L2:
(code for C)
(initializer enumerator for value of C into Re)
JUMP L4

L3:
(code for D)

L4:
(if enumerator Re is finished, JUMP to L5)
(else load next enumerated value to Rx)
JUMP L1

L5:
; finished
</code></pre><h3 id="control-flow-for-variant-4" tabindex="-1">Control flow for variant 4 <a class="header-anchor" href="#control-flow-for-variant-4" aria-label="Permalink to &quot;Control flow for variant 4&quot;">​</a></h3><p>Control flow for <code>for (var A = B in C) D</code> is similar to that of variant 3. If the variable declaration has an initializer (B), it needs to be evaluated before the enumerator target expression (C) is evaluated:</p><pre><code>; Allocate Rx as temporary register for loop value
; Allocate Re as enumerator register

(code for B)
(code for assigning result of B to variable A)
JUMP L2

L1:
(assign Rx to the variable A)
JUMP L3

L2:
(code for C)
(initializer enumerator for value of C into Re)
JUMP L4

L3:
(code for D)

L4:
(if enumerator Re is finished, JUMP to L5)
(else load next enumerated value to Rx)
JUMP L1

L5:
; finished
</code></pre><h3 id="compiling-without-backtracking" tabindex="-1">Compiling without backtracking <a class="header-anchor" href="#compiling-without-backtracking" aria-label="Permalink to &quot;Compiling without backtracking&quot;">​</a></h3><p>The first token after the left parenthesis determines whether we&#39;re parsing variant 1/3 or variant 2/4: a <code>var</code> token can never begin an expression.</p><p>Parsing variant 2/4 without backtracking:</p><ul><li>Parse <code>var</code></li><li>Parse identifier name</li><li>Check whether next token is the equal sign; if so: <ul><li>Parse equal sign</li><li>Parse assignment value expression as AssignmentExpressionNoIn: terminate parsing if <code>in</code> encountered, and use the &quot;rbp&quot; argument to start parsing at the &quot;AssignmentExpression&quot; binding power level</li></ul></li><li>If the next token is <code>in</code>, we&#39;re dealing with variant 4: <ul><li>The code emitted for the variable assignment is proper for variant 4</li><li>The variable identifier should be used for the loop iteration</li></ul></li><li>Else we&#39;re dealing with variant 2. <ul><li>The code emitted for the variable assignment is proper for variant 2</li><li>There may be further variable declarations in the declaration list.</li></ul></li></ul><p>Parsing variant 1/3 without backtracking is a bit more complicated. An important observation is that:</p><ul><li>The first expression (ExpressionNoIn_opt) before semicolon in variant 1 cannot contain a top-level <code>in</code> token</li><li>The expression (LeftHandSideExpression) before <code>in</code> also cannot contain a top-level <code>in</code> token</li></ul><p>This observation allows the following compilation strategy:</p><ul><li>Parse an Expression, prohibiting a top-level <code>in</code> token and keeping track whether the expression conforms to LeftHandSideExpression. Any code generated during this parsing is correct for both variant 1 and variant 3.</li><li>After Expression parsing, check the next token; if the next token is an <code>in</code>, parse the remainder of the statement as variant 3.</li><li>Else, if the next token is a semicolon, parse the remainder of the statement as variant 1.</li><li>Else, SyntaxError.</li></ul><p>Note that if the E5.1 syntax allowed a top-level <code>in</code> for variant 1, this approach would not work.</p><h2 id="compiling-do-while-statements" tabindex="-1">Compiling &quot;do-while&quot; statements <a class="header-anchor" href="#compiling-do-while-statements" aria-label="Permalink to &quot;Compiling \\&quot;do-while\\&quot; statements&quot;">​</a></h2><p>There is a bug filed at:</p><ul><li><a href="https://bugs.ecmascript.org/show_bug.cgi?id=8" target="_blank" rel="noreferrer">https://bugs.ecmascript.org/show_bug.cgi?id=8</a></li></ul><p>The bug is about the expression:</p><pre><code>do{;}while(false)false
</code></pre><p>which is prohibited in the specification but allowed in actual implementations. The syntax error is that a <code>do</code> statement is supposed to be followed by a semicolon and since there is no newline following the right parenthesis, an automatic semicolon should not be allowed.</p><p>The workaround in the current implementation is a special flag for automatic semicolon insertion (ALLOW_AUTO_SEMI_ALWAYS). If the flag is set, automatic semicolon insertion is allowed even when no lineterm is not present before the next token.</p><h2 id="compiling-switch-statements" tabindex="-1">Compiling &quot;switch&quot; statements <a class="header-anchor" href="#compiling-switch-statements" aria-label="Permalink to &quot;Compiling \\&quot;switch\\&quot; statements&quot;">​</a></h2><p>Compiling switch statements is not complicated as such, but switch statement has a bit tricky control flow. Essentially there are two control paths: the &quot;search&quot; code path which looks for the first matching case (or the default case), and the &quot;case&quot; code path which executes the case statements starting from the first match, falling through where appropriate.</p><p>The code generated for this matching model is quite heavy in JUMPs. It would be preferable to structure the code differently, e.g. first emit all checks, and then emit all statement code. Intermediate jumps would not be required at least in the statement code in this case. However, this would require multi-pass parsing or construction of an intermediate representation, which the current multi-pass model explicitly avoids.</p><p>The algorithm in E5.1 Section 12.11 seems to contain some ambiguity, e.g. for a switch statement with a default clause, what B statements are iterated in step 9 in each case? The intent seems clear though, although the text is not. See:</p><ul><li><a href="https://bugs.ecmascript.org/show_bug.cgi?id=345" target="_blank" rel="noreferrer">https://bugs.ecmascript.org/show_bug.cgi?id=345</a></li></ul><p>See <code>test-dev-switch*.js</code>.</p><p>Sometimes switch-case statements are used with a large number of integer case values. For example, a processor simulator would commonly have such a switch for decoding opcodes:</p><pre><code>switch (opcode) {
case 0: /* ... */
case 1: /* ... */
case 2: /* ... */
/* ... */
case 255: /* ... */
}
</code></pre><p>It would be nice to detect such structures and handle it using some sort of switch value indexed jump table. Doing so would need more state than is currently available for the compiler, so switch-case statements like this generate quite suboptimal bytecode at present. This is definite future work.</p><h2 id="compiling-break-continue-fast-and-slow" tabindex="-1">Compiling &quot;break&quot;/&quot;continue&quot; (fast and slow) <a class="header-anchor" href="#compiling-break-continue-fast-and-slow" aria-label="Permalink to &quot;Compiling \\&quot;break\\&quot;/\\&quot;continue\\&quot; (fast and slow)&quot;">​</a></h2><p>A &quot;fast&quot; break/continue jumps directly to the appropriate jump slot of the matching LABEL instruction. The jump slot then jumps to the correct place; in case of BREAK, the jump slot jumps directly to ENDLABEL. The peephole optimizer then optimizes the extra jump, creating a direct jump to the desired location.</p><p>A &quot;fast&quot; break/continue cannot cross a TCF catcher (i.e. a &#39;try&#39; statement or a &#39;with&#39; statement), and the matching label must be the innermost label (otherwise a LABEL catcher would be bypassed).</p><p>A &quot;slow&quot; break/continue uses a <code>longjmp()</code> and falls back to the generic, always correct longjmp handler.</p><h2 id="compiling-return" tabindex="-1">Compiling &quot;return&quot; <a class="header-anchor" href="#compiling-return" aria-label="Permalink to &quot;Compiling \\&quot;return\\&quot;&quot;">​</a></h2><p>Compiling a <code>return</code> statement is mostly trivial, but tail calls pose some interesting problems.</p><p>If the return value is generated by a preceding <code>CALL</code> opcode, the call can be flagged a tail call. The <code>RETURN</code> opcode is still emitted just in case, if there&#39;s some feature preventing the tail call from happening at run time -- for example, the call target may be a native function (which are never tail called) or have a <code>use duk notail</code> directive which prevents tail calling the function.</p><h2 id="compiling-throw-statements" tabindex="-1">Compiling &quot;throw&quot; statements <a class="header-anchor" href="#compiling-throw-statements" aria-label="Permalink to &quot;Compiling \\&quot;throw\\&quot; statements&quot;">​</a></h2><p>A <code>throw</code> is never &quot;fast&quot;; we always use the longjmp handler to process them.</p><h2 id="compiling-logical-expressions" tabindex="-1">Compiling logical expressions <a class="header-anchor" href="#compiling-logical-expressions" aria-label="Permalink to &quot;Compiling logical expressions&quot;">​</a></h2><p>ECMAScript has three logical operators: binary operators <code>&amp;&amp;</code> and <code>||</code>, and a unary operator <code>!</code>. The unary logical NOT operator coerces its argument to a boolean value and negates the result (E5.1 Section 11.4.9). The binary AND and OR operator employ ordered, short circuit evaluation semantics, and the result of a binary operation is one of its arguments, which is <strong>not</strong> coerced to a boolean value (E5.1 Section 11.11).</p><p>The ECMAScript <code>ToBoolean()</code> specification function is used to coerce values into booleans (E5.1 Section 9.2) for comparison purposes. The following values are coerced to <code>false</code>: <code>undefined</code>, <code>null</code>, <code>false</code>, <code>+0</code>, <code>-0</code>, <code>NaN</code>, <code>&quot;&quot;</code>. All other values are coerced to <code>true</code>. Note that the <code>ToBoolean</code> operation is side-effect free, and cannot throw an error.</p><p>Evaluation ordering and short circuiting example using Rhino:</p><pre><code>js&gt; function f(x,y) { print(&quot;f called for:&quot;, y); return x; }
js&gt; function g(x,y) { print(&quot;g called for:&quot;, y); throw new Error(&quot;&quot; + x); }
js&gt;
js&gt; // Illustration of short circuit evaluation and evaluation order
js&gt; // (0/0 results in NaN)
js&gt; var a = f(1,&quot;first (t)&quot;) &amp;&amp; f(0,&quot;second (f)&quot;) || f(0/0,&quot;third (f)&quot;) &amp;&amp; g(0,&quot;fourth (err)&quot;);
f called for: first (t)
f called for: second (f)
f called for: third (f)
js&gt; print(a);
NaN
</code></pre><p>The first expression is evaluated, coerced to boolean, and since it coerces to <code>true</code>, move on to evaluate the second expression. That coerces to <code>false</code>, so the first AND expression returns the number value <code>0</code>, i.e. the value of the second expression (which coerced to <code>false</code> for comparison). Because the first part of the OR coerces to <code>false</code>, the second part is evaluated starting from the third expression (<code>NaN</code>). Since <code>NaN</code> coerces to <code>false</code>, the fourth expression is never evaluated. The result of the latter AND expression is <code>NaN</code>, which also becomes the final value of the outer OR expression.</p><p>Code generation must respect the ordering and short circuiting semantics of ECMAScript boolean expressions. In particular, short circuiting means that binary logical operations are not simply operations on values, but must rather be control flow instructions. Code generation must emit &quot;skip jumps&quot; when generating expression code, and these jumps must be back-patched later. It would be nice to generate a minimum amount of jumps (e.g. when an AND expression is contained by a logical NOT).</p><p>Logical expressions can be used in deciding the control flow path in a control flow statement such as <code>if</code> or <code>do-while</code>, but the expression result can also be used and e.g. assigned to a variable. For optimal code generation the context where a logical expression occurs matters; for example, often we don&#39;t need the final evaluation result but only its &quot;truthiness&quot;. The current compiler doesn&#39;t take advantage of this potential because there&#39;s not enough state information to do so.</p><p>Let&#39;s look at the code generation issues for the following:</p><pre><code>if (!((A &amp;&amp; B) || (C &amp;&amp; D &amp;&amp; E) || F)) {
  print(&quot;true&quot;);
} else {
  print(&quot;false&quot;);
}
</code></pre><p>One code sequence for this would be:</p><pre><code>start:
      (t0 &lt;- evaluate A)
      IF        t0, 1            ; skip if (coerces to) true
      JUMP      skip_and1        ; AND is done, result in t0 (= A)
      (t0 &lt;- evaluate B)
      IF        t0, 1            ; skip if (coerces to) true
      JUMP      skip_and1        ; AND is done, result in t0 (= B)
      ; first AND evaluates to true, result in t0 (= B)
      JUMP        do_lnot

skip_and1:
      (t0 &lt;- evaluate C)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate D)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate E)
      IF        t0, 1
      JUMP      skip_and3
      ; second AND evaluates to true, result in t0 (= E)
      JUMP      do_lnot

skip_and2:
      (t0 &lt;- evaluate F)
      IF        t0, 1
      JUMP      skip_and3
      ; third AND evaluates to true, result in t0 (= F)
      JUMP      do_lnot

skip_and3:
      ; the OR sequence resulted in a value (in t0) which
      ; coerces to false.

      ; fall through to do_lnot

do_lnot:
      ; the AND/OR part is done, with result in t0.  Note that
      ; all code paths must provide the result value in the same
      ; temporary register.

      LNOT      t0, t0           ; coerce and negate
      IF        t0, 1            ; skip if true
      JUMP      false_path

true_path:
      (code for print(&quot;true&quot;))
      JUMP      done

false_path:
      (code for print(&quot;false&quot;))
      ; fall through

done:
      ; &quot;if&quot; is done
</code></pre><p>Because the result of the logical NOT is not actually needed, other than to decide which branch of the if statement to execute, some extra jumps can be eliminated:</p><pre><code>start:
      (t0 &lt;- evaluate A)
      IF        t0, 1            ; skip if (coerces to) true
      JUMP      skip_and1        ; AND is done, result in t0 (= A)
      (t0 &lt;- evaluate B)
      IF        t0, 1            ; skip if (coerces to) true
      JUMP      skip_and1        ; AND is done, result in t0 (= B)
      JUMP      false_path

skip_and1:
      (t0 &lt;- evaluate C)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate D)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate E)
      IF        t0, 1
      JUMP      skip_and3
      JUMP      false_path

skip_and2:
      (t0 &lt;- evaluate F)
      IF        t0, 1
      JUMP      skip_and3
      JUMP      false_path

skip_and3:
      ; the expression inside LNOT evaluated to false, so LNOT would
      ; yield true, and we fall through to the true path

true_path:
      (code for print(&quot;true&quot;))
      JUMP      done

false_path:
      (code for print(&quot;false&quot;))
      ; fall through

done:
      ; &quot;if&quot; is done
</code></pre><p>Which can be further refined to:</p><pre><code>start:
      (t0 &lt;- evaluate A)
      IF        t0, 1            ; skip if (coerces to) true
      JUMP      skip_and1        ; AND is done, result in t0 (= A)
      (t0 &lt;- evaluate B)
      IF        t0, 0            ; skip if (coerces to) false (-&gt; skip_and1)
      JUMP      false_path

skip_and1:
      (t0 &lt;- evaluate C)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate D)
      IF        t0, 1
      JUMP      skip_and2
      (t0 &lt;- evaluate E)
      IF        t0, 0            ; -&gt; skip_and2
      JUMP      false_path

skip_and2:
      (t0 &lt;- evaluate F)
      IF        t0, 0            ; -&gt; skip_and3
      JUMP      false_path

skip_and3:
      ; the expression inside LNOT evaluated to false, so LNOT would
      ; yield true, and we fall through to the true path

true_path:
      (code for print(&quot;true&quot;))
      JUMP      done

false_path:
      (code for print(&quot;false&quot;))
      ; fall through

done:
      ; &quot;if&quot; is done
</code></pre><p>The current compilation model for logical AND and OR is quite simple. It avoids the need for explicit back-patching (all back-patching state is kept in C stack), and allows generation of code on-the-fly. Although logical AND and OR expressions are syntactically <em>left-associative</em>, they are parsed and evaluated in a <em>right-associate</em> manner.</p><p>For instance, <code>A &amp;&amp; B &amp;&amp; CC</code> is evaluated as <code>A &amp;&amp; (B &amp;&amp; C)</code>, which allows the which processes the first logical AND to generate the code for the latter part <code>B &amp;&amp; C</code> recursively, and then back-patch a skip jump over the entire latter part (= short circuiting the evaluation).</p><p>Unnecessary jumps are still generate between boundaries of AND and OR expressions (e.g. in <code>A &amp;&amp; B || C &amp;&amp; D</code>). These jumps are usually &quot;straightened out&quot; by the final peephole pass, possibly leaving unneeded instructions in bytecode, but generating more or less optimal run-time jumps.</p><p>Note that there are no opcodes for logical AND and logical OR. They would not be useful because short-circuit evaluation requires them to be control flow instructions rather than logical ones.</p><h2 id="compiling-function-calls-direct-eval" tabindex="-1">Compiling function calls; direct eval <a class="header-anchor" href="#compiling-function-calls-direct-eval" aria-label="Permalink to &quot;Compiling function calls; direct eval&quot;">​</a></h2><p>ECMAScript E5.1 handles <strong>direct</strong> <code>eval</code> calls differently from other <code>eval</code> calls. For instance, direct <code>eval</code> calls may declare new variables in the calling lexical scope, while variable declarations in non-direct <code>eval</code> calls will go into the global object. See:</p><ul><li>E5.1 Section 10.4.2: Entering Eval Code</li><li>E5.1 Section 15.1.2.1.1: Direct Call to Eval</li></ul><p>E5.1 Section 15.1.2.1.1 states that:</p><blockquote><p>A direct call to the eval function is one that is expressed as a CallExpression that meets the following two conditions:</p><p>The Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment record as its base value and its reference name is &quot;eval&quot;.</p><p>The result of calling the abstract operation GetValue with that Reference as the argument is the standard built-in function defined in 15.1.2.1.</p></blockquote><p>Note that it is <em>not</em> required that the binding be actually found in the global object, a local variable with the name <code>eval</code> and with the standard built-in <code>eval()</code> function as its value is also a direct eval call.</p><p>Direct <code>eval</code> calls cannot be fully detected at compile time, as we cannot always know the contents of the environment records outside the current function. The situation can even change at run time. See <code>test-dev-direct-eval.js</code> for an illustration using an intercepting <code>with</code> environment.</p><p>On the other hand, partial information can be deduced; in particular:</p><ul><li>If a function never performs a function call with the identifier name <code>eval</code>, we <em>can</em> be sure that there are no direct eval calls, as the condition for the identifier name is never fulfilled.</li></ul><p>The current approach is quite conservative, favoring correctness and simple compilation over performing complicated analysis. The current approach to handle a function call made using the identifier <code>eval</code> as follows:</p><ul><li>Flag the function as &quot;tainted&quot; by eval, which turns off most function optimizations to ensure semantic correctness. For example, the varmap is needed and the <code>arguments</code> object must be created on function entry in case eval code accesses it.</li><li>Call setup is made normally, it doesn&#39;t matter whether <code>eval</code> is bound to a register or accessed using <code>GETVAR</code>. It is perfectly fine for a direct eval to happen through a local variable.</li><li>Set the <code>DUK_BC_CALL_FLAG_EVALCALL</code> flag for the CALL bytecode instruction to indicate that the call was made using the identifier <code>&quot;eval&quot;</code>.</li></ul><p>Then at run time:</p><ul><li><code>CALL</code> handler notices that <code>DUK_BC_CALL_FLAG_EVALCALL</code> is set. It then checks if the target function is the built-in eval function, and if so, triggers direct eval behavior.</li></ul><h2 id="identifier-to-register-bindings" tabindex="-1">Identifier-to-register bindings <a class="header-anchor" href="#identifier-to-register-bindings" aria-label="Permalink to &quot;Identifier-to-register bindings&quot;">​</a></h2><h3 id="varmap-fast-path-and-slow-path" tabindex="-1">Varmap, fast path and slow path <a class="header-anchor" href="#varmap-fast-path-and-slow-path" aria-label="Permalink to &quot;Varmap, fast path and slow path&quot;">​</a></h3><p>Identifiers local to a function are (1) arguments, (2) variables, (3) function declarations, and (4) dynamic bindings like &quot;catch&quot; or &quot;let&quot; bindings. Local identifiers are handled in one of two ways:</p><ul><li>An identifier can be bound to a fixed register in the value stack frame allocated to the function. For example, an identifier named <code>&quot;foo&quot;</code> might be bound to register 7 (R7). This is possible when the identifier is known at compile time, a suitable register is available, and when the identifier binding is not deletable (which is usually, but not always, the case).</li><li>An identifier can be always accessed explicitly by name, and its value will be stored in an explicit environment record object. This is possible in all cases, including dynamically established and non-deletable bindings.</li></ul><p>Only function code identifiers can be register mapped. For global code declarations are mapped to the global object (an &quot;object binding&quot;). For non-strict eval code the situation is a bit different: a variable declaration inside a direct eval call will declare new variable to the <em>containing scope</em>. Such bindings are also deletable whereas local declarations in a function are not.</p><p>An example of a function and identifier binding:</p><pre><code>function f(x, y) {
  // Arguments &#39;x&#39; and &#39;y&#39; can be mapped to registers R0 and R1.

  // Local variable can be mapped to register R2.
  var a = 123;

  // Dynamically declared variable is created in an explicit environment
  // record and is not register mapped.
  eval(&#39;var b = 321&#39;);
}
</code></pre><p>When the compiler encounters an identifier access in the local function it looks through the variable map (&quot;varmap&quot;) which records identifier names and their associated registers. If the identifier is found in the varmap, it is safe to access the identifier with a direct register reference which is called a &quot;fast path&quot; access. This is safe because only non-deletable bindings are register mapped, so there&#39;s no way that the binding would later be removed e.g. by uncontrolled eval() calls. There&#39;s also nothing that could come in the way to capture the reference. For example, the ECMAScript statement:</p><pre><code>a += 1;
</code></pre><p>could be compiled to the following when &quot;a&quot; is in the varmap and mapped to R2:</p><pre><code>INC R2
</code></pre><p>When the identifier is not in the varmap, the compiler uses the &quot;slow path&quot; which means addressing identifers by name. For example, the ECMAScript statement:</p><pre><code>b += 1;
</code></pre><p>could be compiled to the following when &quot;b&quot; is <em>not</em> in the varmap:</p><pre><code>; c3 = &#39;b&#39;
; r4 = temp reg

GETVAR r4, c3  ; read &#39;b&#39; to r4
INC r4
PUTVAR r4, c3  ; write r4 to &#39;b&#39;
</code></pre><p>The GETVAR and PUTVAR opcodes (and other slow path opcodes) are handled by the executor by looking up the variable name through explicit environment record objects, which is more or less equivalent to a property lookup through an object&#39;s prototype chain. The slow path is available at any time for looking up any identifier, including a register mapped one.</p><p>When a function call exits, the executor copies any register mapped values from the value stack frame into an environment record object so that any inner functions which are still active can continue to access values held by the outer function. An example of inner functions accessing a &quot;closed&quot; outer function:</p><pre><code>function outer(val) {
  var foo = &#39;bar&#39;;
  return function inner() {
    print(val);
    print(foo);
  }
}

// Once outer() returns, &#39;fn&#39; refers to a function which can still see
// into the variables held in outer().
var fn = outer(123);

fn();  // prints 123, &quot;bar&quot;
</code></pre><h3 id="basic-optimizations" tabindex="-1">Basic optimizations <a class="header-anchor" href="#basic-optimizations" aria-label="Permalink to &quot;Basic optimizations&quot;">​</a></h3><p>A few optimizations are applied to the conceptual model described above:</p><ul><li><p>Creation of a lexical environment object is delayed for a function call when possible, so that an actual object is only created when necessary. Most functions don&#39;t establish new local bindings so there&#39;s no need to create an explicit lexical environment object for every function call.</p></li><li><p>When a function exits, identifier values are copied from registers to a lexical environment object only when necessary -- e.g. when the function has inner functions or eval calls. The compiler makes a conservative estimate when this step can be omitted for better performance.</p><p>Here&#39;s an example when an eval() is enough to access function bindings after function exit:</p><pre><code>duk&gt; function f(x) { var foo=123; return eval(x); }
= undefined
duk&gt; g = f(&#39;(function myfunc() { print(foo); })&#39;);
= function myfunc() {/* ecmascript */}
duk&gt; g()
123
= undefined
</code></pre></li><li><p>When there is no possibility of slow path accesses to identifiers nor any constructs which might otherwise access the varmap (direct eval calls, inner functions, etc), the compiler can omit the &quot;varmap&quot; from the final function template. However, when debugger support is enabled, varmap is always kept so that the debugger can inspect variable names for all functions.</p></li></ul><h3 id="arguments-object" tabindex="-1">Arguments object <a class="header-anchor" href="#arguments-object" aria-label="Permalink to &quot;Arguments object&quot;">​</a></h3><p>The <code>arguments</code> object is special and quite expensive to create when calling a function. The need to create an arguments objects is recorded into the final function template with the <code>DUK_HOBJECT_FLAG_CREATEARGS</code> flag which is checked in call handling.</p><p>The compiler can omit argument object creation only when it&#39;s absolutely certain it won&#39;t be needed. For example the following will now cause the arguments object to be created on function entry (sometimes unnecessarily):</p><ul><li>If there&#39;s an <code>eval</code> anywhere in the function there&#39;s a risk it will access the arguments object.</li><li>If there&#39;s an identifier reference using the name <code>arguments</code> which is not shadowed the arguments object may be referenced.</li></ul><p>Delaying arguments object creation to the point of an actual access is not trivial because argument values may have already been mutated and they affect arguments object creation.</p><h3 id="current-approach" tabindex="-1">Current approach <a class="header-anchor" href="#current-approach" aria-label="Permalink to &quot;Current approach&quot;">​</a></h3><ul><li>The <code>varmap</code> keeps track of identifier-to-register bindings. In the first pass the <code>varmap</code> is empty; the <code>varmap</code> is populated before the second pass. First pass gathers argument names, variable declarations, and inner function declarations.</li><li>After first pass but before second pass the effects of declaration binding instantiation (E5.1 Section 10.5) are considered and a <code>varmap</code> is built. The varmap contains all known identifiers, and their names are mapped either to an integer (= register number) or <code>null</code> (identifier is declared but not register mapped). The rather complex shadowing rules for arguments, variable declarations, and inner function declarations are handled in this step.</li><li><code>catch</code> clause bindings: handled at runtime by the try-catch-finally opcodes by creating an explicit lexical scope with the catch variable binding. All code accessing the catch variable name inside the catch clause uses slow path lookups; this leaves room for future work to handle catch bindings better.</li><li><code>with</code> statements: handled at runtime by try-catch-finally opcodes by creating an explicit lexical scope indicating an &quot;object binding&quot;. The <code>with_depth</code>, the number of nested <code>with</code> statements, is tracked during compilation. A non-zero with_depth prevents fast path variable accesses entirely because potentially any identifier access is captured by the object binding.</li><li>After second pass, when creating the final function template, the <code>varmap</code> is cleaned up: <code>null</code> entries are removed and the map is compacted.</li></ul><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><p>Some future work (not a comprehensive list by any means), in no particular order.</p><h3 id="better-handling-of-catch-variables-let-bindings" tabindex="-1">Better handling of &quot;catch&quot; variables, &quot;let&quot; bindings <a class="header-anchor" href="#better-handling-of-catch-variables-let-bindings" aria-label="Permalink to &quot;Better handling of \\&quot;catch\\&quot; variables, \\&quot;let\\&quot; bindings&quot;">​</a></h3><p>Current handling for &quot;catch&quot; variables creates an explicit lexical environment object and uses slow path for accessing the variable. This is far from optimal but requires more compiler state to be solved better.</p><p>Similarly the ES2015 &quot;let&quot; binding needs efficient support to be useful.</p><h3 id="improve-line-number-assignment" tabindex="-1">Improve line number assignment <a class="header-anchor" href="#improve-line-number-assignment" aria-label="Permalink to &quot;Improve line number assignment&quot;">​</a></h3><p>Current compiler associates opcode line numbers with the &quot;previous token&quot; which is always not correct. Add the necessary plumbing to associate opcode line numbers more accurately.</p><h3 id="partial-copy-of-variables-when-closing-a-function-scope" tabindex="-1">Partial copy of variables when closing a function scope <a class="header-anchor" href="#partial-copy-of-variables-when-closing-a-function-scope" aria-label="Permalink to &quot;Partial copy of variables when closing a function scope&quot;">​</a></h3><p>As of Duktape 1.3 when an outer function containing inner functions exits, its lexical scope is closed with variable values copied from VM registers (value stack frame) into an explicit scope object. This works correctly but causes a reference to be held for all variables in the outer scope, even those that are <em>never</em> accessed by any inner function, see: <a href="https://github.com/svaarala/duktape/issues/229" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/229</a>.</p><p>This could be fixed by improving the compiler a bit:</p><ul><li>For every variable in the varmap, track the variable&#39;s current register mapping and a flag indicating if it has been referenced by an inner function (&quot;keep on close&quot;).</li><li>Whenever a function dereferences a variable not defined in the function itself, scan outer lexical scopes for matching variables. If so, mark that variable in the outer function as being referenced by an inner function. (Note that if any involved function has an eval(), all bets are off and conservative code must be generated, as eval() may introduce new bindings at run time.)</li><li>Encode that &quot;keep on close&quot; flags to the final compilation result (the function template). If eval()s are involved, mark all variables as &quot;keep on close&quot;.</li><li>At run time, when a function exits, copy only &quot;keep on close&quot; variables into the explicit scope object. Other variables are then decref&#39;d and finalized if appropriate.</li></ul><h3 id="make-ivalue-manipulation-shuffling-aware" tabindex="-1">Make ivalue manipulation shuffling aware <a class="header-anchor" href="#make-ivalue-manipulation-shuffling-aware" aria-label="Permalink to &quot;Make ivalue manipulation shuffling aware&quot;">​</a></h3><p>Current ivalue manipulation is not aware of register shuffling. Instead, ivalue manipulation relies on bytecode emission helpers to handle shuffling as necessary. Sometimes this results in sub-optimal opcode sequences (e.g. the result of an operation shuffled to a high register and then immediately needed in a subsequent operation). Code quality could be improved by making ivalue manipulation shuffling aware.</p><h3 id="improve-support-for-large-functions" tabindex="-1">Improve support for large functions <a class="header-anchor" href="#improve-support-for-large-functions" aria-label="Permalink to &quot;Improve support for large functions&quot;">​</a></h3><p>Large functions don&#39;t produce very good code with the current compiler:</p><ul><li>The method of binding identifiers to registers consumes a lot of useful low registers which can be directly addressed by all opcodes. It might be better to reserve identifiers in a non-continuous fashion so that a reasonable number of temporary registers could also be guaranteed to be in the low register range.</li><li>The method of allocating temporaries may reserve low registers as temporaries which are then not available for inner expressions which are often more important for performance (think outer loop vs. inner loop).</li></ul><p>These are not fundamental limitations of the compiler, but there&#39;s been little effort to improve support for large functions so far, other than to ensure they work correctly.</p><h3 id="chunked-stream-parsing-with-rewind" tabindex="-1">Chunked stream parsing with rewind <a class="header-anchor" href="#chunked-stream-parsing-with-rewind" aria-label="Permalink to &quot;Chunked stream parsing with rewind&quot;">​</a></h3><p>For low memory environments it would be useful to be able to stream source code off e.g. flash memory. Because Duktape decodes the source code into a codepoint window anyway, hiding the streaming process would be relatively straightforward.</p><p>Adding support for streaming would involve using a callback (perhaps a pure C callback or even an actual Duktape/C or ECMAScript callback) for providing a chunk of source code for Duktape to decode from. Another callback would be needed to rewind to a specified position. Another approach is to provide a callback to provide at most N bytes starting from a specified offset, and let the callback optimize for continuous reads if that&#39;s helpful.</p><p>Allowing source code compression is also preferable. It&#39;s possible to use an ordinary stateful compression algorithm (like deflate) for the source code, but in a naive implementation any rewind operation means that the decompression must restart from the beginning of the entire source text. A more practical approach is to use chunked compression so that semi-random access is possible and reasonably efficient.</p><p>One more design alternative is to model the source input as a sequence of Unicode codepoints instead of bytes, so that Duktape would just request a sequence of codepoints starting from a certain <em>codepoint</em> offset and then put them into the codepoint window. The user callback would handle character encoding as needed, which would simultaneously add support for custom source encodings. The downside of this approach is that the user callback needs the ability to map an arbitrary codepoint offset to a byte offset which is an awkward requirement for multibyte character encodings.</p><h3 id="context-aware-compilation-of-logical-expressions" tabindex="-1">Context aware compilation of logical expressions <a class="header-anchor" href="#context-aware-compilation-of-logical-expressions" aria-label="Permalink to &quot;Context aware compilation of logical expressions&quot;">​</a></h3><p>When a logical expression occurs in an &quot;if&quot; statement, the final result of the expression is not actually needed (only its truthiness matters). Further, the &quot;if&quot; statement only needs to decide between two alternative jumps, so that the short circuit handling used by the logical expression could just jump to those targets directly.</p><h3 id="improve-pool-allocator-compatibility" tabindex="-1">Improve pool allocator compatibility <a class="header-anchor" href="#improve-pool-allocator-compatibility" aria-label="Permalink to &quot;Improve pool allocator compatibility&quot;">​</a></h3><p>A small improvement would be to track opcodes and line numbers in separate buffers rather than a single buffer with <code>duk_compiler_instr</code> entries.</p><h3 id="split-compiler-into-multiple-files" tabindex="-1">Split compiler into multiple files <a class="header-anchor" href="#split-compiler-into-multiple-files" aria-label="Permalink to &quot;Split compiler into multiple files&quot;">​</a></h3><p>Example:</p><ul><li>Bytecode emission</li><li>Ivalue handling</li><li>Expression parser</li><li>Statement parser and entry point</li></ul><h3 id="using-some-memory-between-pass-1-and-pass-2" tabindex="-1">Using some &quot;memory&quot; between pass 1 and pass 2 <a class="header-anchor" href="#using-some-memory-between-pass-1-and-pass-2" aria-label="Permalink to &quot;Using some \\&quot;memory\\&quot; between pass 1 and pass 2&quot;">​</a></h3><p>The multi-pass compilation approach allows us to build some &quot;memory&quot; to help in code generation. In fact, pass 1 is now used to discover variable declarations, which is already a sort of memory which affects code generation later.</p><p>These would help, for example:</p><ul><li>Avoiding LABEL sites for iteration structures not requiring them. For instance, an iteration statement without an explicit label and with no &quot;break&quot; or &quot;continue&quot; statement inside the iteration construct does not need a LABEL site.</li><li>More simply, one could simply record all label sites created in pass 1, and note whether any break/continue targeted the label site in question. On pass 2, this state could be consulted to skip emitting label sites.</li></ul><p>Because the source is identical when reparsed, it is possible to address such &quot;memory&quot; using e.g. statement numbering, expression numbering, or token numbering, where the numbers are assigned from start of the function (the rewind point).</p><h3 id="compile-time-lookups-for-non-mutable-constants" tabindex="-1">Compile time lookups for non-mutable constants <a class="header-anchor" href="#compile-time-lookups-for-non-mutable-constants" aria-label="Permalink to &quot;Compile time lookups for non-mutable constants&quot;">​</a></h3><p>Variable lookups are represented by ivalues which identify a variable by name. Eventually they get converted to concrete code which reads a variable either directly from a register, or using a slow path GETVAR lookup.</p><p>This could be improved in several ways. For example, if support for <code>const</code> was added, the ivalue conversion could detect that the variable maps to a constant in the current function or an outer function (with the necessary checks to ensure no &quot;capturing&quot; bindings can be established by e.g. an eval). The ivalue could then be coerced into a registered constant, copying the value of the constant declaration.</p><h3 id="slow-path-record-skip-count" tabindex="-1">Slow path record skip count <a class="header-anchor" href="#slow-path-record-skip-count" aria-label="Permalink to &quot;Slow path record skip count&quot;">​</a></h3><p>When a slow path access is made, some environment record lookups can be skipped if the records belong to functions which have no potential for dynamically introduced bindings. For example:</p><pre><code>var foo = 123;  // global

function func1() {
    var foo = 321;

    function func2() {
        var bar = 432;

        function func3() {
            var quux = 543;

            // The slow path lookup for &#39;hello&#39; can skip func3, func2, and
            // func1 entirely because it will never match there.  In other
            // words, we could look up &#39;hello&#39; directly from the global object.
            print(&#39;hello&#39;);

            // The slow path lookup for &#39;foo&#39; could bypass func3 and func2,
            // and begin from func1.
            print(foo);
        }
    }
}
</code></pre><p>Any function with an <code>eval()</code> will potentially contain any binding, &quot;with&quot; statements must be handled correctly, etc.</p><p>This optimization would be nice for looking up global bindings like <code>print</code>, <code>Math</code>, <code>Array</code>, etc.</p><p>The technical change would be for e.g. GETVAR to get an integer argument indicating how many prototype levels to skip when looking up the binding.</p><h3 id="slow-path-non-configurable-non-writable-bindings" tabindex="-1">Slow path non-configurable, non-writable bindings <a class="header-anchor" href="#slow-path-non-configurable-non-writable-bindings" aria-label="Permalink to &quot;Slow path non-configurable, non-writable bindings&quot;">​</a></h3><p>When a slow path access is certain to map to a non-configurable, non-writable value, the value could be copied into the function&#39;s constant table and used directly without an actual slow path lookup at run time. There are a few problems with this:</p><ul><li>At the moment constants can only be numbers and strings, and this affects bytecode dump/load. If a constant were e.g. a function reference, bytecode dump/load wouldn&#39;t be able to handle it without some backing information to reconstruct the reference on bytecode load.</li><li>Even though a binding is non-writable and non-configurable, it can still be changed by C code with <code>duk_def_prop()</code>. This is intentional so that C code has more freedom for sandboxing and such. For such environments this optimization might not always be appropriate.</li></ul><h3 id="better-handling-of-shared-constant-detection" tabindex="-1">Better handling of shared constant detection <a class="header-anchor" href="#better-handling-of-shared-constant-detection" aria-label="Permalink to &quot;Better handling of shared constant detection&quot;">​</a></h3><p>When a new constant is introduced, the current implementation linearly walks through existing constants to see if one can be reused. This walk is capped to ensure reasonable compilation times even for functions with a large number of constants.</p><p>A better solution would be to use a faster search structure for detecting shared constants, e.g. a hash map with more flexible keys than in ECMAScript objects (perhaps one of the ES2015 maps).</p><h3 id="better-switch-case-handling" tabindex="-1">Better switch-case handling <a class="header-anchor" href="#better-switch-case-handling" aria-label="Permalink to &quot;Better switch-case handling&quot;">​</a></h3><p>It would be nice to support at least dense integer ranges and use a jump table to handle them. This is important, for example, if a switch-case implements some kind of integer-dependent dispatch such as an opcode decoder.</p>`,502)]))}const m=t(i,[["render",r]]);export{u as __pageData,m as default};
