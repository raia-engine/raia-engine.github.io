import{_ as t,c as a,a2 as o,o as n}from"./chunks/framework.DPuwY6B9.js";const h=JSON.parse('{"title":"Duktape 2.2 release notes","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/release-notes-v2-2.md","filePath":"resource/duktape/doc/release-notes-v2-2.md","lastUpdated":1732350347000}'),r={name:"resource/duktape/doc/release-notes-v2-2.md"};function i(l,e,s,c,u,d){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="duktape-2-2-release-notes" tabindex="-1">Duktape 2.2 release notes <a class="header-anchor" href="#duktape-2-2-release-notes" aria-label="Permalink to &quot;Duktape 2.2 release notes&quot;">​</a></h1><h2 id="release-overview" tabindex="-1">Release overview <a class="header-anchor" href="#release-overview" aria-label="Permalink to &quot;Release overview&quot;">​</a></h2><p>Main changes in this release (see RELEASES.rst for full details):</p><ul><li>Internal reworking of call handling for better performance and code sharing. Coroutine yield and tail call restrictions removed when using new Foo(), .call(), .apply(), Reflect.apply(), and Reflect.construct(). Maximum call argument count increased to ~64k.</li><li>C API additions: duk_seal(), duk_freeze(), duk_is_constructable(), duk_require_object(), duk_push_proxy(), macros for creating symbol literals in C code (DUK_HIDDEN_SYMBOL(&quot;myValue&quot;) etc), and more duk_def_prop() convenience flags. The 0xFF byte prefix is now reserved entirely for user hidden Symbols, so there are no longer restrictions in what follows the prefix.</li><li>More ES2015 features: Math.clz32(), Math.imul(), Math.sign(), Object.prototype.{__defineGetter__,__defineSetter__}, Object.prototype.{__lookupGetter__,_lookupSetter__}, Proxy &#39;apply&#39; and &#39;construct&#39; traps, minimal new.target, and fixed string/symbol key sorting.</li><li>Performance.now() binding and a monotonic time provider.</li><li>Case insensitive RegExp character class canonicalization performance has improved by ~50x using a small lookup table (256 bytes, total footprint impact is ~300-400 bytes).</li><li>Performance, footprint, and portability improvements. Also improvements to error messages, value summaries, and assertion coverage.</li></ul><h2 id="upgrading-from-duktape-2-1" tabindex="-1">Upgrading from Duktape 2.1 <a class="header-anchor" href="#upgrading-from-duktape-2-1" aria-label="Permalink to &quot;Upgrading from Duktape 2.1&quot;">​</a></h2><p>No action (other than recompiling) should be needed for most users to upgrade from Duktape v2.1.x. Note the following:</p><ul><li>There are public API macros to create different Symbol types as C literals. For example, DUK_HIDDEN_SYMBOL(&quot;myPointer&quot;) can now be used instead of manually creating the internal representation (&quot;xFF&quot; &quot;myPointer&quot;).</li><li>Bytecode dump format has been changed slightly: initial byte is now 0xBF (previously 0xFF) to avoid potential confusion with Symbol strings, and serialization version byte (in practice unused) was removed from the format. If any application code checks for bytecode files using a 0xFF initial byte check, it will need to be updated to check for 0xBF.</li><li>The typedef for duk_bool_t was changed from duk_small_int_t (typically &#39;int&#39;) to duk_small_uint_t (typically &#39;unsigned int&#39;). API constants for DUK_TYPE_xxx, DUK_TYPE_MASK_xxx, flags, etc were changed to unsigned (e.g. &#39;(1U &lt;&lt; 3)) to match their C type. These changes may cause some sign conversion warnings in application call sites.</li><li>duk_safe_call() no longer automatically extends the value stack to ensure there&#39;s space for &#39;nrets&#39; return values. This was not guaranteed by the API and the check is mostly unnecessary overhead. If a duk_safe_call() call site now fails due to this change, simply <code>duk_require_stack()</code> to ensure that there&#39;s reserve for <code>nargs - nrets</code> more elements (conceptually &#39;nargs&#39; arguments are consumed, and &#39;nrets&#39; result values pushed).</li><li>Call stack (including both activation records and catcher records) is no longer a resized monolithic allocation which improves memory behavior for very low memory targets. If you&#39;re using a pool allocator, you may need to measure and adjust pool sizes/counts.</li><li>Function.prototype.call(), Function.prototype.apply(), Reflect.apply(), new Xyz(), duk_new(), and Reflect.construct() are now handled inline in call handling. As a result, they are not part of the call stack, are absent in tracebacks, don&#39;t consume native stack for ECMAScript-to-ECMAScript calls, no longer prevent a coroutine yield, and can be used in tail call positions (e.g. &#39;return func.call(null, 1, 2);&#39;).</li><li>Functions pushed using duk_push_c_function() and duk_push_c_lightfunc() now inherit from an intermediate prototype (func -&gt; %NativeFunctionPrototype% -&gt; Function.prototype) which provides <code>.name</code> and <code>.length</code> getters. The setters are intentionally missing so direct writes for these properties fail, but you can write them using <code>Object.defineProperty()</code> or <code>duk_def_prop()</code>. The inherited getters can also be replaced if necessary. The intermediate prototype doesn&#39;t have a named global binding, but you can access it by reading the prototype of a pushed function.</li><li>The bound &#39;this&#39;, bound arguments, and target of a duk_hboundfunc are no longer internal properties (but duk_hboundfunc struct members). The &#39;this&#39; binding, target, and bound argument count are now visible as artificial properties; the bound argument values are not visible in the debugger protocol for now.</li><li>The Proxy target and handler references are no longer internal properties (but duk_hproxy struct members), and are not visible in the debugger protocol for now.</li><li>DUK_USE_DATE_GET_NOW() is now allowed to return fractions. The fractions won&#39;t be available through the Date built-in (this is forbidden by the ECMAScript specification) but are available through the duk_get_now() C API call. The default POSIX and Windows Date providers now return fractions, so duk_get_now() call sites may now get fractional millisecond timestamps even in default configuration.</li><li>Debugger StepInto, StepOver, and StepOut are now accepted also when the current function doesn&#39;t have line information (i.e. it is native). The step commands will still pause on function entry/exit as appropriate; for example, StepInto will pause on function entry or exit (or an error throw).</li><li>Case insensitive RegExps now perform better by default, with the small canonicalization lookup (~300-400 bytes, DUK_USE_REGEXP_CANON_BITMAP) enabled by default. The small lookup still performs slower than DUK_USE_REGEXP_CANON_WORKAROUND but the difference is smaller, and you may be able to turn off the workaround option whose main downside is a relatively large footprint impact (128kB).</li><li>When an Error instance is being constructed and Duktape.errCreate() is called for the constructor return value, the call stack seen by errCreate() now includes the constructor call (previously it was unwound before calling errCreate()). This affects e.g. any Duktape.act() calls in errCreate().</li></ul>',7)]))}const f=t(r,[["render",i]]);export{h as __pageData,f as default};
