import{_ as t,c as o,a2 as r,o as a}from"./chunks/framework.DzmM640o.js";const h=JSON.parse('{"title":"duk_hobject","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-design.md","filePath":"resource/duktape/doc/hobject-design.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/hobject-design.md"};function n(s,e,l,d,c,p){return a(),o("div",null,e[0]||(e[0]=[r(`<h1 id="duk-hobject" tabindex="-1">duk_hobject <a class="header-anchor" href="#duk-hobject" aria-label="Permalink to &quot;duk_hobject&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>The <code>duk_hobject</code> type represents an object with key-value properties, and is the most important type from an implementation point of view. It provides objects for various purposes:</p><ul><li>Objects with E5 normal object semantics</li><li>Objects with E5 array object exotic behavior</li><li>Objects with E5 string object exotic behavior</li><li>Objects with E5 arguments object exotic behavior</li><li>Objects with no E5 semantics, for internal use</li></ul><p>This document discusses the <code>duk_hobject</code> object in detail, including:</p><ul><li>Requirements overview</li><li>Features of ECMAScript E5 objects</li><li>Internal data structure and algorithms</li><li>Enumeration guarantees</li><li>ECMAScript property behavior (default and exotic)</li><li>Design notes, future work</li></ul><p>The details of property-related algorithms in E5 are pretty intricate and are described separately in <code>hobject-algorithms.rst</code>.</p><p>The following parts of ECMAScript E5 are useful background:</p><table tabindex="0"><thead><tr><th>Section</th><th>Description</th></tr></thead><tbody><tr><td>8.6</td><td>Object type, internal properties, property attributes</td></tr><tr><td>8.10</td><td>Property descriptors</td></tr><tr><td>8.12</td><td>Default property access methods</td></tr><tr><td>10.6</td><td>Arguments object exotic behavior</td></tr><tr><td>15.4.5.1</td><td>Array object exotic behavior</td></tr><tr><td>15.5.5.2</td><td>String object exotic behavior</td></tr></tbody></table><p>See also the following documentation:</p><ul><li><code>hobject-algorithms.rst</code>: detailed derivation of object algorithms</li><li><code>hobject-enumeration.rst</code>: more discussion on enumeration</li><li><code>error-objects.rst</code>: error object properties</li><li><code>function-objects.rst</code>: function template and instance properties</li></ul><h2 id="requirements-overview" tabindex="-1">Requirements overview <a class="header-anchor" href="#requirements-overview" aria-label="Permalink to &quot;Requirements overview&quot;">​</a></h2><p>ECMAScript object compatibility requires:</p><ul><li>Properties with a string key and a value that is either a plain data value or an accessor (getter/setter)</li><li>Property attributes which control the behavior of individual properties (e.g. enumerability and writability)</li><li>Object extensibility flag which controls addition of new properties</li><li>Prototype-based inheritance of properties along a loop-free prototype chain</li><li>Some very basic enumeration guarantees for both mutating and non-mutating enumeration</li><li>Object internal properties (at a conceptual level)</li></ul><p>Additional practical requirements include:</p><ul><li>Additional enumeration guarantees (e.g. enumeration order matches key insertion order); see separate discussion on enumeration</li><li>Minimal memory footprint, especially for objects with few properties which dominate common use</li><li>Near constant property lookup performance, even for large objects</li><li>Near constant amortized property insert performance, even for large objects</li><li>Fast read/write access for array entries, in particular avoiding string interning whenever possible</li><li>Sparse array support (e.g. <code>var x=[]; x[0]=1; x[1000000]=2;</code>): must be compliant, shouldn&#39;t allocate megabytes of memory, but does not have to be fast</li><li>Support long-lived objects with an arbitrary number of key insertions and deletions (implies &quot;compaction&quot; of keys / ordering structure)</li></ul><p>There are unavoidable trade-offs involved, the current trade-off preferences are roughly as follows (most important to least important):</p><ol><li>Compliance</li><li>Compactness</li><li>Performance</li><li>Low complexity</li></ol><p>Compliance is a must-have goal for all object features. Performance is only really relevant for common idioms. Rare cases need to be compliant but not especially compact or performant: for instance, sparse arrays don&#39;t perform very well but are still compliant.</p><h2 id="object-features" tabindex="-1">Object features <a class="header-anchor" href="#object-features" aria-label="Permalink to &quot;Object features&quot;">​</a></h2><h3 id="named-and-internal-properties" tabindex="-1">Named and internal properties <a class="header-anchor" href="#named-and-internal-properties" aria-label="Permalink to &quot;Named and internal properties&quot;">​</a></h3><p>An ECMAScript object consists of:</p><ul><li>A set of externally visible <em>named properties</em></li><li>A set of (conceptual) <em>internal properties</em></li></ul><p>The externally visible named properties are characterized by:</p><ul><li>A string key <ul><li>16-bit characters (any 16-bit unsigned integer codepoints may be used)</li><li>Even array indices are strings, e.g. <code>x[0]</code> really means <code>x[&quot;0&quot;]</code></li></ul></li><li>A property value which may be: <ul><li>A <em>data property</em>, a plain ECMAScript value</li><li>An <em>accessor property</em>, a setter/getter function pair invoked for property accesses</li></ul></li><li>Property attributes which control property accesses: <ul><li>For data properties: <ul><li><code>[[Configurable]]</code></li><li><code>[[Enumerable]]</code></li><li><code>[[Value]]</code></li><li><code>[[Writable]]</code></li></ul></li><li>For accessor properties: <ul><li><code>[[Configurable]]</code></li><li><code>[[Enumerable]]</code></li><li><code>[[Get]]</code></li><li><code>[[Set]]</code></li></ul></li></ul></li><li>The <code>[[Extensible]]</code> internal property determines whether new (own) keys can be added to an object. Many other internal properties exist.</li></ul><p>Internal properties are used in E5 to specify required behavior; the concrete property implementation is implementation specific. The current implementation for internal properties is covered in more detail below.</p><h3 id="property-attributes-and-descriptors" tabindex="-1">Property attributes and descriptors <a class="header-anchor" href="#property-attributes-and-descriptors" aria-label="Permalink to &quot;Property attributes and descriptors&quot;">​</a></h3><p>Property attributes affect property access algorithms internally. They are also externally visible and can be manipulated through built-in methods. The property attributes are:</p><ul><li><code>[[Configurable]]</code></li><li><code>[[Enumerable]]</code></li><li><code>[[Value]]</code></li><li><code>[[Writable]]</code></li><li><code>[[Get]]</code></li><li><code>[[Set]]</code></li></ul><p>New properties added to objects by an assignment are by default data properties with the following attributes: <code>[[Writable]]=true</code>, <code>[[Enumerable]]=true</code>, <code>[[Configurable]]=true</code>. This is implicit in the <code>[[Put]]</code> algorithm (E5 Section 8.12.5, step 6). Note that these defaults differ from the &quot;official default values&quot; (all attributes <code>false</code>) in E5 Section 8.6.1 which are used for e.g. <code>[[DefineOwnProperty]]</code>.</p><p>User code can deviate from the defaults for assignments by defining or modifying properties using <code>Object.defineProperty()</code>. This is not very common, so almost all user properties have default attributes. Built-in objects often have properties with non-default attributes, though.</p><p>A <em>property descriptor</em> contains zero or more property attributes, and is used both internally and externally to describe or modify property attributes. Property descriptors are used internally in the E5 specification with the following notation:</p><pre><code>{ \`\`[[Value]]\`\`: 42, \`\`[[Writable]]\`\`: true }
</code></pre><p>The same property descriptor would be represented as an external ECMAScript value:</p><pre><code>{ &quot;value&quot;: 42, &quot;writable&quot;: true }
</code></pre><p>The internal and external property descriptors are converted through the internal <code>FromPropertyDescriptor()</code> and <code>ToPropertyDescriptor()</code> methods.</p><p>Property descriptors are classified into several categories based on what keys they contain:</p><ul><li>Data property descriptor: contains <code>[[Value]]</code> or <code>[[Writable]]</code></li><li>Accessor property descriptor: contains <code>[[Set]]</code> or <code>[[Get]]</code></li><li>Generic property descriptor: a descriptor which is neither a data nor an accessor property descriptor, i.e. does not contain <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Set]]</code>, or <code>[[Get]]</code></li></ul><p>Although a property descriptor can technically be both a data property descriptor and an accessor property descriptor at the same time, such descriptors are rejected whenever they are encountered. The <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes can be in any kind of a descriptor.</p><p>A property descriptor is <em>fully populated</em> if it contains all the keys of its type, i.e.:</p><ul><li>A fully populated data descriptor contains all of the following: <code>[[Configurable]]</code>, <code>[[Enumerable]]</code>, <code>[[Value]]</code>, <code>[[Writable]]</code></li><li>A fully populated accessor descriptor contains all of the following: <code>[[Configurable]]</code>, <code>[[Enumerable]]</code>, <code>[[Get]]</code>, <code>[[Set]]</code></li></ul><p>The property attributes stored in the object for a certain property always form a fully populated property descriptor. Any missing values are always filled in with defaults when a property is first inserted, and although attribute values can be changed after insertion, the attributes themselves cannot be removed.</p><p>Partially populated property descriptors are used internally in the specification for describing property modifications. They can also be used externally (for similar purposes) through <code>Object.defineProperty()</code>.</p><p>Consider the following example, which illustrates how properties and their attributes can be defined in various ways:</p><pre><code>// array initializer
var o = [ &quot;one&quot;, &quot;two&quot; ];  // also sets &quot;length&quot; to 2

// add &quot;foo&quot; (writable, enumerable, configurable)
o.foo = 1;

// modify attributes after insertion
Object.defineProperty(o, &quot;foo&quot;, {
  writable: false
});

// insert an accessor, with [[DefineOwnProperty]] default
// attributes (non-enumerable, non-configurable)
Object.defineProperty(o, &quot;bar&quot;, {
  &quot;get&quot;: function() { return &quot;bar&quot;; },
  &quot;set&quot;: function(x) { throw new Error(&quot;cannot write bar&quot;); }
});
</code></pre><p>The object would have the following internal state (represented as external property descriptors):</p><pre><code>&quot;0&quot;       --&gt;  { &quot;configurable&quot;: true,
                 &quot;enumerable&quot;: true,
                 &quot;writable&quot;: true,
                 &quot;value&quot;: &#39;one&#39; }

&quot;1&quot;       --&gt;  { &quot;configurable&quot;: true,
                 &quot;enumerable&quot;: true,
                 &quot;writable&quot;: true,
                 &quot;value&quot;: &#39;two&#39; }

// non-default attributes (E5 Section 15.4.5.2)
&quot;length&quot;  --&gt;  { &quot;configurable&quot;: false,
                 &quot;enumerable&quot;: false,
                 &quot;writable&quot;: true,
                 &quot;value&quot;: 2 }

&quot;foo&quot;     --&gt;  { &quot;configurable&quot;: true,
                 &quot;enumerable&quot;: true,
                 &quot;writable&quot;: false,
                 &quot;value&quot;: 1 }

// [[DefineOwnProperty]] defaults for new properties
// differ from [[Put]] (defaults to false)
&quot;bar&quot;     --&gt;  { &quot;configurable&quot;: false,
                 &quot;enumerable&quot;: false,
                 &quot;get&quot;: &lt;function reference&gt;,
                 &quot;set&quot;: &lt;function reference&gt; }
</code></pre><p>Property descriptors can also be read back from user code through <code>Object.getOwnPropertyDescriptor()</code>. Example using NodeJS / V8:</p><pre><code>var o = {
  foo: 1,

  get bar() { return &quot;bar&quot;; },
  set bar(x) { throw new Error(&quot;cannot write bar&quot;); }
};

// Prints:
// { value: 1,
//   writable: true,
//   enumerable: true,
//   configurable: true }

console.log(Object.getOwnPropertyDescriptor(o, &quot;foo&quot;));

// Prints:
// { get: [Function: bar],
//   set: [Function: bar],
//   enumerable: true,
//   configurable: true }

console.log(Object.getOwnPropertyDescriptor(o, &quot;bar&quot;));
</code></pre><p>The visibility of property attributes to user code poses some implementation challenges. Ordinary property access occurs through the <code>[[Get]]</code>, <code>[[Put]]</code>, and <code>[[Delete]]</code> algorithms, hiding some of the internal complexity regarding property attributes etc. However, the built-in method <code>Object.defineProperty()</code> exposes the internal <code>[[DefineOwnProperty]]</code> in all its complexity to user code.</p><p>The current implementation manages to use fully populated descriptors internally, and expose partial descriptors only through <code>Object.defineProperty()</code>.</p><h3 id="prototype-chain" tabindex="-1">Prototype chain <a class="header-anchor" href="#prototype-chain" aria-label="Permalink to &quot;Prototype chain&quot;">​</a></h3><p>Each object has a non-mutable <em>internal prototype</em> established at object creation (<code>[[Prototype]]</code> internal property). The value of the internal prototype must be another object or null. Since the prototype object may also have an internal prototype (and so on), the objects form a non-mutable <em>prototype chain</em> terminating at an object whose internal prototype is <code>null</code>.</p><p>The prototype chain affects most property access algorithms with the general principle that if a property is not found in a certain object, the prototype chain is then searched in ascending order. To simplify:</p><ul><li>Property read operations return the value found in the first object in the prototype chain containing the property. If an accessor property is found, the getter is called.</li><li>Property write operations first check the prototype chain to see whether the property exists. If so, the property may prevent the write (if a non-writable data property), cause a setter call (if an accessor property), or allow the write. The write is allowed and not captured by a setter, the property is added to the <em>original target object</em> (instead of an object possibly higher up in the prototype chain).</li><li>Property delete operations do not consult the prototype chain and only have an effect on the target object.</li></ul><p>The non-mutability of the prototype chain is not very explicit in the specification (nor does the current implementation assume or take advantage of its non-mutability). The requirement is stated in a footnote in E5 Section 8.6.2:</p><blockquote><p>NOTE This specification defines no ECMAScript language operators or built-in functions that permit a program to modify an object&#39;s <code>[[Class]]</code> or <code>[[Prototype]]</code> internal properties or to change the value of [[Extensible]] from false to true.</p></blockquote><p>The prototype chain is required to be loop-free; it is required to terminate in a null reference (again, in E5 Section 8.6.2):</p><blockquote><p>Every <code>[[Prototype]]</code> chain must have finite length (that is, starting from any object, recursively accessing the [[Prototype]] internal property must eventually lead to a null value).</p></blockquote><p>The current implementation makes no specific effort to ensure this because plain ECMAScript code cannot create prototype loops (though C code can easily do so). To see why this is the case, assume that the current set of objects have no prototype loops and a new object is created. The internal prototype of the created object is either set to <code>null</code> or one of the existing objects during its creation. Since the prototypes of the existing objects cannot be updated, the result is a new set of objects without prototype loops. Even so, all prototype walking loops in the implementation contain a sanity limit for prototype chain length to break out should a loop be somehow created.</p><h3 id="valid-array-index-and-length" tabindex="-1">Valid array index and length <a class="header-anchor" href="#valid-array-index-and-length" aria-label="Permalink to &quot;Valid array index and length&quot;">​</a></h3><p>The E5 specification has very specific definitions for <em>valid array index</em> property names and <em>valid array length</em> property values. Only these trigger the <code>Array</code> specific <code>[[DefineOwnProperty]]</code> behavior in E5 Section 15.4.5.1 steps 3 and 4.</p><p>Note that these requirements do not simply specify a minimum length for supported arrays: they also specify a maximum length for arrays at least with respect to how <code>length</code> behaves. It would be nice to be able to support larger arrays as a build option, but there are probably no realistic cases with arrays larger than 4G elements which would still be relevant for embedding Duktape.</p><h4 id="array-index" tabindex="-1">Array index <a class="header-anchor" href="#array-index" aria-label="Permalink to &quot;Array index&quot;">​</a></h4><p>ECMAScript E5 Section 15.4 states:</p><blockquote><p>A property name <code>P</code> (in the form of a String value) is an <em>array index</em> if and only if <code>ToString(ToUint32(P))</code> is equal to <code>P</code> and <code>ToUint32(P)</code> is not equal to 2^32-1 (0xffffffff).</p></blockquote><p>This implies that the maximum array length is 2*<em>32-1 (0xffffffff) and the maximum array index is one less, 2</em>*32-2 (0xfffffffe). All valid array index and length values can be represented with unsigned 32-bit values. Because 0xffffffff is not a valid array index, it is used internally as a convenient &quot;no array index&quot; marker (<code>DUK_ARRIDX_NONE</code>). For instance, a coercion call can return the marker to indicate that an input was not a valid array index.</p><p>Because ECMAScript object property keys are strings, all array indices encountered in property access expressions are conceptually first coerced to a string form using <code>ToString()</code> and then checked whether they are valid array indexes (this is unlike array <code>length</code> values, which can have any type, see below). (Obviously, this explicit coercion should be avoided whenever possible.)</p><p>The following table lists the possible coercions:</p><table tabindex="0"><thead><tr><th>Property name</th><th><code>ToString</code></th><th>Valid array index?</th></tr></thead><tbody><tr><td><code>undefined</code></td><td><code>&quot;undefined&quot;</code></td><td>no</td></tr><tr><td><code>null</code></td><td><code>&quot;null&quot;</code></td><td>no</td></tr><tr><td><code>false</code></td><td><code>&quot;false&quot;</code></td><td>no</td></tr><tr><td><code>true</code></td><td><code>&quot;true&quot;</code></td><td>no</td></tr><tr><td>a number</td><td>various</td><td>yes, if a whole number in the range [0,2**32-2]</td></tr><tr><td>a string</td><td>same</td><td>yes, if a &quot;canonical&quot; representation for a whole number in the range [0,2**32-2] (<code>&quot;2&quot;</code> is valid, while <code>&quot;0.2e1&quot;</code> is not)</td></tr><tr><td>an object</td><td>various</td><td>depends on coerced string value</td></tr></tbody></table><p>Note that for instance <code>&quot;0.2e1&quot;</code> which numerically represents 2 is not a valid array index: <code>ToString(ToUint32(&quot;0.2e1&quot;))</code> produces <code>&quot;2&quot;</code>, but this is not equal to the original string <code>&quot;0.2e1&quot;</code> (which is required).</p><h4 id="array-length" tabindex="-1">Array length <a class="header-anchor" href="#array-length" aria-label="Permalink to &quot;Array length&quot;">​</a></h4><p>The requirements for a valid <em>array length</em> are a bit different, because array length is assigned as an arbitrary property value and is not therefore automatically coerced to a string first.</p><p>The requirements for a valid array length are implicit in E5 Section 15.4.5.1, steps 3.c to 3.d:</p><ul><li>Step 3.c: Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>.</li><li>Step 3.d: If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, throw a <code>RangeError</code> exception</li></ul><p>The requirements boils down to (for input value <code>X</code>):</p><ul><li><code>ToUint32(X)</code> == <code>ToNumber(X)</code></li></ul><p>The requirements are seemingly similar to the array index requirements, but in fact allow a wider set of values, such as:</p><ul><li><code>true</code> represents array length <code>1</code>, but is not a valid array index</li><li><code>&quot;0.2e1&quot;</code> represents array length <code>2</code>, but is not a valid array index</li><li><code>0xffffffff</code> represents array length 2**32-1, but is not a valid array index</li></ul><p>A potential <code>length</code> value <code>X</code> is treated as follows (see E5 Sections 9.3 and 9.6 for definitions of the coercions <code>ToNumber</code> and <code>ToUint32</code>):</p><table tabindex="0"><thead><tr><th>Property value</th><th><code>ToNumber</code></th><th><code>ToUint32</code></th><th>Valid array length?</th></tr></thead><tbody><tr><td><code>undefined</code></td><td><code>NaN</code></td><td><code>+0</code></td><td>no</td></tr><tr><td><code>null</code></td><td><code>+0</code></td><td><code>+0</code></td><td>yes, length <code>0</code></td></tr><tr><td><code>false</code></td><td><code>+0</code></td><td><code>+0</code></td><td>yes, length <code>0</code></td></tr><tr><td><code>true</code></td><td><code>1</code></td><td><code>1</code></td><td>yes, length <code>1</code></td></tr><tr><td>a number</td><td>various</td><td>various</td><td>yes, if whole number in the range [0,2**32-1]</td></tr><tr><td>a string</td><td>various</td><td>various</td><td>yes, if representation of a whole number in the range [0,2**32-1] (does not need to be canonical, e.g. <code>&quot;2&quot;</code>, <code>&quot;2.0&quot;</code>, <code>&quot;0.2e1&quot;</code> are all acceptable</td></tr><tr><td>an object</td><td>arious</td><td>arious</td><td>depends on coerced values</td></tr></tbody></table><p>As an example of using a non-number as Array length:</p><pre><code>duk&gt; var a = [ &#39;foo&#39;, &#39;bar&#39;, &#39;quux&#39; ]; a
= foo,bar,quux
duk&gt; a.length = true;  // same as a.length = 1
= true
duk&gt; a
= foo
duk&gt; a.length
= 1
</code></pre><h3 id="enumeration-requirements" tabindex="-1">Enumeration requirements <a class="header-anchor" href="#enumeration-requirements" aria-label="Permalink to &quot;Enumeration requirements&quot;">​</a></h3><p>Enumeration requirements are discussed in a separate section below, together with the current implementation for enumerating object keys.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\\newpage</span></span></code></pre></div><h2 id="structure-overview" tabindex="-1">Structure overview <a class="header-anchor" href="#structure-overview" aria-label="Permalink to &quot;Structure overview&quot;">​</a></h2><p>The memory layout of an <code>duk_hobject</code> is illustrated below:</p><pre><code>duk_hobject                       property allocation
(fixed allocation)                (dynamic allocation)

+------------------------+        +---------------------------+
| duk_heaphdr    (flags) |  .----&gt;| entry part keys           |
+========================+  |     | (e_size x duk_hstring *)  |
| duk_u8 *p -------------+--&#39;     +---------------------------+
| duk_u32 e_size         |     .-&gt;| entry part values         |
| duk_u32 e_next         |     :  | (e_size x duk_propvalue)  |
| duk_u32 a_size         |     :  +---------------------------+
| duk_u32 h_size         |     +-&gt;| entry part flags          |
| duk_hobject *prototype |     :  | (e_size x duk_u8)         |
+------------------------+     :  +---------------------------+
: duk_hcompfunc          :     +-&gt;| array part values         |
: duk_hnatfunc           :     :  | (a_size x duk_tval)       |
: duk_hthread            :     :  +---------------------------+
: ...                    :     +-&gt;| hash part indices         |
: (extended structures)  :     :  | (h_size x duk_u32)        |
+------------------------+     :  +---------------------------+
                               :
&#39;p&#39; is NULL if no property     \`- these pointers are computed
allocation exists                 on-the-fly using e_size and
                                  a_size
</code></pre><p>There are multiple memory layouts for the property allocation part, each containing the same parts but in a different order. The different layouts are used to best suit the target platform&#39;s alignment needs. The layout is automatically selected by Duktape during compilation (feature detection).</p><p>The heap header structure <code>duk_heaphdr</code> contains:</p><ul><li>flags with both heap level flags (<code>DUK_HEAPHDR_FLAG_*</code> in <code>duk_heaphdr.h</code>) and object specific flags (<code>DUK_HOBJECT_FLAG_*</code> in <code>duk_hobject.h</code>)</li><li>heap allocated list linkage</li><li>reference counter field</li></ul><p>The object specific part of <code>duk_hobject</code> contains:</p><ul><li>property allocation: A data structure for storing properties</li><li>internal prototype field for fast prototype chain walking; other internal properties are stored in the property allocation</li></ul><p>Some <code>duk_hobject</code> sub-types share the beginning of the <code>duk_hobject</code> struct but have additional fields. These sub-types include: <code>duk_harray</code>, <code>duk_hcompfunc</code>, <code>duk_hnatfunc</code>, <code>duk_hthread</code>, and <code>duk_hbufobj</code>.</p><p>The property allocation part is a single memory allocation containing all the object properties, both external and internal. It is subdivided internally into the following parts:</p><ul><li><em>Entry part</em> stores ordered key-value properties with arbitrary property attributes (flags), and supports accessor properties (getter/setter properties), i.e., full E5 semantics</li><li><em>Array part</em> (optional) stores plain values with default property attributes (writable, enumerable, configurable) for valid array indices (<code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, ..., <code>&quot;4294967294&quot;</code>); does not support accessor properties</li><li><em>Hash part</em> (optional) provides accelerated key lookups for the entry part, mapping a key into an entry part index</li></ul><p>Internal properties are stored in the entry part, and are only distinguished from normal properties in that their keys are invalid UTF-8 sequences which cannot be generated (and thus not accessed) from ECMAScript code. Internal properties should never be enumerable or visible in other ways. See separate discussion of internal properties later in the document.</p><p>The <code>duk_hobject</code> allocation is fixed and its address never changes after initialization. The property allocation part is allocated on demand, and its address may change when the object is resized; this currently always happens because there is no in-place resizing. The resizing process is described in a separate section below. The property allocation part can also be missing, the <code>p</code> pointer is NULL in this case.</p><p>To avoid storing multiple pointers/offsets pointing to the individual sections of the property allocation, the different parts are reached with run-time pointer computations. There are a lot of convenience accessor macros in <code>duk_hobject.h</code> to access the various parts and elements within the parts. <strong>Always</strong> use these macros to manipulate object properties so that changing the layout is contained to a small section of code.</p><p>Notes:</p><ul><li>For a newly allocated object with no properties, there is no property allocation, and the <code>p</code> pointer is <code>NULL</code>. It may also become <code>NULL</code> later if all object properties are deleted and the object is then compacted.</li><li>The array part is assumed to be comprehensive, i.e. if the array part exists, all valid array index keys must reside in the array part. If this invariant would need to be violated, the array part is abandoned and its entries moved into the entry part.</li><li>The array part entries are assumed to have default property attributes (writable, configurable, enumerable). If this invariant would need to be violated, the array part is also abandoned.</li><li>The array part is also abandoned if the array part would become too sparse, i.e. it would take too much memory compared to the number of entries actually present. This behavior is not compliance related.</li><li>A certain key can be present at most once (in either the entry or array part). This invariant must be enforced when adding new keys into the object. Other implementation code can simply assume it.</li><li>The default attributes for new properties depend on how they are inserted: <ul><li>For ordinary assignment, the defaults are defined in the <code>[[Put]]</code> algorithm (E5 Section 8.12.5, step 6): writable, enumerable, configurable. Note that these differ from the official default values defined in E5 Section 8.6.2.</li><li>For <code>[[DefineOwnProperty]]</code> the defaults are defined in E5 Section 8.12.9 step 4, which refers to the official &quot;default attribute values&quot; in E5 Section 8.6.2: non-writable, non-enumerable, non-configurable.</li></ul></li></ul><h2 id="entry-and-hash-part" tabindex="-1">Entry and hash part <a class="header-anchor" href="#entry-and-hash-part" aria-label="Permalink to &quot;Entry and hash part&quot;">​</a></h2><p>The entry part contains ordered key-value pairs, and supports full ECMAScript E5 semantics: property values can be plain <em>data properties</em> or <em>accessor properties</em>, and can have any property attributes, stored in property flags. Internal properties, identified with a special key prefix, can also be stored.</p><p>The hash part is optional, and allows faster lookups into the entry part. It is only used for objects with at least <code>DUK_HOBJECT_E_USE_HASH_LIMIT</code> properties in the entry part.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\\newpage</span></span></code></pre></div><h3 id="layout" tabindex="-1">Layout <a class="header-anchor" href="#layout" aria-label="Permalink to &quot;Layout&quot;">​</a></h3><p>The entry part consists of three separate arrays arranged sequentially: keys, values, flags. An optional hash part may exist to speed up key lookups:</p><pre><code>+---------+                  
| key 0   |   entry part keys
| NULL    |   (duk_hstring *)
.-&gt;| key 2   |
|  | / / / / |
|  | / / / / |
|  +---------+
|  | value 0 |   entry part values
|  | / / / / |   (duk_propvalue)
+-&gt;| value 2 |
|  | / / / / |
|  | / / / / |
|  +---------+
|  | flags 0 |   entry part flags
|  | / / / / |   (duk_u8)
+-&gt;| flags 2 |
|  | / / / / |
|  | / / / / |   / / / /   Denotes uninitialized data
|  +---------+             which is not reachable from
|  :         :             a GC perspective
|  : array   :
|  : part    :
|  :         :
|  +---------+
|  | UNUSED  |   hash part
\`--| 2       |   (duk_u32)
| DELETED |
| UNUSED  |   UNUSED  = DUK_HOBJECT_HASHIDX_UNUSED
| 0       |           = 0xffffffffU
| UNUSED  |
| UNUSED  |   DELETED = DUK_HOBJECT_HASHIDX_DELETED
| UNUSED  |           = 0xfffffffeU
+---------+
              DELETED entries don&#39;t terminate hash
              probe sequences, UNUSED entries do.

Here, e_size = 5, e_next = 3, h_size = 8.
</code></pre><p>Each array in the entry part contains <code>e_size</code> allocated entries. The entries at indices [0,<code>e_next</code>[ are currently in use, and any entries above that are uninitialized (garbage) data, and not reachable from a GC perspective.</p><p>New keys are always appended to the current <code>e_next</code> position (with the entry part resized if it is already full). Existing entries are deleted by marking a key as <code>NULL</code>; they are not reused for new properties to avoid disrupting the key enumeration order (which should match insertion order). NULL entries are removed (compacted) whenever the property allocation is resized. If a key entry is <code>NULL</code>, the corresponding value and flag fields MUST NOT be interpreted, and are not considered reachable from a GC perspective. Thus, the property value must be decref&#39;d when the key is set to NULL. If a key entry is non-<code>NULL</code>, it is considered reachable and must be incref&#39;d on insertion.</p><p>Flags are represented by an <code>duk_u8</code> field, with flags defined in <code>duk_hobject.h</code>. The current flags are:</p><ul><li><code>DUK_PROPDESC_FLAG_WRITABLE</code></li><li><code>DUK_PROPDESC_FLAG_ENUMERABLE</code></li><li><code>DUK_PROPDESC_FLAG_CONFIGURABLE</code></li><li><code>DUK_PROPDESC_FLAG_ACCESSOR</code></li></ul><p>The value field is a union of (1) a plain value, and (2) an accessor value which contains <code>get</code> and <code>set</code> function pointers. The interpretation of the union depends on the <code>DUK_PROPDESC_FLAG_ACCESSOR</code>; if set, the value is treated as the accessor part of the union, otherwise it is treated as the value part of the union. This interpretation must be done everywhere where the value is accessed, otherwise garbage values will be read. In particular, the reference count and garbage collection code must always interpret the union correctly based on the current entry flags.</p><p>The hash part (if it exists) maps an <code>duk_hstring</code> key <code>K</code> to an index <code>I</code> of the current entries part, or indicates that the key does not exist in the object. The hash index structure has no bearing on garbage collection; in particular, the index references from the hash part to the entry part are not considered counted references.</p><p>If the hash part exists, it is always kept up-to-date with the entry part so that both structures always contain the same keys. Deleted entries in the hash data structure are explicitly marked DELETED. Such entries don&#39;t terminate hash probe sequences but act otherwise as UNUSED entries; see more detailed discussion below. DELETED entries are eliminated (converted to UNUSED) when the property allocation is resized, improving hash part performance.</p><p>Notes:</p><ul><li>This layout of three separate arrays has been chosen so that a linear key scan is efficient, e.g. works nicely with cache lines and prefetches, which is important because &quot;small&quot; objects don&#39;t have a hash part at all. Linear scan is more space efficient and often also faster than a hash lookup, which does one or more random accesses to the hash part when going through the probe sequence.</li><li>Objects in dynamic languages often don&#39;t guarantee a key enumeration order, which allows objects to be implemented with easy and efficient &quot;pure&quot; hash tables. Although ECMAScript E5 does not require a particular key ordering for enumeration, a practical implementation must provide some ordering guarantees to be compatible with existing code base. Such guarantees include enumerating keys in their insertion order; see the section on enumeration for details. This has a big impact on the viable data structure alternatives; the current entry and hash part model is a relatively simple approach to satisfy the practical requirements.</li></ul><h3 id="hash-part-details" tabindex="-1">Hash part details <a class="header-anchor" href="#hash-part-details" aria-label="Permalink to &quot;Hash part details&quot;">​</a></h3><p>The hash part maps a key <code>K</code> to an index <code>I</code> of the entry part or indicates that <code>K</code> does not exist. The hash part uses a <a href="http://en.wikipedia.org/wiki/Hash_table#Open_addressing" target="_blank" rel="noreferrer">closed hash table</a>, i.e. the hash table has a fixed size and a certain key has multiple possible locations in a <em>probe sequence</em>.</p><p>::: note ::: title Note :::</p><p>The current hash algorithm does not perform especially well, and it is future work to make it work better especially with high load factors. :::</p><p>The hash part is an array of <code>h_size</code> <code>duk_u32</code> values. Each value is either an index to the entry part, or one of two markers:</p><ul><li><code>UNUSED</code>: entry is currently unused</li><li><code>DELETED</code>: entry has been deleted</li></ul><p>Hash table size (<code>h_size</code>) is selected relative to the maximum number of inserted elements <code>N</code> (equal to <code>e_size</code> in practice) in two steps:</p><ol><li>Find lowest N so that <code>2 ** N &gt;= e_size</code>.</li><li>Use <code>2 ** (N + 1)</code> as hash size. This guarantees load factor is lower than 0.5 after resize.</li></ol><p>The probe sequence for a certain key is guaranteed to walk through every hash table entry. Currently the probe sequence is simply:</p><ul><li><code>(X + i) % h_size</code> where i=0,1,...,h_size-1.</li></ul><p>This isn&#39;t ideal for avoiding clustering (double hashing would be better) but is cache friendly and works well enough with low load factors.</p><p>When looking up an element from the hash table, we walk through the probe sequence looking at the hash table entries. If a UNUSED entry is found, the probe sequence is terminated, and we determine that the entry cannot be in the hash (and thus, not in the entry part). If a DELETED entry is found, we continue with the probe sequence. This is necessary to handle deletions correctly.</p><p>When inserting an element to the hash table, we must first ensure it does not already exist. The probe sequence must be verified up to the first UNUSED entry (but not beyond). The element is then inserted to the first UNUSED <em>or</em> DELETED entry. DELETED entries can thus be reused, but they can never be marked UNUSED, otherwise probe sequences would be &quot;broken&quot;.</p><p>When an element is deleted, it is first located by following the probe sequence, and if found, is then replaced with a DELETED marker.</p><p>If the hash part is full, the probe sequence eventually comes back to the initial entry and is thus in an infinite loop. An explicit loop check would be an unnecessary cost: it suffices to ensure there is at least one UNUSED entry in the hash part. As the probe sequence is guaranteed to cover every hash entry, it will eventually hit the UNUSED entry and terminate.</p><p>DELETED entries don&#39;t terminate hash probe sequences. If they did, existing hash chains could be broken as a side effect of deletions. Since the hash must contain at least one UNUSED entry, DELETED entries must be &quot;purged&quot; from time to time: if all entries were either occupied or marked DELETED, probe sequences would never terminate. Currently DELETED entries are only removed during property allocation resizing, which always rehashes all entries, purging any DELETED entries as a side effect. The handling of key insertion and deletion in the entry part actually guarantees that a rehashing occurs before the hash part fills up with DELETED entries as follows.</p><p>Because all new entries are appended to the existing entry part key array (deleted entry part keys are marked <code>NULL</code> but not reused until a resize happens), the hash part contains exactly <code>e_next</code> used and DELETED entries combined, and exactly <code>h_size - e_next</code> UNUSED entries. As long as the hash part is larger than the entry part (<code>h_size &gt; e_size</code>) the hash is thus guaranteed to contain at least one UNUSED entry. When an insertion is attempted to a full entry part (<code>e_next = e_size</code>), a property allocation resize is triggered which also resizes and rehashes the hash part, purging any <code>DELETED</code> entries.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\\newpage</span></span></code></pre></div><h2 id="array-part" tabindex="-1">Array part <a class="header-anchor" href="#array-part" aria-label="Permalink to &quot;Array part&quot;">​</a></h2><h3 id="layout-1" tabindex="-1">Layout <a class="header-anchor" href="#layout-1" aria-label="Permalink to &quot;Layout&quot;">​</a></h3><p>The array part simply contains a sequence of tagged values:</p><pre><code>values
(duk_tval)

+---------+
| value 0 |  Represents the array:
| UNUSED  |    { &quot;0&quot;: (value 0), &quot;2&quot;: (value 2) }
| value 2 |
| UNUSED  |  UNUSED = duk_tval &#39;unused&#39; marker value
| UNUSED  |           (DUK_TVAL_IS_UNUSED(tv))
+---------+

Here, a_size = 5.
</code></pre><p>The array part stores all properties whose string key is a <em>valid array index</em>, a canonical string representation of a whole number in the range [0,0xfffffffe] (discussed in more detail above). The array part is <em>comprehensive</em>, which means that if an object has an array part, any string key which is a valid array index <em>must</em> reside in the array part (it can never be in the entry part). (Because 0xffffffff is not a valid array index, it is used internally as a convenient &quot;no array index&quot; marker, <code>DUK_ARRIDX_NONE</code>.)</p><p>The array part does not store any property attribute flags: all entries are implicity assumed to be data properties with the default <code>[[Put]]</code> property attributes: writable, enumerable, configurable. This assumption is true for almost all real world code. If a property insertion or modification were to violate this assumption, the entire array part needs to be abandoned and moved to the entry part to maintain E5 semantics.</p><p>All array entries are always reachable from a GC perspective, up to the allocated size, <code>a_size</code>. Unused values are marked with the special &quot;unused&quot; value, set using the <code>DUK_TVAL_SET_UNUSED</code> macro. Any other entries, including &quot;undefined&quot; values, set using the <code>DUK_TVAL_SET_UNDEFINED</code> macro, are considered to be in use, and their corresponding key is considered to exist in the object, and they are thus visible to enumeration. In the illustration above, values at indices &quot;0&quot; and &quot;2&quot; are considered used, so an attempt to enumerate the array part would result in <code>[&quot;0&quot;, &quot;2&quot;]</code>, also e.g. <code>2 in obj</code> would be true while <code>3 in obj</code> would be false.</p><p>Notes:</p><ul><li>The array part is an optimized structure for reading and writing array indexed properties efficiently. It can be used for <em>any</em> object, not just the ECMAScript <code>Array</code> object, and ECMAScript <code>Array</code> exotic behaviors are unrelated to the array part&#39;s existence.</li><li>A non-<code>Array</code> object with an array part does not get the <code>Array</code> related exotic behaviors (like automatic interaction between array indexed elements and the <code>length</code> property).</li><li>An <code>Array</code> object may be created without an array part, or may have its array part abandoned. The <code>Array</code> exotic behaviors must keep on working even if the <code>Array</code> object has no array part.</li><li>The <code>Array</code> <code>length</code> property is stored as an ordinary property in the entries part, and has no relation with array part size (<code>a_size</code>).</li></ul><h3 id="abandoning-the-array-part" tabindex="-1">Abandoning the array part <a class="header-anchor" href="#abandoning-the-array-part" aria-label="Permalink to &quot;Abandoning the array part&quot;">​</a></h3><p>The array entries are assumed to be data properties with default attributes (writable, configurable, enumerable). This has the following implications:</p><ul><li><p>When a new property with an array index outside the currently allocated array part is being added (e.g. as part of a property write), we must either:</p><ol><li>extend the array allocation to cover the new entry; or</li><li>abandon the entire array part, moving all array part entries to the entry part.</li></ol><p>The first option may not be viable if the array were to become very sparse (e.g. when executing: <code>var a = []; a[1000000000] = 1</code>).</p></li><li><p>When a property in the array part would become an accessor property (getter/setter) or would need to have incompatible attributes, the entire array part must be abandoned.</p><p>Note that the property cannot be stored in the entry part while keeping the array part, because the array part is assumed to be comprehensive.</p></li></ul><p>When an array part is abandoned, its entries are all moved into the entries part as ordinary key-value properties with string keys. If an array part is abandoned for a certain object it is currently never reinstated. The current implementation performs array abandonment only as part of a property allocation resize; the need to abandon the array thus triggers a resize with the side effect of doing key compaction, rehashing, etc.</p><p>The enumeration ordering of keys is preserved for existing array index keys by adding them first to the resized entry part, before non-array-index keys. However, key ordering behavior for new array indexed entries after the resize (which abandons the array part) differs from an object with an array part: array index keys are appended to the entry part as ordinary keys. This implementation specific behavior is illustrated below:</p><pre><code>// two example arrays
var a = [1,2,3]; a.foo = &quot;bar&quot;;
var b = [1,2,3]; b.foo = &quot;bar&quot;;

// force &#39;a&#39; to abandon array part
a[1000000] = 4;  // array part abandoned
a.length = 3;    // array part not reinstated

// arrays &#39;a&#39; and &#39;b&#39; have the same enumeration
// ordering at this point: [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot; ].

a[4] = 5;
a[3] = 4;
b[4] = 5;
b[3] = 4;

// enumeration ordering differs here:
print(Object.keys(a));   // -&gt; 0,1,2,foo,4,3
print(Object.keys(b));   // -&gt; 0,1,2,3,4,foo
</code></pre><p>Note that ECMAScript implementation behavior differs greatly when it comes to &quot;sparse arrays&quot;. For instance, the above example has varying results with existing ECMAScript implementations:</p><pre><code>// Rhino (Rhino 1.7 release 3 2012 02 13)
// (behavior matches example above)
[...]
0,1,2,foo,4,3
0,1,2,3,4,foo

// smjs (JavaScript-C 1.8.5+ 2011-04-16)
// (enumerates based purely on insertion order
// for both objects)
[...]
0,1,2,foo,4,3
0,1,2,foo,4,3

// V8 (nodejs v0.4.12)
// (enumerates array indices before other keys
// for both objects)
print = console.log;
[...]
[ &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;foo&#39; ]
[ &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;foo&#39; ]
</code></pre><h3 id="fast-array-access" tabindex="-1">Fast array access <a class="header-anchor" href="#fast-array-access" aria-label="Permalink to &quot;Fast array access&quot;">​</a></h3><p>The reason why a separate array part exists is to:</p><ul><li>Store normal array structures compactly: normal arrays are dense and have default properties</li><li>Provide relatively fast access to array elements: avoid entry or hash part lookup</li><li>Avoid string interning of array index keys for numeric indices</li></ul><p>ECMAScript array indices are always strings, so conceptually arrays map string indices of the form &quot;0&quot;, &quot;1&quot;, etc to arbitrary values. Non-string keys for property accesses are coerced to strings at run time. For instance:</p><pre><code>var a = [1,2];
print(a[0]);    // 0 coerced to &quot;0&quot; before access
print(a[&quot;0&quot;]);  // equivalent access

var i = 1;
print(a[i]);    // equivalent to a[&quot;1&quot;]
</code></pre><p>If the property access key happens to be a number which is also a valid array index (whole number in the range [0,2**32-1[) and the target array happens to have an array part, we can avoid the string interning and look up the entry directly. The same applies to assignments to array index properties.</p><p>This is not trivial to implement in practice because of the prototype chain, the details of property access algorithms etc. Currently the &quot;fast path&quot; behavior applies to a very narrow set of circumstances. See the following functions in <code>duk_hobject_props.c</code>:</p><ul><li><code>duk_hobject_get_value_u32()</code></li><li><code>duk_hobject_get_value_tval()</code></li><li><code>duk_hobject_has_property_u32()</code></li><li><code>duk_hobject_has_property_tval()</code></li></ul><p>There is currently no fast path for array writes, which means the key is temporarily interned for the duration of the array write. The array write fast path is a bit tricky: if the element does not already exist, a property higher up in the prototype chain may block or capture the write, and currently the prototype chain lookup is only possible with a string key. See future work.</p><h2 id="resizing-the-property-allocation" tabindex="-1">Resizing the property allocation <a class="header-anchor" href="#resizing-the-property-allocation" aria-label="Permalink to &quot;Resizing the property allocation&quot;">​</a></h2><p>The property allocation resizing algorithm handles: growing and shrinking of the entry, array, and hash parts; abandoning the array part, key compaction (elimination of <code>NULL</code> keys); and rehashing (elimination of <code>DELETED</code> entries). Only one resizing algorithm is used; all parts of the property allocation are always processed during resizing. Multiple resizing algorithms would be useful (e.g. to just resize one part, perhaps in-place), but would increase code size. The current resize algorithm is <code>realloc_props()</code> in <code>duk_hobject_props.c</code>.</p><p>The property allocation is currently resized e.g. when:</p><ul><li>The entry part runs out during insertion of a new property.</li><li>The array part needs to be extended during insertion of a new property.</li><li>The array part needs to be abandoned due to: <ul><li>a property insert which would result in a too sparse array part;</li><li>a property insert incompatible with the array part assumptions; or</li><li>a property modification incompatible with the array part assumptions.</li></ul></li><li>The object is compacted, i.e. its active entry and array part properies are counted, and an optimal (small) new size is allocated.</li></ul><p>The resizing algorithm:</p><ul><li>Allocates a new memory area for properties (in-place resizing is not supported). This may trigger a garbage colleciton, and may fail.</li><li>If array abandoning is requested, existing array properties are first moved into the beginning of the new entry part to keep the enumeration ordering identical to that before abandonding (array indices are normally enumerated before other entry keys). The array abandoning process is a bit tricky because it requires string interning which may trigger garbage collection and may also fail. Any temporary values must thus be reachable and correctly referenced counted for every intern call.</li><li>Existing entry part properties are moved into the new entry part. Any <code>NULL</code> keys are skipped, so that the entry part keys are &quot;compacted&quot;.</li><li>If the new allocation has a hash part, the new entry part keys are hashed into the new hash part. Note that an existing hash part (of the current allocation) is irrelevant and is ignored here; in any case, the new hash part contains no <code>DELETED</code> entries.</li></ul><p>If the array part is not abandoned, reference counts for the object as a whole remain constant: the reachable keys and values are exactly the same. If the array part is abandoned, the newly interned array index string keys (e.g. <code>&quot;0&quot;</code>) will be newly reachable and need to be incref&#39;d.</p><p>Some complications:</p><ul><li><p>The tricky reachability issues related to array abandoning are handled by using the current thread&#39;s value stack as a place to store temporaries; the value stack has an existing process for cleanup if an error occurs. This is not the whole story, though; see code for details.</p></li><li><p>The allocation calls required during resizing (for the new memory area, string interning, and value stack resizing) may cause a garbage collection. The garbage collection may attempt to resize any object as part of an &quot;emergency GC&quot; compaction. This needs to be prevented for the current object (or in general, for any object being concurrently resized).</p><p>The current solution is to prevent finalizers from running (which prevents attempts to add, remove, or modify properties in the middle of a resize) and to prevent object compaction (so that a certain object won&#39;t be resized when it is already being resized).</p></li></ul><h2 id="enumeration" tabindex="-1">Enumeration <a class="header-anchor" href="#enumeration" aria-label="Permalink to &quot;Enumeration&quot;">​</a></h2><p>Enumeration poses a lot of problems for implementing the ECMAScript object/array semantics efficiently.</p><p>Below, the relevant parts of the specification are first discussed (and quoted for easy reference), followed by some useful additional requirements and features. Some implementation pitfalls are then discussed. Finally, the current enumeration mechanism is discussed in some detail.</p><p>The current implementation can be found in <code>duk_hobject_enum.c</code>.</p><h3 id="ecmascript-specification-requirements" tabindex="-1">ECMAScript specification requirements <a class="header-anchor" href="#ecmascript-specification-requirements" aria-label="Permalink to &quot;ECMAScript specification requirements&quot;">​</a></h3><p>E5 Section 12.6.4: &quot;The for-in statement&quot; contains the main requirements for enumeration in the E5 specification:</p><ul><li>The mechanics and order of enumerating the properties [...] is not specified.</li><li>Properties of the object being enumerated may be deleted during enumeration. If a property that has not yet been visited during enumeration is deleted, then it will not be visited.</li><li>If new properties are added to the object being enumerated during enumeration, the newly added properties are not guaranteed to be visited in the active enumeration.</li><li>Enumerating the properties of an object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not enumerated if it is &quot;shadowed&quot; because some previous object in the prototype chain has a property with the same name.</li></ul><p>E5 Section 15.2.3.7: &quot;Object.defineProperties ( O, Properties )&quot; requires that when multiple properties are defined with <code>Object.defineProperties()</code>, the order should be kept:</p><ul><li>If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used to order the list elements in step 3 of this algorithm.</li></ul><p>E5 Section 15.2.3.14: &quot;Object.keys ( O )&quot; requires that the &quot;for-in&quot; enumeration order should also be used for <code>Object.keys()</code>:</p><ul><li>If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used in step 5 of this algorithm.</li></ul><h3 id="practical-enumeration-requirements" tabindex="-1">Practical enumeration requirements <a class="header-anchor" href="#practical-enumeration-requirements" aria-label="Permalink to &quot;Practical enumeration requirements&quot;">​</a></h3><p>The E5 requirements for enumeration are rather loose; for instance, there is no requirement that object keys are enumerated in their insertion order or even that array indexes are enumerated in an ascending order. However, real world code sometimes makes such assumptions.</p><p>For instance, it is a common idiom to assume that the following works:</p><pre><code>var a = [ &quot;foo&quot;, &quot;bar&quot;, &quot;quux&quot; ];
for (var i in a) {
  print(i, a[i]);
}
</code></pre><p>Many programmers expect this to print:</p><pre><code>0 foo
1 bar
2 quux
</code></pre><p>where it might just as well, while being fully E5 compliant, print:</p><pre><code>2 quux
0 foo
1 bar
</code></pre><p>Similarly, much existing code assumes that properties are enumerated in the order they were inserted. See, for instance:</p><ul><li><p><a href="http://code.google.com/p/chromium/issues/detail?id=2605" target="_blank" rel="noreferrer">http://code.google.com/p/chromium/issues/detail?id=2605</a></p></li><li><p><a href="http://ejohn.org/blog/javascript-in-chrome/" target="_blank" rel="noreferrer">http://ejohn.org/blog/javascript-in-chrome/</a></p><p>&quot;However, specification is quite different from implementation. All modern implementations of ECMAScript iterate through object properties in the order in which they were defined. Because of this the Chrome team has deemed this to be a bug and will be fixing it.&quot;</p></li><li><p><code>hobject-enumeration.rst</code> for practical testing results with actual implementations.</p></li></ul><p>We impose the following additional requirements for compatibility:</p><ul><li>Non-array-index keys should be enumerated in their insertion order.</li><li>The keys for <code>Array</code> elements should be enumerated in an ascending order, and before non-array-index keys. <ul><li>This is currently provided for all objects with an array part. ECMAScript <code>Array</code> instances should thus always have an array part (at least when they are created).</li><li>If an object has an array part which is abandoned, e.g. because the array becomes too sparse, the enumeration ordering reverts to enumerating entries in insertion order (regardless of whether the property is a valid array index or not).</li></ul></li><li>All keys of a certain object should be enumerated (including both array index and non-array-index keys) before proceeding to the prototype. Keys already enumerated must not be repeated during enumeration even if they occur again in the prototype chain.</li><li>If an entry is deleted during enumeration before it has appeared in the enumeration sequence, it must not turn up later in the enumeration.</li><li>A certain key must never appear twice in the enumeration sequence, despite any mutation.</li><li>A key which was present during the &quot;initialization&quot; of the enumeration (before the first key was enumerated) must not be omitted from the enumeration sequence, if they are not deleted during enumeration (before they have appeared in the enumeration sequence).</li></ul><p>Note the following <em>non-requirements</em>:</p><ul><li>New entries added during enumeration are not required to show up during the enumeration in progress. <ul><li>The current implementation will <em>never</em> enumerate such keys. This is not desirable as such, but is a side effect of the (simplistic) implementation strategy.</li><li>The same behavior seems to apply to smjs, Rhino, and V8 at the time of writing.</li></ul></li></ul><h3 id="implementation-issues" tabindex="-1">Implementation issues <a class="header-anchor" href="#implementation-issues" aria-label="Permalink to &quot;Implementation issues&quot;">​</a></h3><p>It is tempting to implement enumeration with sort of enumerator state which maintains some iteration pointers or indices to the target object and steps through object properties and the (immutable) prototype chain on request. However, this approach has many practical difficulties:</p><ul><li>Object mutation may cause the internal structure of the target object (or any object in its prototype chain) to change. <ul><li>This poses a problem for any approach based on maintaining an index to the array/entry part, as an index may be invalidated by internal data structure maintenance such as compaction of keys.</li><li>This problem can be avoided if the object is &quot;frozen&quot; for enumeration, but this requires awkward book-keeping, which must work even if errors are thrown, threads yield (and perhaps never resume, or are garbage collected) etc.</li></ul></li><li>Any keys may be deleted during enumeration. <ul><li>This poses a problem for any approach based on maintaining a key based state, e.g. &quot;current key&quot;. The key in question may be deleted; how can one then find the next key in the sequence?</li></ul></li></ul><h3 id="current-enumeration-mechanism" tabindex="-1">Current enumeration mechanism <a class="header-anchor" href="#current-enumeration-mechanism" aria-label="Permalink to &quot;Current enumeration mechanism&quot;">​</a></h3><p>The current enumeration approach is based on creating an internal enumeration object (enumerator) when enumeration is initialized, before any keys are needed. The entire list of enumerated keys is generated during initialization and stored in the enumerator. This avoids any issues with mutation, because no user code runs while the enumerator is being initialized. This step is memory intensive; in particular, all enumerated array index keys are interned.</p><p>The enumerator is then used to generate a sequence of keys on demand. When a new key is requested, the enumerator advances to the next key in its internal sequence. The key is then checked to ensure it has not been deleted during enumeration; if it has, we skip and try the next key in the sequence.</p><p>Note that the key may be deleted and still found in an ancestor (and should still be enumerated):</p><pre><code>function F() {};
F.prototype = { &quot;foo&quot;: &quot;inherited&quot; };

var a = new F();
a.bar = &quot;skip&quot;;
a.foo = &quot;own&quot;;

// enumeration order: &quot;bar&quot;, &quot;foo&quot;
for (var i in a) {
  delete a.foo;  // only affects &#39;a&#39;, not F.prototype
  print(i, a[i]);
}
</code></pre><p>This is expected to print:</p><pre><code>bar skip
foo inherited
</code></pre><p>However, behavior seems to differ across implementations: V8 and Smjs work as above, while Rhino does not enumerate <code>&quot;foo&quot;</code>. Rhino <em>will</em> enumerate <code>foo</code> if the for-loop is executed twice. There are other corner cases in enumeration too, see test cases.</p><p>Suppose the enumeration target is:</p><pre><code>x = [ &quot;foo&quot;, &quot;bar&quot;, &quot;quux&quot; ];
x.foo = &quot;bar&quot;;
</code></pre><p>After initialization, the internal enumerator object would contain the following:</p><pre><code>e = {
  // internal control properties first
  &quot;_Target&quot;: (target object),
  &quot;_Next&quot;: (numeric index),

  // followed by enumeration keys
  // (as properties, not array entries)
  &quot;0&quot;: true,
  &quot;1&quot;: true,
  &quot;2&quot;: true,
  &quot;foo&quot;: true
}
</code></pre><p>The enumerator object takes advantage of two features:</p><ol><li>Keys inserted into an object maintain their order in the entry part (even during resizes). Thus, we can insert keys into the enumerator and trust that their order is maintained. The entry part is always gap-free, i.e. there are no NULL keys in the sequence.</li><li>Inserting enumerated keys as properties instead of array entries allows duplicate keys to be handled correctly. Duplicate keys may occur when the prototype chain is walked. The first occurrence is recorded in its correct position, and any later occurrences are ignored.</li></ol><p>The <code>_Next</code> internal property is a numeric index which indicates where to find the next potential key. It is an index to the <em>entry part</em> of the enumerator, and it&#39;s initialized to the value 2 because positions 0 and 1 are taken by <code>_Target</code> and <code>_Next</code> properties, respectively. Entry index 2 in the example above is the &quot;0&quot; key. This needs to be managed carefully as the indexing model depends on the entry part having a very specific, unchanged form.</p><p>Note that the enumerator is not mutated after its creation, so this entry part index approach is reliable. It is reliable even if the enumerator is resized, as long as properties are not deleted; that would cause problems in a resize, when the entry part was compacted.</p><h3 id="notes" tabindex="-1">Notes <a class="header-anchor" href="#notes" aria-label="Permalink to &quot;Notes&quot;">​</a></h3><p>The current implementation has some nice qualities:</p><ul><li>It is very simple and robust, and avoids any issues with mutation (except that keys added during mutation are never enumerated, which is not nice but a common feature in other implementations, too).</li><li>It has small code space.</li><li>It has minimal impact on anything else, e.g. it requires no co-operation from the object, such as avoiding key compaction until enumeration is over.</li></ul><p>However, it has many drawbacks:</p><ul><li>It has a relatively large memory footprint for the enumerator. Because the keys are stored as key-value properties (not as array entries), each enumerated key takes about 13 bytes on a typical 32-bit architecture (4 bytes for key, 8 bytes for value, 1 byte for flags). <ul><li>This footprint could be reduced somewhat by using the property-based approach to generate the enumeration sequence (eliminating duplicate keys etc), and then converting that to an array; array entries typically take 8 bytes. But this would temporarily increase memory footprint even more.</li></ul></li><li>Numeric key indices of an array part or the virtual numeric key indices of a <code>String</code> object are interned and are reachable simultaneously during enumeration.</li><li>Execution of program code stops while the enumerator is initially created. This probably has little impact in most cases, but it might be an issue if a very large object is being enumerated (consider for instance enumerating a very large array).</li></ul><p>As a concrete illustration of some of the drawbacks, consider the following:</p><pre><code>var a = [... large array of 1 million elements ...];
for (var i in a) {
  print(i, a[i]);
}
</code></pre><p>The enumerator created in this example would contain a million interned keys for &quot;0&quot;, &quot;1&quot;, and so on. <em>All</em> of these keys would remain reachable for the entire duration of the enumeration. The following code would perform <em>much</em> better (and would be more portable, as it makes no assumptions on enumeration order):</p><pre><code>var a = [... large array of 1 million elements ...];
var n = a.length;
for (var i = 0; i &lt; n; i++) {
  print(i, a[i]);
}
</code></pre><p>This problem could be alleviated a bit by deleting any already-enumerated keys from the enumerator as enumeration proceeds. Care would then have to be taken to avoid any possibility of a resize of the object to avoid mixing up the key order (due to key compaction). This might not be easy to arrange, if GC is allowed to opportunistically compact objects (at least in &quot;emergency GC&quot; mode). A much easier approach would be to replace enumeration entry keys with a fixed string (like the empty string) instead of deleting them. This would still free the string resources but keep the object property key list intact. However, it would lead to duplicate keys in the entry part, which needs careful consideration to work correctly.</p><h2 id="internal-properties" tabindex="-1">Internal properties <a class="header-anchor" href="#internal-properties" aria-label="Permalink to &quot;Internal properties&quot;">​</a></h2><p>Duktape implements E5 internal properties in differing ways, depending on the property in question:</p><ul><li>concretely stored internal properties</li><li><code>duk_hobject</code> header flags</li><li><code>duk_hobject</code> structure fields (only internal prototype currently)</li><li>implicit behaviors in specification algorithms based on e.g. object flags, type, or class</li></ul><p>The current approach for storing internal properties which are not visible to ordinary program code and never overlap with externally visible named properties is simple: since all standard keys encode into valid UTF-8 sequences (valid CESU-8 sequences to be exact) in memory, internal properties are prefixed with an invalid UTF-8 sequence which standard ECMAScript code cannot generate and thus cannot access. The current prefix is a single <code>0x82</code> byte. The prefix is denoted with an underscore in this document; e.g. <code>_Map</code> would be represented as the byte sequence: <code>0x82</code> <code>&#39;M&#39;</code> <code>&#39;a&#39;</code> <code>&#39;p&#39;</code> in memory. User C code can also use internal properties for its own purposes, as long as the property names don&#39;t conflict with Duktape&#39;s internal properties.</p><p>To avoid complications:</p><ul><li>Internal properties MUST NOT be enumerable <ul><li>Duktape prevents enumeration of internal properties regardless of their <code>[[Enumerable]]</code> attribute. This makes it easier for user code to read/write internal properties as ordinary put/get primitives can be used.</li></ul></li><li>Internal properties MUST NOT be visible in any other way either, e.g. through <code>Object.getOwnPropertyNames()</code> which outputs also non-enumerable properties <ul><li>Duktape prevents this in each relevant built-in function.</li></ul></li><li>User ECMAScript code should not be given references to internal strings, i.e. strings other than valid UTF-8/CESU-8 encodings</li><li>Untrusted ECMAScript code should have no access to buffer values or buffer constructors because it&#39;s easy to create an internal property name with buffers</li></ul><p>User C code can access internal properties; C code has full memory access anyway so it must be trustworthy in any case. User code should never access Duktape&#39;s internal properties as the internal properties may change arbitrarily between versions.</p><p>Internal property names use a bit of shorthand and often the same internal key is reused in many contexts. This is simply to save a bit of memory with minimal impact on readability.</p><p>The following table summarizes the internal properties specified in E5, and how they are mapped to the <code>duk_hobject</code> implementation. The double brackets are omitted from the specification property names (e.g. <code>[[Class]]</code> is listed as &quot;Class&quot;).</p><table tabindex="0"><thead><tr><th>Property</th><th>Implementation</th></tr></thead><tbody><tr><td>Prototype</td><td><code>duk_hobject</code> struct <code>prototype</code> field.</td></tr><tr><td>Class</td><td><code>duk_hobject</code> flags field, encoded as a number.</td></tr><tr><td>Extensible</td><td><code>duk_hobject</code> flag <code>DUK_HOBJECT_FLAG_EXTENSIBLE</code>.</td></tr><tr><td>Get</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>GetOwnProperty</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>GetProperty</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>Put</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>CanPut</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>HasProperty</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>Delete</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>DefaultValue</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>DefineOwnProperty</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>PrimitiveValue</td><td>Internal property <code>_Value</code>.</td></tr><tr><td>Construct</td><td>Not stored, implicit in algorithms. <code>duk_hobject</code> flag <code>DUK_HOBJECT_FLAG_CONSTRUCTABLE</code> indicates whether the object is a constructor, i.e. conceptually implements the internal <code>[[Construct]]</code> function. Note that all callable objects are not constructable.</td></tr><tr><td>Call</td><td>Not stored, implicit in algorithms. <code>duk_hobject</code> macro <code>DUK_HOBJECT_IS_CALLABLE</code> determines whether the object is callable, i.e. conceptually implements the internal <code>[[Call]]</code> function. The check is made using (other) object type flags, there is no dedicated &quot;callable&quot; flag.</td></tr><tr><td>HasInstance</td><td>Not stored, implicit in algorithms.</td></tr><tr><td>Scope</td><td>Internal <code>duk_hcompfunc</code> fields <code>lex_env</code> and <code>var_env</code>. Unlike E5, global and eval code are also compiled into functions, hence two scope fields are needed.)</td></tr><tr><td>FormalParameters</td><td>Internal property <code>_Formals</code>.</td></tr><tr><td>Code</td><td>An ECMAScript function (<code>duk_hcompfunc</code>) has a pointer to compiled bytecode and associated data (such as constants), see <code>duk_hcompfunc.h</code>. A C function (<code>duk_hnatfunc</code>) has a pointer to a a C function and some related control data, see <code>duk_hnatfunc.h</code>. Lightfunc C function pointer is embedded in the tagged <code>duk_tval</code> directly.</td></tr><tr><td>TargetFunction</td><td><code>duk_hobject</code> flag <code>DUK_HOBJECT_FLAG_BOUND</code> is set, and the internal property <code>_Target</code> is set to the target function.</td></tr><tr><td>BoundThis</td><td><code>duk_hobject</code> flag <code>DUK_HOBJECT_FLAG_BOUND</code> is set and the internal property <code>_This</code> is set to the <code>this</code> binding.</td></tr><tr><td>BoundArguments</td><td><code>duk_hobject</code> flag <code>DUK_HOBJECT_FLAG_BOUND</code> is set and the internal property <code>_Args</code> is set to a list of bound arguments.</td></tr><tr><td>Match</td><td>Not stored, implicit in algorithms. Object type (class number is DUK_HOBJECT_CLASS_REGEXP) determines whether <code>[[Match]]</code> is conceptually supported. The compiled regexp and its flags are stored as the <code>_Bytecode</code> internal property, whose value is an internal string.</td></tr><tr><td>ParameterMap</td><td>Internal property <code>_Map</code></td></tr></tbody></table><h2 id="exotic-behavior-and-virtual-properties" tabindex="-1">Exotic behavior and virtual properties <a class="header-anchor" href="#exotic-behavior-and-virtual-properties" aria-label="Permalink to &quot;Exotic behavior and virtual properties&quot;">​</a></h2><h3 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h3><p>The E5 specification defines default property access algorithms like <code>[[GetProperty]]</code> and <code>[[DefineOwnProperty]]</code> in E5 Section 8.12. Some objects have behavior which differs from default behavior; we call these <em>exotic properties</em> (or properties with <em>exotic behavior</em>), as opposed to <em>normal properties</em> (or properties with <em>normal behavior</em> or <em>default behavior</em>).</p><p>Conceptually each object has a number of algorithms &quot;stored&quot; in its internal properties (E5 Section 8.6.2), including all the property access algorithms. The current implementation of property access is completely different: there are fixed algorithms for property access, which change their behavior based on object type and flags. The exotic behaviors are thus &quot;inlined&quot; into a single algorithm.</p><p>From a purely implementation viewpoint some properties are stored in a data structure as concrete key-value pairs, while others are computed on-the-fly. The former are called <em>concrete properties</em> and the latter <em>virtual properties</em>. Whether a property is concrete or virtual should have no externally visible impact with respect to compliance. Note that these two concepts (&quot;being exotic&quot; and &quot;being virtual&quot;) are indepedent: a exotic property can be implemented with a concrete property storing its value, and a normal property can be implemented as a virtual property.</p><h3 id="exotic-behaviors-in-e5-specification" tabindex="-1">Exotic behaviors in E5 specification <a class="header-anchor" href="#exotic-behaviors-in-e5-specification" aria-label="Permalink to &quot;Exotic behaviors in E5 specification&quot;">​</a></h3><p>Exotic behaviors are discussed at least in the following places in the E5 specification (page numbers refer to page numbers on the page contents, not the &quot;PDF page number&quot;).</p><p>Section 8.6.2, pages 32-33 summarizes exotic behavior and refers to:</p><ul><li>Array objects: <code>[[DefineOwnProperty]]</code>, E5 Section 15.4.5.1</li><li>String objects: <code>[[GetOwnProperty]]</code>, E5 Section 15.5.5.2</li><li>Arguments objects: <code>[[Get]]</code>, <code>[[GetOwnProperty]]</code>, <code>[DefineOwnProperty]]</code>, <code>[[Delete]]</code>, E5 Section 10.6 (the exotic behavior of a non-strict arguments object is pretty intricate and is discussed separately in <code>arguments-object.rst</code>)</li><li>Function objects: <code>[[Get]]</code>, E5 Section 15.3</li></ul><p>Exotic behavior for <code>[[Get]]</code>:</p><ul><li>The <code>arguments</code> object: E5 Section 10.5 <ul><li>If <code>arguments.caller</code> has a value, which is a strict function object, the <code>[[Get]]</code> operation fails after standard lookup is complete.</li><li>Note that the exotic behavior occurs at the level of <code>[[Get]]</code> and is <em>not</em> visible through property descriptors, e.g. through <code>[[GetProperty]]</code> or <code>[[GetOwnProperty]]</code>.</li><li>Exotic behavior only applies to non-strict arguments objects.</li></ul></li><li>The <code>Function</code> object: E5 Section 15.3.5.4 <ul><li>Same exotic behavior for <code>caller</code> property as for <code>arguments</code> object.</li></ul></li></ul><p>Exotic behavior for <code>[[GetOwnProperty]]</code>:</p><ul><li><code>String</code> object array-index properties: E5 Section 15.5.5.2 <ul><li>Covers properties which are valid array indexes as specified in E5 Section 15.4, i.e. P for which <code>ToString(ToUint32(P)) == P</code> and <code>ToUint32(P) != 0xffffffff</code>.</li><li>ECMAScript E5.1 extended behavior to all number-like properties, and thus allows strings longer than 4G characters.</li></ul></li><li><code>Array</code> <code>length</code> property: E5 Section 15.4.5 <ul><li>May be implemented as a concrete property or as a virtual property. Currently implemented as a concrete property.</li></ul></li><li>The <code>arguments</code> object: E5 Section 10.5 <ul><li>The <code>[[Value]]</code> of a property descriptor may be overridden for &quot;magically bound&quot; properties (some numeric indices).</li><li>Exotic behavior only applies to non-strict arguments objects.</li></ul></li></ul><p>Exotic behavior for <code>[[DefineOwnProperty]]</code>:</p><ul><li><code>Array</code> <code>length</code> property: E5 Section 15.4.5.1 <ul><li>Has side effects on array elements (deleting elements above newly written length).</li></ul></li><li><code>Array</code> index properties: E5 Section 15.4.5.1 <ul><li>Has the side effect of automatically updating array <code>length</code>.</li></ul></li><li>The <code>arguments</code> object: E5 Section 10.6 <ul><li>Automatic interaction with &quot;magically bound&quot; variables (some numeric indices). May also remove magic binding.</li><li>Exotic behavior only applies to non-strict arguments objects.</li></ul></li></ul><p>Exotic behavior for <code>[[Delete]]</code>:</p><ul><li>The <code>arguments</code> object: E5 Section 10.6 <ul><li>Automatic interaction with &quot;magically&quot; bound variables (some numeric indices), may remove magic binding.</li><li>Exotic behavior only applies to non-strict arguments objects.</li></ul></li></ul><p>When implementing exotic or virtual properties, property attributes must be respected normally. Exotic or virtual properties may have specific initial attributes, but these are not fixed and may be changed later by user code. The <em>only</em> properties which are &quot;truly fixed&quot; are:</p><ul><li>Non-configurable, non-writable data properties</li><li>Non-configurable accessor properties</li></ul><p>In particular, a data property which is non-configurable but writable <em>can</em> be changed to non-writable (see E5 Section, step 10). The property cannot be changed back to writable after that. This has the practical implication that only &quot;truly fixed&quot; properties can be easily implemented as stateless virtual properties.</p><h3 id="summary-of-exotic-properties" tabindex="-1">Summary of exotic properties <a class="header-anchor" href="#summary-of-exotic-properties" aria-label="Permalink to &quot;Summary of exotic properties&quot;">​</a></h3><p>The following table summarizes exotic properties defined in the E5 specification, along with their (initial) property attributes in the columns W(ritable), E(numerable), and C(onfigurable): <code>y</code> means &quot;true&quot;, <code>n</code> means &quot;false&quot;, <code>a</code> means &quot;any&quot;:</p><table tabindex="0"><thead><tr><th>Object</th><th>Property</th><th>W</th><th>E</th><th>C</th><th>Notes</th></tr></thead><tbody><tr><td><code>Array</code> instance</td><td><code>length</code></td><td>y</td><td>n</td><td>n</td><td>Write may affect array elements (indices above new length are deleted)</td></tr><tr><td><code>Array</code> instance</td><td>array indices</td><td>a</td><td>a</td><td>a</td><td>Write may affect array <code>length</code> (if new index is above existing length)</td></tr><tr><td><code>String</code> instance</td><td><code>length</code></td><td>n</td><td>n</td><td>n</td><td>No exotic behavior as such, but easy to implement as a virtual property because not writable or configurable.</td></tr><tr><td><code>String</code> instance</td><td>array indices inside string length</td><td>n</td><td>y</td><td>n</td><td>No exotic behavior as such, but maps individual characters to indicates; affects enumeration.</td></tr><tr><td>plain string value</td><td><code>length</code></td><td>n</td><td>n</td><td>n</td><td>See notes below.</td></tr><tr><td>plain string value</td><td>array indices inside string length</td><td>n</td><td>y</td><td>n</td><td>See notes below.</td></tr><tr><td>Arguments object, non-strict</td><td>some numeric indices</td><td>y</td><td>y</td><td>y</td><td>Some numeric indices of an arguments object &quot;magically bind&quot; to formal arguments. Only affects a non-strict arguments object.</td></tr><tr><td>Arguments object, non-strict</td><td><code>caller</code></td><td>a</td><td>a</td><td>a</td><td>If <em>value</em> of <code>caller</code> property is a strict function, <code>[[Get]]</code> fails (but <code>[[GetOwnProperty]]</code> does not!). Only affects a non-strict arguments object.</td></tr></tbody></table><p>Notes:</p><ul><li>The exotic properties for <code>String</code> instances (which are objects) also apply in practice to plain strings, because properties of plain strings can also be accessed (the string is automatically promoted to a temporary object; the implementation handles this without an actual temporary object being created).</li><li>The <code>caller</code> property of a non-strict arguments object is curious: it has exotic behavior but no such property is established for non-strict argument objects. (This is why its property attributes are listed as &quot;any&quot; above.)</li><li>The only exotic properties which are easy to implement as fully virtual, stateless properties are the <code>String</code> instance <code>length</code> and array index properties, because they are non-configurable and non-writable. They are enumerable, though, which must be taken into account in enumeration.</li><li>The array <code>length</code> property has an initial value which is a valid array length (32-bit unsigned integer). The exotic behavior of the property ensures that whatever values are assigned to it, they are either rejected or coerced into a valid array length (32-bit unsigned integer).</li></ul><h3 id="implementation-of-exotic-properties" tabindex="-1">Implementation of exotic properties <a class="header-anchor" href="#implementation-of-exotic-properties" aria-label="Permalink to &quot;Implementation of exotic properties&quot;">​</a></h3><p>The following table summarizes the implementation of exotic properties at the moment.</p><table tabindex="0"><thead><tr><th>Object</th><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>Array</code> instance</td><td><code>length</code></td><td>Stored as a concrete property. <code>DUK_HOBJECT_FLAG_EXOTIC_ARRAY</code> enables exotic behavior in: <code>duk_hobject_put_value()</code>, <code>duk_hobject_object_define_property()</code>.</td></tr><tr><td><code>Array</code> instance</td><td>array indices</td><td>Stored as conrete properties in array part or entry part (if array part abandoned). <code>DUK_HOBJECT_FLAG_EXOTIC_ARRAY</code> enables exotic behavior in: <code>duk_hobject_put_value()</code>, <code>duk_hobject_object_define_property()</code>.</td></tr><tr><td><code>String</code> instance</td><td><code>length</code></td><td>Virtual property computed from the string length of the internal <code>_Value</code> property. <code>DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ</code> enables exotic behavior in: <code>get_own_property_desc()</code>.</td></tr><tr><td><code>String</code> instance</td><td>array indices inside string length</td><td>Virtual properties computed by looking up characters of the internal <code>_Value</code> property. <code>DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ</code> enables exotic behavior in: <code>get_own_property_desc()</code>.</td></tr><tr><td>plain string value</td><td><code>length</code></td><td>Exotic handling in property access code, return string character length without promoting the plain string value to a temporary <code>String</code> instance.</td></tr><tr><td>plain string value</td><td>array indices inside string length</td><td>Exotic handling in property access code, return individual character value without promoting the plain string value to a temporary <code>String</code> instance.</td></tr><tr><td>Arguments object, non-strict</td><td>some numeric indices</td><td>Stored as concrete property values. <code>DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS</code> enables exotic behavior in: <code>get_own_property_desc()</code>, <code>duk_hobject_get_value()</code>, <code>duk_hobject_put_value()</code>, <code>duk_hobject_delete_property()</code>, <code>duk_hobject_object_define_property()</code>.</td></tr><tr><td>Arguments object, non-strict</td><td><code>caller</code></td><td>Stored as a concrete property <code>DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS</code> enables exotic behavior in: <code>duk_hobject_get_value()</code>. This exotic behavior only affects <code>[[Get]]</code>, it is not visible through e.g. property descriptors or <code>[[GetOwnProperty]]</code>.</td></tr></tbody></table><p>Notes:</p><ul><li>The only virtual properties are <code>String</code> object <code>length</code> and array index properties. These are easy to implement as virtual properties because they are non-configurable and non-writable. However, they <em>are</em> enumerable which affects enumeration handling.</li><li>If array <code>length</code> becomes non-writable, the exotic behavior ensures no elements above the specified length can ever be inserted. The array part could thus be compacted without risk of it being extended afterwards.</li></ul><h3 id="notes-on-array-length-and-array-indices" tabindex="-1">Notes on array length and array indices <a class="header-anchor" href="#notes-on-array-length-and-array-indices" aria-label="Permalink to &quot;Notes on array length and array indices&quot;">​</a></h3><p>The exotic array semantics only apply to valid array indices. Nothing prevents user code from writing to numeric array indices higher than the maximum valid array index, but such writes will get no exotic behavior:</p><pre><code>var x = [];
x[&quot;4294967294&quot;] = 1;    // has array semantics, updates length
print(x.length);        // length is 4294967295

x[&quot;9999999999&quot;] = 2;    // no array semantics
print(x.length);        // length is still 4294967295

print(x[4294967294]);   // coerced to string -&gt; value &quot;1&quot;
print(x[9999999999]);   // like above -&gt; value &quot;2&quot;

print(Object.keys(x));  // -&gt; [&quot;4294967294&quot;, &quot;999999999&quot;]

x.length = 0;           // deletes valid array indices
print(x[4294967294]);   // undefined
print(x[9999999999]);   // value still &quot;2&quot;, not auto-deleted
</code></pre><p>Note that assigning an <code>undefined</code> value extends the array length, as it is a valid value:</p><pre><code>var x = [];
print(x.length);        // -&gt; 0
x[10] = undefined;
print(x.length);        // -&gt; 11

print(Object.keys(x));  // -&gt; [ &quot;10&quot; ]
</code></pre><h2 id="internal-objects" tabindex="-1">Internal objects <a class="header-anchor" href="#internal-objects" aria-label="Permalink to &quot;Internal objects&quot;">​</a></h2><p>The following internal objects are currently used:</p><ul><li>Function templates which are &quot;instantiated&quot; into concrete closures</li><li>A declarative environment record</li><li>An object environment record</li><li>Function formals name list</li><li>Function variable map</li></ul><p>Internal objects don&#39;t always need ECMAScript properties like:</p><ul><li>Enumeration order</li><li>Property attributes</li><li>Prototype chain</li></ul><p>The current implementation does not take advantage of these: internal objects are handled just like ECMAScript objects.</p><h2 id="function-instances" tabindex="-1">Function instances <a class="header-anchor" href="#function-instances" aria-label="Permalink to &quot;Function instances&quot;">​</a></h2><p>The creation of function instances is described in E5 Section 13.2. Each function instance (each closure created from a function expression or declaration) has the following properties:</p><ul><li><code>length</code></li><li><code>prototype</code>: points to a fresh object which has a <code>constructor</code> property pointing back to the function</li><li><code>caller</code>: thrower (strict functions only)</li><li><code>arguments</code>: thrower (strict functions only)</li></ul><p>There is considerable variance in practical implementations:</p><ul><li><p>smjs:</p><pre><code>  // the &quot;name&quot; property is non-standard; &quot;arguments&quot; and &quot;caller&quot; are
  // present for a non-strict function

  js&gt; f = function foo() {}
  (function () {})
  js&gt; Object.getOwnPropertyNames(f)
  [&quot;prototype&quot;, &quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;]

  // for strict mode, the same properties are present.

  js&gt; f = function foo() { &quot;use strict&quot;; }
  (function foo() {&quot;use strict&quot;;})
  js&gt; Object.getOwnPropertyNames(f);
  [&quot;prototype&quot;, &quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;]

  // the &quot;name&quot; property contains the function expression name

  js&gt; f.name
  &quot;foo&quot;

  // &quot;name&quot; is non-writable, non-configurable (and non-enumerable)
  // -&gt; works as a reliable &quot;internal&quot; property too

  js&gt; Object.getOwnPropertyDescriptor(f, &#39;name&#39;)
  ({configurable:false, enumerable:false, value:&quot;foo&quot;, writable:false})
</code></pre></li><li><p>nodejs (v8):</p><pre><code>  // &quot;name&quot; is non-standard; &quot;arguments&quot; and &quot;caller&quot; are present
  // for even a non-strict function

  &gt; f = function foo() {}
  [Function: foo]
  &gt; Object.getOwnPropertyNames(f)
  [ &#39;length&#39;,
    &#39;caller&#39;,
    &#39;arguments&#39;,
    &#39;name&#39;,
    &#39;prototype&#39; ]
  &gt; f.name
  &#39;foo&#39;

  // strict mode is the same

  &gt; f = function foo() { &quot;use strict&quot;; }
  [Function: foo]
  &gt; Object.getOwnPropertyNames(f)
  [ &#39;name&#39;,
    &#39;length&#39;,
    &#39;arguments&#39;,
    &#39;prototype&#39;,
    &#39;caller&#39; ]

  // &#39;name&#39; is writable but not configurable/enumerable

  &gt; f.name
  &#39;foo&#39;
  &gt; Object.getOwnPropertyDescriptor(f, &#39;name&#39;)
  { value: &#39;foo&#39;,
    writable: true,
    enumerable: false,
    configurable: false }
</code></pre></li><li><p>rhino:</p><pre><code>  // &quot;name&quot; is non-standard, &quot;arity&quot; is non-standard, &quot;arguments&quot;
  // is present (but &quot;caller&quot; is not)

  js&gt; f = function foo() {}
  [...]
  js&gt; Object.getOwnPropertyNames(f)
  arguments,prototype,name,arity,length

  // name is non-writable, non-enumerable, non-configurable

  js&gt; pd = Object.getOwnPropertyDescriptor(f, &#39;name&#39;)
  [object Object]
  js&gt; pd.writable
  false
  js&gt; pd.enumerable
  false
  js&gt; pd.configurable
  false

  // strict mode functions are similar
</code></pre></li></ul><p>See <code>function-objects.rst</code> for more discussion.</p><h3 id="built-in-functions" tabindex="-1">Built-in functions <a class="header-anchor" href="#built-in-functions" aria-label="Permalink to &quot;Built-in functions&quot;">​</a></h3><p>The properties of built-in functions are a special case, because they are not created with the algorithm in E5 Section 13.2; instead, their properties are described explicitly in E5 Section 15.</p><p>There is considerable variance between implementations on what properties built-in functions get.</p><h2 id="design-notes-and-future-work" tabindex="-1">Design notes and future work <a class="header-anchor" href="#design-notes-and-future-work" aria-label="Permalink to &quot;Design notes and future work&quot;">​</a></h2><h3 id="es2015-proxy-objects-or-lua-like-metatables" tabindex="-1">ES2015 Proxy objects or Lua-like metatables <a class="header-anchor" href="#es2015-proxy-objects-or-lua-like-metatables" aria-label="Permalink to &quot;ES2015 Proxy objects or Lua-like metatables&quot;">​</a></h3><p>It would be nice to have a Lua metatable like mechanism for creating custom object behavior extensions and full object virtualization, see <a href="http://www.lua.org/pil/13.html" target="_blank" rel="noreferrer">http://www.lua.org/pil/13.html</a> for a description of Lua metatables. There is a similar mechanism in ECMAScript 6 called &quot;Proxy object&quot;:</p><ul><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-proxy-object-internal-methods-and-internal-slots" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-proxy-object-internal-methods-and-internal-slots</a></li></ul><p>The ES2015 Proxy object is of course a natural target for implementation, but it&#39;s not clear what the underlying mechanism should be: should the Proxy object mechanism be the internal mechanism, or should there be some other implementation specific mechanism underneath which is used to provide the Proxy object implementation but also provide non-standard additional features?</p><p>Nice-to-have features:</p><ul><li>Sufficient for creating arbitrary &quot;host objects&quot;</li><li>Sufficient for providing array-like access to byte buffers</li><li>Allow &quot;full virtualization&quot; of E5 semantics</li></ul><p>Some notes:</p><ul><li>Should interact reasonably with the E5 object model, e.g. property descriptors.</li><li>Should metatable behavior only affect non-existent properties (as in Lua)? To apply it to all properties, simply use an empty table.</li><li>May require raw access functions for dealing with the underlying properties.</li><li>What&#39;s the best level for capturing operations? a. Concrete, exposed operations like getprop, putprop, hasprop, delprop, Object.getOwnPropertyDescriptor(), Object.defineProperty(), etc? b. Specification functions like <code>[[GetOwnProperty]]</code>, <code>[[DefineProperty]]</code> etc?</li><li>In addition, should cover: <ul><li>Enumeration</li><li>Getting object <code>[[Class]]</code></li><li>Garbage collection =&gt; finalizer</li></ul></li></ul><h3 id="es2015-features" tabindex="-1">ES2015 features <a class="header-anchor" href="#es2015-features" aria-label="Permalink to &quot;ES2015 features&quot;">​</a></h3><p>There are many ES2015 features which may need changes to the basic object model.</p><p>For instance, there are keyed collections:</p><ul><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-keyed-collection" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-keyed-collection</a></li></ul><p>The <code>Map</code> object provides an arbitrary collection of key/value pairs, where keys and values can be arbitrary ECMAScript objects. This is very useful compared to the standard ECMAScript object whose keys can only be strings.</p><p>How to implement this? One could extend the basic model to provide enough functionality to implement <code>Map</code> values. One could also implement them entirely separate from the basic object model. The trouble is, the <code>Map</code> keys and values must be GC reachable so they have to reside either in basic objects or there needs to be additional native structure for them.</p><h3 id="array-like-access-to-underlying-byte-buffers" tabindex="-1">Array-like access to underlying byte buffers <a class="header-anchor" href="#array-like-access-to-underlying-byte-buffers" aria-label="Permalink to &quot;Array-like access to underlying byte buffers&quot;">​</a></h3><p>There are various proposals for typed access to an underlying buffer. For instance:</p><ul><li><a href="http://www.khronos.org/registry/typedarray/specs/latest/" target="_blank" rel="noreferrer">http://www.khronos.org/registry/typedarray/specs/latest/</a></li><li><a href="http://nodejs.org/docs/v0.4.7/api/buffers.html" target="_blank" rel="noreferrer">http://nodejs.org/docs/v0.4.7/api/buffers.html</a></li></ul><p>See <code>buffers.txt</code>.</p><h3 id="windowproxy" tabindex="-1">WindowProxy <a class="header-anchor" href="#windowproxy" aria-label="Permalink to &quot;WindowProxy&quot;">​</a></h3><p>The HTML5 WindowProxy object seems to require behavior outside E5.</p><p>See: <a href="http://www.w3.org/TR/html5/browsers.html#windowproxy" target="_blank" rel="noreferrer">http://www.w3.org/TR/html5/browsers.html#windowproxy</a>.</p><p>The ES2015 Proxy object probably addresses this.</p><h3 id="script-origin-for-security-checks" tabindex="-1">Script origin for security checks <a class="header-anchor" href="#script-origin-for-security-checks" aria-label="Permalink to &quot;Script origin for security checks&quot;">​</a></h3><p>HTML5 web storage, as an example, uses &#39;script origin&#39; to do required security checks on property access.</p><p>Possible implementation e.g. through: a metatable-like mechanism for capturing accesses, and some way to introspect the current caller or call chain to check script origin.</p><p>It would be nice to be able to determine an origin for every function, mapped to an ECMAScript object with a bunch of propeties like URI, load time.</p><h3 id="alternatives-to-current-entry-part" tabindex="-1">Alternatives to current entry part <a class="header-anchor" href="#alternatives-to-current-entry-part" aria-label="Permalink to &quot;Alternatives to current entry part&quot;">​</a></h3><p>Are there better alternatives to the current entry part model?</p><p>The pointer computations have a run-time performance cost and also a code footprint cost. Is it worth it? This depends on the number of objects. For instance, if there are 1000 objects and a pointer to the array part and hash part are added to <code>duk_hobject</code>, this would have a footprint of 8000 extra bytes on a 32-bit platform.</p><h3 id="hash-algorithm-notes" tabindex="-1">Hash algorithm notes <a class="header-anchor" href="#hash-algorithm-notes" aria-label="Permalink to &quot;Hash algorithm notes&quot;">​</a></h3><p>Some hash algorithm goals:</p><ul><li>Minimal memory allocation</li><li>High load factor (minimizes memory use)</li><li>Small code space</li></ul><p>Closed hashing (open addressing) provides fixed allocation, but requires a &quot;probe sequence&quot; to deal with hash collisions. Options for dealing with collisions include:</p><ul><li><a href="http://en.wikipedia.org/wiki/Linear_probing" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Linear_probing</a></li><li><a href="http://en.wikipedia.org/wiki/Quadratic_probing" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Quadratic_probing</a></li><li><a href="http://en.wikipedia.org/wiki/Double_hashing" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Double_hashing</a></li><li><a href="http://en.wikipedia.org/wiki/Cuckoo_hashing" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Cuckoo_hashing</a></li></ul><p>Notes on current solution:</p><ul><li>Linear probing is more cache efficient but requires a lower load (= higher allocated size relative to used size) to avoid &#39;clustering&#39; issues. Current approach prefers compact object size over cache efficiency.</li><li>Slightly better probe would be: <code>probe_steps[(hash &gt;&gt; 16) % 32]</code>. This could possibly correlate less with the initial hash value, but requires an extra shift operation. Most likely not worth it.</li><li>The current algorithm is not very good, as it requires the load factor to be relatively low (around 70-80%) to be efficient. Much better results are possible. This is definite future work.</li></ul><h3 id="property-key-ordering" tabindex="-1">Property key ordering <a class="header-anchor" href="#property-key-ordering" aria-label="Permalink to &quot;Property key ordering&quot;">​</a></h3><p>Because of the practical enumeration requirements, a data structure for object keys must both maintain keys in their insertion order, and also support some form of indexed access (e.g. a hash table) to work efficiently with large objects.</p><p>One such approach is to use an &quot;ordered hash table&quot; which maintains entries both in the hash structure and a linked list for order.</p><p>The current approach is to maintain a simple, ordered entry part, and then provide an optional hash table on top of that. This has some nice properties:</p><ul><li>The entry part maintains key ordering trivially.</li><li>The hash part is optional, which minimizes object size. For small objects a linear scan of keys is also relatively efficient because the keys are adjacent in memory (being in the own &quot;sub array&quot;).</li><li>The hash part is non-critical. For instance, it could be dumped in an emergency out of memory situation without losing any information.</li><li>It would be relatively straightforward to support multiple hash algorithms for e.g. different object sizes. In particular, it might be useful to have a variant for medium size objects, where entry part indices could be 8-bit or 16-bit values (instead of 32-bit).</li></ul><p>What are the practical alternatives?</p><h3 id="separate-object-type-for-internal-objects" tabindex="-1">Separate object type for internal objects <a class="header-anchor" href="#separate-object-type-for-internal-objects" aria-label="Permalink to &quot;Separate object type for internal objects&quot;">​</a></h3><p>There used to be a separate object type for internal objects.</p><p>The differences to standard objects include: no need to support array part, no property attributes, no accessor properties, no need to preserve property ordering, no exotic behaviors, etc.</p><p>However, the extra cost of having another object data structure does not seem worth it. The effects are:</p><ul><li>Code size is increased by several kilobytes.</li><li>Internal objects data size decreases slightly (no need to track property attributes, for instance).</li><li>Internal object property lookup is slightly more performant.</li></ul><p>Currently it seems to make more sense to use the same object abstraction but to provide &quot;short cut&quot; raw property accessors for faster / simpler accessing, if necessary.</p><h3 id="array-part-freezing-vs-abandoning" tabindex="-1">Array part &quot;freezing&quot; vs abandoning <a class="header-anchor" href="#array-part-freezing-vs-abandoning" aria-label="Permalink to &quot;Array part \\&quot;freezing\\&quot; vs abandoning&quot;">​</a></h3><p>The current policy is that the array part is either actively used and contains all array indexed properties, or it is abandoned entirely and all entries moved to the entry part. An alternative design would allow some array entries to be in the array part and others in the entry part.</p><p>For instance, the array part could be &quot;frozen&quot; and entries above the allocated size could reside in the entry part. This is an easy and relatively straightforward policy too:</p><ul><li>If the &quot;frozen&quot; flag is set, never resize the array part (except perhaps to abandon it entirely).</li><li>If an array index key is not found from the array part, and the &quot;frozen&quot; flag is <em>not</em> set, no need to look at the entry part (this would be the common case). If the &quot;frozen&quot; flag is set, need to look at the entry part, too.</li></ul><p>This policy has the nice side effect that there is no need to necessarily support array abandoning at all. However, without array abandoning the frozen array part could be left arbitrarily sparse after deletions.</p><h3 id="array-size-management-improvements" tabindex="-1">Array size management improvements <a class="header-anchor" href="#array-size-management-improvements" aria-label="Permalink to &quot;Array size management improvements&quot;">​</a></h3><ul><li>When to do compaction checks (e.g. property deletion)?</li><li>Periodic actual density checks (relative to e_size + a_size to keep average cost limited)?</li><li>Triggered density checks?</li></ul><h3 id="more-fast-paths-for-array-indexing" tabindex="-1">More fast paths for array indexing <a class="header-anchor" href="#more-fast-paths-for-array-indexing" aria-label="Permalink to &quot;More fast paths for array indexing&quot;">​</a></h3><p>It would be nice to have more fast paths (intern free accesses) for the array part. In particular, it would be very nice to have a fast path for <code>[[Put]]</code>, at least for the very common case of a plain Array value inheriting from <code>Array.prototype</code> with no array indexes entries anywhere in the prototype chain.</p><p>How to do the prototype chain check required by <code>[[Put]]</code> efficiently? In other hands, how to the check <em>without interning the index</em> that:</p><ul><li>The property does not exist in any ancestor.</li><li>Or if it exists in an ancestor, the write is not prevented by a non-writable property or &quot;captured&quot; by an accessor property.</li></ul><p>Some approaches:</p><ul><li>Rework the property lookup to do lazy interning in general.</li><li>Add an object flag <code>DUK_HOBJECT_FLAG_NO_ARRIDX_PROPS</code>. <ul><li>If set, the flag guarantees that the object has no concrete or virtual array indexed properties.</li><li>The prototype walking check can then simply check that no object in the prototype chain has this flag cleared. The flag must be cleared for e.g. <code>String</code> objects which have virtual array indexed properties.</li><li>Unfortunately the <code>Array</code> prototype is itself an array, see E5 Section 15.4.4. However, it normally has no array elements, so it could have the flag set initially, and if someone set an array index to the prototype (which does not really make sense) the flag would be cleared, wrecking performance.</li><li>Whenever adding a new property (by whichever means) and the key is an array index, the flag must be cleared for the target object.</li></ul></li></ul><p>Note that the fast path really only needs to work for <code>Array</code> instances in practice. Their prototype chain is:</p><pre><code>null
 ^
 |
Object prototype (E5 Section 15.2.4)
 ^
 |
Array prototype (E5 Section 15.4.4)
 ^
 |
Array instance (see E5 Section 15.4.2)
</code></pre><p>The exotic flag based approach would work if the object and array prototypes have no array indexed keys.</p><p>Existing ECMAScript implementations do not seem to implement the official <code>[[Put]]</code> algorithm accurately, especially for checking the ancestor properties for protection. For instance, NodeJS / V8:</p><pre><code>&gt; var p = Array.prototype;
&gt; Object.defineProperty(p, &#39;0&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
[]
&gt; var a = [];
&gt; a[0] = &#39;own&#39;;  // should fail
&#39;own&#39;
&gt; console.log(a[0]);  // but does not
own
</code></pre><p>NodeJS / V8 doesn&#39;t seem to respect <code>[[Put]]</code> for normal objects either:</p><pre><code>&gt; var p = Object.prototype;
&gt; Object.defineProperty(p, &#39;foo&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
{}
&gt; var o = {};
&gt; o.foo = &#39;own&#39;;  // should fail
&#39;own&#39;
&gt; console.log(o.foo);  // but does not
own
</code></pre><p>Rhino respects the algorithm in both cases:</p><pre><code>Rhino 1.7 release 3 2012 02 13
js&gt; var p = Array.prototype;
js&gt; Object.defineProperty(p, &#39;0&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
inherited
js&gt; var a = [];
js&gt; a[0] = &#39;own&#39;;  // should fail
own
js&gt; print(a[0]);
inherited
</code></pre><p>and:</p><pre><code>Rhino 1.7 release 3 2012 02 13
js&gt; var p = Object.prototype;
js&gt; Object.defineProperty(p, &#39;foo&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
[object Object]
js&gt; var o = {};
js&gt; o.foo = &#39;own&#39;;  // should fail
own
js&gt; print(o.foo);
inherited
</code></pre><p>Similarly for Smjs:</p><pre><code>js&gt; var p = Array.prototype;
js&gt; Object.defineProperty(p, &#39;0&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
[&quot;inherited&quot;]
js&gt; var a = [];
js&gt; a[0] = &#39;own&#39;;  // should fail
&quot;own&quot;
js&gt; print(a[0]);
inherited
</code></pre><p>and:</p><pre><code>js&gt; var p = Object.prototype;
js&gt; Object.defineProperty(p, &#39;foo&#39;, { &#39;value&#39;: &#39;inherited&#39;, &#39;writable&#39;: false });
({})
js&gt; var o = {};
js&gt; o.foo = &#39;own&#39;;
&quot;own&quot;
js&gt; print(o.foo);
inherited
</code></pre><h3 id="delete-keys-from-enumerator-state-during-enumeration" tabindex="-1">Delete keys from enumerator state during enumeration <a class="header-anchor" href="#delete-keys-from-enumerator-state-during-enumeration" aria-label="Permalink to &quot;Delete keys from enumerator state during enumeration&quot;">​</a></h3><p>It would be nice to delete keys from enumerator state once the keys have been enumerated. This would reduce memory pressure as quickly as it is currently possible. Care must be taken to avoid a resize and key compaction while enumeration is running.</p><p>A more practical alternative is to replace the already enumerated keys with a fixed string (e.g. the empty string). This would allow the enumerated keys to be freed as the enumeration progresses. However, this would create duplicate keys in the entry part, something which is not currently allowed and would thus need careful consideration.</p><h3 id="enumeration-ordering-vs-mutation" tabindex="-1">Enumeration ordering vs. mutation <a class="header-anchor" href="#enumeration-ordering-vs-mutation" aria-label="Permalink to &quot;Enumeration ordering vs. mutation&quot;">​</a></h3><p>Enumeration vs. mutation causes a lot of implementation headache, as no internal reorganizations (hash part resizing, array part reallocation or dropping, compactions) can cause enumeration to fail. There are at least three basic approaches to manage these:</p><ol><li>Freeze the object when one or more enumerations are in progress. However, to do this, enumerations must be tracked which complicates execution.</li><li>Design the data structures to work with enumeration (especially mutation during enumeration) so that the object does not need to know that enumerations are in progress. This is difficult.</li><li>Create a snapshot of keys to-be-enumerated when the enumerator is created. This wastes memory but is guaranteed to work - although newly added keys will not show up in the enumeration (which is compliant behavior).</li></ol><p>The current approach is to create a snapshot of keys and then re-check them to see whether they&#39;ve been deleted during enumeration.</p><h3 id="more-modular-virtual-exotic-properties" tabindex="-1">More modular virtual/exotic properties <a class="header-anchor" href="#more-modular-virtual-exotic-properties" aria-label="Permalink to &quot;More modular virtual/exotic properties&quot;">​</a></h3><p>More modular (but still compact) way of implementing virtual and exotic properties?</p><h3 id="test-cases" tabindex="-1">Test cases <a class="header-anchor" href="#test-cases" aria-label="Permalink to &quot;Test cases&quot;">​</a></h3><p>Black box and white box test cases.</p>`,373)]))}const m=t(i,[["render",n]]);export{h as __pageData,m as default};
