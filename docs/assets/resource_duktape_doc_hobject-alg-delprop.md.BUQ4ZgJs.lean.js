import{_ as o,c as t,a2 as r,o as c}from"./chunks/framework.CuCbyi2k.js";const u=JSON.parse('{"title":"DELPROP: exposed property deletion algorithm (\\"delete\\" operator)","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-delprop.md","filePath":"resource/duktape/doc/hobject-alg-delprop.md","lastUpdated":1732350347000}'),d={name:"resource/duktape/doc/hobject-alg-delprop.md"};function i(a,e,l,n,s,p){return c(),t("div",null,e[0]||(e[0]=[r(`<h1 id="delprop-exposed-property-deletion-algorithm-delete-operator" tabindex="-1">DELPROP: exposed property deletion algorithm (&quot;delete&quot; operator) <a class="header-anchor" href="#delprop-exposed-property-deletion-algorithm-delete-operator" aria-label="Permalink to &quot;DELPROP: exposed property deletion algorithm (\\&quot;delete\\&quot; operator)&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>Properties are deleted in ECMAScript code with the <code>delete</code> operator, e.g.:</p><pre><code>delete foo.bar;
</code></pre><p>This involves:</p><ul><li>A property accessor reference (E5 Section 11.2.1)</li><li><code>delete</code> semantics (E5 Section 11.4.1)</li><li>A call to <code>[[Delete]]</code></li></ul><p>The property accessor coercions are the same as for <code>GetValue</code>:</p><ul><li>The base reference is checked with <code>CheckObjectCoercible()</code></li><li>The property name is coerced to a string</li></ul><p>The <code>delete</code> expression will then:</p><ul><li>Coerce the base value to an object</li><li>Call the <code>[[Delete]]</code> algorithm</li></ul><p>Note that if the base value is not an object, a temporary object will be created by coercion. Since a deletion always operates on the &quot;own properties&quot; of an object, the deletion can only have side effects (error throwing) side effects. Any other effects will be lost with the temporary object. This is discussed in more detail below, for the deletion algorithm.</p><p>Notes:</p><ul><li><code>[[Delete]]</code> only checks for the property <code>P</code> in the original object <code>O</code>, and does not follow the prototype chain</li><li>In particular, an inherited property <code>P</code> which would prevent a <code>[[Put]]</code> does not affect the outcome of <code>[[Delete]]</code></li></ul><h2 id="first-draft" tabindex="-1">First draft <a class="header-anchor" href="#first-draft" aria-label="Permalink to &quot;First draft&quot;">​</a></h2><p>Starting from the property accessor, then applying <code>delete</code> (and skipping any unused steps):</p><ol><li>Call <code>CheckObjectCoercible</code> for the base value. In practice, throw a <code>TypeError</code> if the base value is <code>null</code> or <code>undefined</code>.</li><li>Coerce property name to string using <code>ToString()</code>.</li><li>Coerce base value to object using <code>ToObject()</code> and call <code>[[Delete]]</code> with the coerced object, the coerced key, and a &quot;Throw&quot; flag set if the property reference is contained in strict mode code.</li></ol><p>More formally, suppose <code>O</code> is the base value, <code>P</code> is the property name value, and <code>currStrict</code> is <code>true</code> if the property deletion expression occurred in strict code:</p><ol><li>If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code></li><li><code>P</code> = <code>ToString(P)</code></li><li><code>O</code> = <code>ToObject(O)</code></li><li>Call <code>O.[[Delete]](P, currStrict)</code>, and return its result</li></ol><h2 id="avoiding-object-coercion" tabindex="-1">Avoiding object coercion <a class="header-anchor" href="#avoiding-object-coercion" aria-label="Permalink to &quot;Avoiding object coercion&quot;">​</a></h2><p>We want to avoid the object coercion; let&#39;s first make it more explicit:</p><ol><li>If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code></li><li><code>P</code> = <code>ToString(P)</code></li><li>If <code>O</code> is an object, call <code>[[Delete]](O, P, currStrict)</code>, and return its result</li><li>Else <code>O</code> is primitive: a. <code>O</code> = <code>ToObject(O)</code> (create temporary object) b. Call <code>O.[[Delete]](P, currStrict)</code>, and return its result</li></ol><h2 id="avoiding-temporary-objects" tabindex="-1">Avoiding temporary objects <a class="header-anchor" href="#avoiding-temporary-objects" aria-label="Permalink to &quot;Avoiding temporary objects&quot;">​</a></h2><p>Note that a <code>[[Delete]]</code> only operates on the &quot;own properties&quot; of the target object. When the base value is not an object, the deletion operates only on the temporary object. Since the temporary object is immediately discarded, there are only two possible user visible effects:</p><ul><li>The return value of <code>[[Delete]]</code>, which is: <ul><li><code>true</code>, if the property does not exist</li><li><code>true</code>, if the property exists and could be deleted</li><li><code>false</code>, if the property exists, cannot be deleted, and <code>Throw</code> is <code>false</code> (if <code>Throw</code> is <code>true</code>, an error is thrown instead)</li></ul></li><li>Errors thrown by <code>[[Delete]]</code>, which happens if: <ul><li>The (own) property exists, the property is non-configurable, and the Throw flag is set, i.e. we&#39;re evaluating <code>delete</code> in strict code</li></ul></li></ul><p>The coerced temporary object can be:</p><ul><li>a <code>Boolean</code> instance: no own properties</li><li>a <code>Number</code> instance: no own properties</li><li>a <code>String</code> instance: has <code>length</code> and array indices (inside string length) as own properties, all non-configurable</li></ul><p>Given these, the algorithm can be changed to avoid creation of temporaries entirely:</p><ol><li>If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code></li><li><code>P</code> = <code>ToString(P)</code></li><li>If <code>O</code> is an object, call <code>[[Delete]](O, P, currStrict)</code> and return its result</li><li>Else <code>O</code> is primitive: a. If <code>O</code> is a boolean, return <code>true</code> b. If <code>O</code> is a number, return <code>true</code> c. If <code>O</code> is a string: 1. If <code>P</code> is length or an array index inside the <code>O</code> string length: a. If <code>currStrict</code> is <code>true</code>, throw a <code>TypeError</code> b. Else, return <code>false</code> 2. Else, return <code>true</code> d. Return <code>true</code> (This step should never be reached, as the checks above are comprehensive.)</li></ol><p>Step 4 can be simplified a bit:</p><ol><li>If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code></li><li><code>P</code> = <code>ToString(P)</code></li><li>If <code>O</code> is an object, call <code>[[Delete]](O, P, currStrict)</code> and return its result</li><li>If <code>O</code> is a string: a. If <code>P</code> is length or an array index inside the <code>O</code> string length: 1. If <code>currStrict</code> is <code>true</code>, throw a <code>TypeError</code> 2. Else, return <code>false</code></li><li>Return <code>true</code></li></ol><h2 id="fast-path-for-array-indices" tabindex="-1">Fast path for array indices <a class="header-anchor" href="#fast-path-for-array-indices" aria-label="Permalink to &quot;Fast path for array indices&quot;">​</a></h2><p>It would be straightforward to add a fast path for array indices, but there is no fast path in the current implementation for array index deletion. The index is always string coerced and interned.</p>`,32)]))}const f=o(d,[["render",i]]);export{u as __pageData,f as default};
