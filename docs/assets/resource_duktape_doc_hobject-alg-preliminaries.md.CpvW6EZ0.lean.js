import{_ as o,c as t,a2 as c,o as d}from"./chunks/framework.DPuwY6B9.js";const h=JSON.parse('{"title":"Preliminary algorithm work","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-preliminaries.md","filePath":"resource/duktape/doc/hobject-alg-preliminaries.md","lastUpdated":null}'),r={name:"resource/duktape/doc/hobject-alg-preliminaries.md"};function i(a,e,n,l,s,p){return d(),t("div",null,e[0]||(e[0]=[c(`<h1 id="preliminary-algorithm-work" tabindex="-1">Preliminary algorithm work <a class="header-anchor" href="#preliminary-algorithm-work" aria-label="Permalink to &quot;Preliminary algorithm work&quot;">​</a></h1><p>In this section we look at the internal algorithms and do some preliminary work of restating them by: inlining algorithms, merging algorithms, looking at algorithm behavior with some fixed parameters, etc. Tricky issues of algorithms are also discussed to some extent.</p><p>The purpose of this section is to provide raw material for the sections dealing with actual exposed algorithms.</p><h2 id="canput" tabindex="-1">CanPut <a class="header-anchor" href="#canput" aria-label="Permalink to &quot;CanPut&quot;">​</a></h2><p><code>[[CanPut]]</code> indicates whether a <code>[[Put]]</code> would cause an error or not. An error is possible in the following cases for object <code>O</code>, property <code>P</code>:</p><ul><li><code>O</code> has <code>P</code> as own property, it is a plain property, and <code>[[Writable]]</code> is false</li><li><code>O</code> has <code>P</code> as own property, it is an accessor property, and is missing the <code>[[Set]]</code> function</li><li><code>P</code> is found in <code>O</code>&#39;s prototype chain (not in <code>O</code>), it is a plain property, and either <code>O.[[Extensible]]</code> or property <code>[[Writable]]</code> is false</li><li><code>P</code> is found in <code>O</code>&#39;s prototype chain (not in <code>O</code>), it is an accessor property, and is missing the <code>[[Set]]</code> function</li><li><code>P</code> is not found in <code>O</code>&#39;s prototype chain, and <code>O.[[Extensible]]</code> is false</li></ul><p>The algorithm in E5 Section 8.12.4 deals with the &quot;own property&quot; case first and then looks up the property again from the prototype chain. If a property is found, the only difference is between steps 2.b and 8.a: the <code>[[Extensible]]</code> property of the original object <code>O</code> must be checked if the property is found in an ancestor, as a <code>[[Put]]</code> would actually go into <code>O</code>, extending its set of properties.</p><p>The following simplified (and restated) variant should be equivalent and requires only one prototype chain lookup:</p><ol><li><code>desc</code> = <code>O.[[GetProperty]](P)</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>O.[[Extensible]]</code>.</li><li>If <code>IsAccessorDescriptor(desc)</code>: a. If <code>desc.[[Set]]</code> is <code>undefined</code>, return <code>false</code>. b. Else, return <code>true</code>.</li><li>Else, <code>desc</code> must be a data descriptor: a. (<strong>CHANGED:</strong>) If <code>desc</code> was not found in the original object <code>O</code>, and <code>O.[[Extensible]]</code> is <code>false</code>, return <code>false</code>. b. Return <code>desc.[[Writable]]</code>.</li></ol><p>The step denoted with CHANGED reconciles steps 2.b and 8.a of the original algorithm. The &quot;found in the original object <code>O</code>&quot; part can be implemented in many ways:</p><ul><li>Compare object pointers of original object vs. object where property was found: works if an object occurs at most once in a prototype chain (which should always be the case)</li><li>The prototype chain lookup <code>[[GetProperty]]</code> also returns an &quot;inherited&quot; flag</li></ul><h2 id="getproperty" tabindex="-1">GetProperty <a class="header-anchor" href="#getproperty" aria-label="Permalink to &quot;GetProperty&quot;">​</a></h2><p><code>[[GetProperty]]</code> is a very straightforward wrapper over <code>[[GetOwnProperty]]</code> which follows the prototype chain. Like <code>[[GetOwnProperty]]</code>, it returns a descriptor.</p><p>There is no exotic behavior for <code>[[GetProperty]]</code>, the exotic behaviors only affect <code>[[GetOwnProperty]]</code> which is called during <code>[[GetProperty]]</code>.</p><h3 id="original-algorithm" tabindex="-1">Original algorithm <a class="header-anchor" href="#original-algorithm" aria-label="Permalink to &quot;Original algorithm&quot;">​</a></h3><ol><li>Let <code>prop</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>prop</code> is not <code>undefined</code>, return <code>prop</code>.</li><li>Let <code>proto</code> be the value of the <code>[[Prototype]]</code> internal property of <code>O</code>.</li><li>If <code>proto</code> is <code>null</code>, return <code>undefined</code>.</li><li>Return the result of calling the <code>[[GetProperty]]</code> internal method of <code>proto</code> with argument <code>P</code>.</li></ol><h3 id="eliminating-recursion" tabindex="-1">Eliminating recursion <a class="header-anchor" href="#eliminating-recursion" aria-label="Permalink to &quot;Eliminating recursion&quot;">​</a></h3><p>This is better unwound into a loop (using <code>desc</code> instead of <code>prop</code>, as it is more descriptive):</p><ol><li>Let <code>curr</code> be <code>O</code>.</li><li>While <code>curr</code> is not <code>null</code>: a. Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>. b. If <code>desc</code> is not <code>undefined</code>, return <code>desc</code>. c. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>.</li><li>Return <code>undefined</code>.</li></ol><h3 id="less-nested-form" tabindex="-1">Less nested form <a class="header-anchor" href="#less-nested-form" aria-label="Permalink to &quot;Less nested form&quot;">​</a></h3><p>The following is a less &quot;nested&quot; form (note that <code>curr</code> is guaranteed to be non-null in the first loop):</p><ol><li>Let <code>curr</code> be <code>O</code>.</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is not <code>undefined</code>, return <code>desc</code>.</li><li>Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>.</li><li>If <code>curr</code> is not <code>null</code>, goto NEXT.</li><li>Return <code>undefined</code></li></ol><p>::: note ::: title Note :::</p><p>A maximum prototype chain depth should be imposed as a safeguard against loops. Note that while it should be impossible to create prototype loops with ECMAScript code alone, creating them from C code <em>is</em> possible. :::</p><h3 id="getproperty-with-default-getownproperty-inlined" tabindex="-1">GetProperty with default GetOwnProperty inlined <a class="header-anchor" href="#getproperty-with-default-getownproperty-inlined" aria-label="Permalink to &quot;GetProperty with default GetOwnProperty inlined&quot;">​</a></h3><p><code>[[GetOwnProperty]]</code> is just creating the descriptor from whatever form properties are stored. It has exotic behaviors, so the resulting function is a bit complicated.</p><p>The inlined form for default <code>[[GetOwnProperty]]</code> is essentially:</p><ol><li><code>curr</code> = <code>O</code></li><li><strong>NEXT:</strong> If <code>curr</code> has own property <code>P</code>: a. Let <code>D</code> be a newly created Property Descriptor with no fields. b. Let <code>X</code> be <code>curr</code>&#39;s own property named P. c. If <code>X</code> is a data property, then 1. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. 2. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute. d. Else <code>X</code> is an accessor property, so 1. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. 2. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute. e. Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute. f. Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute. g. Return <code>D</code>.</li><li>Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>.</li><li>If <code>curr</code> is not <code>null</code>, goto NEXT.</li><li>Return <code>undefined</code></li></ol><p>This is a relatively useless form, because exotic behaviors are missing.</p><h3 id="getproperty-with-complete-getownproperty-inlined" tabindex="-1">GetProperty with complete GetOwnProperty inlined <a class="header-anchor" href="#getproperty-with-complete-getownproperty-inlined" aria-label="Permalink to &quot;GetProperty with complete GetOwnProperty inlined&quot;">​</a></h3><p>The following inlines <code>[[GetOwnProperty]]</code> with all exotic behaviors:</p><ol><li><code>curr</code> = <code>O</code></li><li><strong>NEXT:</strong> Let <code>X</code> be <code>curr</code>&#39;s own property named <code>P</code>. If <code>curr</code> doesn&#39;t have an own property with name <code>P</code>: a. If <code>curr</code> is not a <code>String</code> instance, goto NOTFOUND. b. (<code>String</code> object exotic behavior.) Let <code>str</code> be the String value of the <code>[[PrimitiveValue]]</code> internal property of <code>O</code> and <code>len</code> be the number of characters in <code>str</code>. c. If <code>P</code> is <code>&quot;length&quot;</code>: 1. Return a Property Descriptor with the values: - <code>[[Value]]: len</code> (a primitive number) - <code>[[Enumerable]]: false</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> d. If <code>P</code> is an array index (E5 Section 15.4): 1. Let <code>index</code> be <code>ToUint32(P)</code>. 2. If <code>index</code> &lt; <code>len</code>, return a Property Descriptor with the values: - <code>[[Value]]:</code> a primitive string of length 1, containing one character from <code>str</code> at position <code>index</code> (zero based index) - <code>[[Enumerable]]: true</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> e. Goto NOTFOUND.</li><li>Let <code>D</code> be a newly created Property Descriptor filled as follows: a. If <code>X</code> is a data property: 1. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. 2. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute. b. Else <code>X</code> is an accessor property: 1. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. 2. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute. c. For either type of property: 1. Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute. 2. Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute.</li><li>If <code>curr</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Set <code>D.[[Value]]</code> to the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Return <code>D</code>.</li><li><strong>NOTFOUND:</strong> Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>.</li><li>If <code>curr</code> is not <code>null</code>, goto NEXT.</li><li>Return <code>undefined</code></li></ol><p>::: note ::: title Note :::</p><p>This implementation is currently <em>not</em> used. The implementation for <code>[[GetOwnProperty]]</code> is a separate helper. See <code>duk_hobject_props.c</code>, helper functions: <code>get_own_property_desc()</code> and <code>get_property_desc()</code>. :::</p><h2 id="get" tabindex="-1">Get <a class="header-anchor" href="#get" aria-label="Permalink to &quot;Get&quot;">​</a></h2><p><code>[[Get]]</code> is straightforward; it gets a property descriptor with <code>[[GetProperty]]</code> and then coerces it to a value.</p><h2 id="get-with-getproperty-inlined" tabindex="-1">Get with GetProperty inlined <a class="header-anchor" href="#get-with-getproperty-inlined" aria-label="Permalink to &quot;Get with GetProperty inlined&quot;">​</a></h2><p><code>[[Get]]</code> was covered above when discussion exotic behaviors, so we&#39;ll skip discussing it again here.</p><p><code>[[Get]]</code> is essentially a <code>[[GetProperty]]</code> followed by coercion of the descriptor into a value. For a data descriptor, simply return its <code>[[Value]]</code>. For a property accessor, simply call its <code>[[Get]]</code> function. The descriptor does not need to be created at all, as we&#39;re just interested in the final value.</p><p>The following combines both <code>[[GetOwnProperty]]</code> and <code>[[Get]]</code> with exotic behaviors:</p><ol><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li><code>curr</code> = <code>O</code></li><li><strong>NEXT:</strong> Let <code>X</code> be <code>curr</code>&#39;s own property named <code>P</code>. If <code>curr</code> doesn&#39;t have an own property with name <code>P</code>: a. If <code>curr</code> is not a <code>String</code> instance, goto NOTFOUND. b. (<code>String</code> object exotic behavior.) Let <code>str</code> be the String value of the <code>[[PrimitiveValue]]</code> internal property of <code>O</code> and <code>len</code> be the number of characters in <code>str</code>. c. If <code>P</code> is <code>&quot;length&quot;</code>: 1. Return <code>len</code> (a primitive number). (No need to check for arguments object exotic behavior or <code>&quot;caller&quot;</code> property exotic behavior.) d. If <code>P</code> is an array index (E5 Section 15.4): 1. Let <code>index</code> be <code>ToUint32(P)</code>. 2. If <code>index</code> &lt; <code>len</code>: a. Return a primitive string of length 1, containing one character from <code>str</code> at position <code>index</code> (zero based index). (No need to check for arguments object exotic behavior or <code>&quot;caller&quot;</code> property exotic behavior.) e. Goto NOTFOUND.</li><li>If <code>X</code> is a data property: a. Set <code>res</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. b. Goto FOUND1</li><li>Else <code>X</code> is an accessor property: a. Let <code>getter</code> be <code>X</code>&#39;s <code>[[Get]]</code> attribute. b. If <code>getter</code> is <code>undefined</code>: 1. Return <code>undefined</code>. (Note: arguments object exotic behavior for mapped variables cannot apply: if the property is an accessor, it can never be in the arguments object <code>[[ParameterMap]]</code>. Also, the <code>&quot;caller&quot;</code> exotic behavior does not apply, since the result <code>undefined</code> is not a strict mode function. Thus, no &quot;goto FOUND1&quot; here.) c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments. d. Goto FOUND2. (Note: arguments object exotic behavior for mapped variables cannot apply: if the property is an accessor, it can never be in the arguments object <code>[[ParameterMap]]</code>. However, the <code>&quot;caller&quot;</code> exotic behavior might apply, at FOUND2.)</li><li><strong>FOUND1</strong>: If <code>curr</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Set <code>res</code> to the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li><strong>FOUND2</strong>: If <code>O</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li><li><strong>NOTFOUND:</strong> Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>.</li><li>If <code>curr</code> is not <code>null</code>, goto NEXT.</li><li>Return <code>undefined</code>. (Note: no need for exotic behavior checks here; e.g. result is not a strict mode function.)</li></ol><p>::: note ::: title Note :::</p><p>The step 5.c gives the object as the <code>this</code> binding for the getter call. When properties are actually accessed from ECMAScript code, the wrappers (property accessor evaluation, <code>GetValue()</code>) have a different behavior: the primitive (uncoerced) object is given as the <code>this</code> binding. :::</p><h2 id="defineownproperty-callers" tabindex="-1">DefineOwnProperty callers <a class="header-anchor" href="#defineownproperty-callers" aria-label="Permalink to &quot;DefineOwnProperty callers&quot;">​</a></h2><p><code>[[DefineOwnProperty]]</code> is defined in E5 Section 8.12.9. It is a complex algorithm which allows the value and attributes of property <code>P</code> of object <code>O</code> to be changed. It is used for <code>[[Put]]</code> which is performance relevant and should thus be &quot;inlined&quot; to the extent possible (see special case analysis below). It is also used generically when initializing newly created objects etc, which can also use a simplified version.</p><p>Note: <code>[[DefineOwnProperty]]</code> allows some counterintuitive property attributes changes to be made. The callers in the specification are supposed to &quot;guard&quot; against these. For instance:</p><ul><li>A property which is non-configurable but writable <em>can</em> be changed to non-writable (but not vice versa). Non-configurability does not guarantee that changes cannot be made.</li><li>A property which is configurable but not writable can have its value changed by a <code>[[DefineOwnProperty]]</code> call. This is allowed because a caller could simply change the property to writable, change its value, and then change it back to non-writable (this is possible because the property is configurable). The <code>[[Put]]</code> algorithms prevents writing to a non-writable but configurable property with an explicit check, <code>[[CanPut]]</code>.</li></ul><p><code>[[DefineOwnProperty]]</code> is referenced by the following property-related internal algorithms:</p><ul><li><code>FromPropertyDescriptor</code>, E5 Section 8.10.4</li><li><code>[[Put]]</code>, E5 Section 8.12.5</li><li>Array&#39;s exotic <code>[[DefineOwnProperty]]</code> relies on the default one, E5 Section 15.4.5.1</li><li>Argument object&#39;s exotic <code>[[DefineOwnProperty]]</code> relies on the default one, E5 Section 10.6</li></ul><p>It is used less fundamentally in many places, e.g. to initialize values (list probably not complete):</p><ul><li><code>CreateMutableBinding</code>, E5 Section 10.2.1.2.2</li><li>Arguments object setup, E5 Section 10.6</li><li>Array initializer, E5 Section 11.1.4</li><li>Object initializer, E5 Section 11.1.5</li><li>Function object creation, E5 Section 13.2</li><li><code>[[ThrowTypeError]]</code> function object, E5 Section 13.2.3</li><li><code>Object.getOwnPropertyNames</code>, E5 Section 15.2.3.4</li><li><code>Object.defineProperty</code>, E5 Section 15.2.3.6</li><li><code>Object.seal</code>, E5 Section 15.2.3.8</li><li><code>Object.freeze</code>, E5 Section 15.2.3.9</li><li><code>Object.keys</code>, E5 Section 15.2.3.14</li><li><code>Function.prototype.bind</code>, E5 Section 15.3.4.5</li><li><code>Array.prototype.concat</code>, E5 Section 15.4.4.4</li><li><code>Array.prototype.slice</code>, E5 Section 15.4.4.10</li><li><code>Array.prototype.splice</code>, E5 Section 15.4.4.12</li><li><code>Array.prototype.map</code>, E5 Section 15.4.4.19</li><li><code>Array.prototype.filter</code>, E5 Section 15.4.4.20</li><li><code>String.prototype.match</code>, E5 Section 15.5.4.10</li><li><code>String.prototype.split</code>, E5 Section 15.5.4.14</li><li><code>RegExp.prototype.exec</code>, E5 Section 15.10.6.2</li><li><code>JSON.parse</code>, E5 Section 15.12.2</li><li><code>JSON.stringify</code>, E5 Section 15.12.3</li></ul><h2 id="defineownproperty-for-an-existing-property-in-put" tabindex="-1">DefineOwnProperty for an existing property in Put <a class="header-anchor" href="#defineownproperty-for-an-existing-property-in-put" aria-label="Permalink to &quot;DefineOwnProperty for an existing property in Put&quot;">​</a></h2><p>This case arises when a <code>[[Put]]</code> is performed and the property already exists. The property value is updated with a call to <code>[[DefineOwnProperty]]</code> with a property descriptor only containing <code>[[Value]]</code>. See E5 Section 8.12.5, step 3.</p><p>We can assume that:</p><ul><li>The property exists (checked by <code>[[Put]]</code>)</li><li>The property is a data property (checked by <code>[[Put]]</code>)</li><li>The property cannot be non-writable (checked by <code>[[Put]]</code>, using <code>[[CanPut]]</code>)</li><li>The property descriptor is a data descriptor</li><li>The property descriptor is of the form: <code>{ [[Value]]: val }</code></li><li>Because the property exists, the <code>length</code> of an <code>Array</code> object cannot change by a write to an array index; however, a write to <code>&quot;length&quot;</code> may delete array elements</li></ul><p>More specifically, we know that in the <code>[[DefineOwnProperty]]</code> algorithm:</p><ul><li><code>current</code> is not <code>undefined</code></li><li><code>IsGenericDescriptor(current)</code> is <code>false</code></li><li><code>IsDataDescriptor(current)</code> is <code>true</code></li><li><code>IsAccessorDescriptor(current)</code> is <code>false</code></li><li><code>IsGenericDescriptor(Desc)</code> is <code>false</code></li><li><code>IsDataDescriptor(Desc)</code> is <code>true</code></li><li><code>IsAccessorDescriptor(Desc)</code> is <code>false</code></li></ul><p>Taking the <code>[[DefineOwnProperty]]</code> with all exotic behaviors included, using the above assumptions, eliminating any unnecessary steps, cleaning up and clarifying, we get:</p><ol><li>If <code>O</code> is an <code>Array</code> object, and <code>P</code> is <code>&quot;length&quot;</code>, then: a. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. b. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, throw a <code>RangeError</code> exception. Note that this is unconditional (thrown even if <code>Throw</code> is <code>false</code>). c. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a <code>length</code> data property that cannot be deleted or reconfigured. d. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) e. If <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. 4. Return. f. Update the property (<code>&quot;length&quot;</code>) value to <code>newLen</code>. g. Return.</li><li>Set the <code>[[Value]]</code> attribute of the property named <code>P</code> of object <code>O</code> to the value of <code>Desc.[[Value]]</code>. (Since it is side effect free to update the value with the same value, no check for that case is needed.)</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>Desc.[[Value]]</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</li><li>Return <code>true</code>.</li></ol><p>Note that step 1 combines the pre-step and post-step for an <code>Array</code> object <code>length</code> exotic behavior. This is only possible if we know beforehand that the <code>&quot;length&quot;</code> property is writable (so that the write never fails and we always reach the post-step).</p><p>We&#39;ll refine one more time, by eliminating references to <code>Desc</code> and using <code>val</code> to refer to <code>Desc.[[Value]]</code>:</p><ol><li>If <code>O</code> is an <code>Array</code> object, and <code>P</code> is <code>&quot;length&quot;</code>, then: a. Let <code>newLen</code> be <code>ToUint32(val)</code>. b. If <code>newLen</code> is not equal to <code>ToNumber(val)</code>, throw a <code>RangeError</code> exception. Note that this is unconditional (thrown even if <code>Throw</code> is <code>false</code>). c. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a <code>length</code> data property that cannot be deleted or reconfigured. d. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) e. If <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. 4. Return. f. Update the property (<code>&quot;length&quot;</code>) value to <code>newLen</code>. g. Return.</li><li>Set the <code>[[Value]]</code> attribute of the property named <code>P</code> of object <code>O</code> to <code>val</code>. (Since it is side effect free to update the value with the same value, no check for that case is needed.)</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>val</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</li><li>Return <code>true</code>.</li></ol><p>We&#39;ll need this variant later when creating an inlined version for the full property write processing.</p><h2 id="defineownproperty-for-a-non-existent-property-in-put" tabindex="-1">DefineOwnProperty for a non-existent property in Put <a class="header-anchor" href="#defineownproperty-for-a-non-existent-property-in-put" aria-label="Permalink to &quot;DefineOwnProperty for a non-existent property in Put&quot;">​</a></h2><p>This case arises when a <code>[[Put]]</code> is performed and the property does not already exist as an &quot;own property&quot;, and no setter in an ancestor captured the write. The property is created with a call to <code>[[DefineOwnProperty]]</code> with a property descriptor containing a <code>[[Value]]</code>, and the following set to <code>true</code>: <code>[[Writable]]</code>, <code>[[Enumerable]]</code>, <code>[[Configurable]]</code>. See E5 Section 8.12.5, step 6.</p><p>We can assume that:</p><ul><li>The property does not exist (checked by <code>[[Put]]</code>)</li><li>The object is extensible (checked by <code>[[Put]]</code>)</li><li>The property descriptor is a data descriptor</li><li>The property descriptor has the fields: <ul><li><code>[[Value]]: val</code></li><li><code>[[Writable]]: true</code></li><li><code>[[Enumerable]]: true</code></li><li><code>[[Configurable]]: true</code></li></ul></li><li>If the object is an <code>Array</code>, the property name <code>P</code> cannot be <code>&quot;length&quot;</code> (as that would exist)</li></ul><p>More specifically, we know that in the <code>[[DefineOwnProperty]]</code> algorithm:</p><ul><li><code>current</code> is <code>undefined</code></li></ul><p>Taking the <code>[[DefineOwnProperty]]</code> with all exotic behaviors included, using the above assumptions, and then eliminating any unnecessary steps, cleaning up and clarifying, we get:</p><ol><li><p>If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. Goto REJECT if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>.</p></li><li><p>Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>.</p></li><li><p>If <code>O</code> is an <code>Array</code> object, <code>P</code> is an array index and <code>index</code> &gt;= <code>oldLen</code>: a. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds, because we&#39;ve checked in the pre-step that the <code>&quot;length&quot;</code> is writable, and since <code>P</code> is an array index property, the length must still be writable here.</p></li><li><p>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>Desc.[[Value]]</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</p></li><li><p>Return <code>true</code>.</p></li><li></li></ol><pre><code>**REJECT**:

:   If \`Throw\` is \`true\`, then throw a \`TypeError\` exception,
    otherwise return \`false\`.
</code></pre><p>This can be refined further by noticing that the arguments object exotic behavior cannot be triggered if the property does not exist: all magically bound properties exist initially, and if they are deleted, the magic variable binding is also deleted.</p><p>We can also change the order of property creation and the postponed array <code>length</code> write because they are both guaranteed to succeed.</p><p>So, we get:</p><ol><li><p>If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. If <code>index</code> &gt;= <code>oldLen</code>: 1. Goto REJECT <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. 2. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds.</p></li><li><p>Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>.</p></li><li><p>Return <code>true</code>.</p></li><li></li></ol><pre><code>**REJECT**:

:   If \`Throw\` is \`true\`, then throw a \`TypeError\` exception,
    otherwise return \`false\`.
</code></pre><p>We&#39;ll refine one more time, by eliminating references to <code>Desc</code> and using <code>val</code> to refer to <code>Desc.[[Value]]</code>:</p><ol><li>If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. If <code>index</code> &gt;= <code>oldLen</code>: 1. Goto REJECT <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. 2. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds.</li><li>Create an own data property named <code>P</code> of object <code>O</code> whose attributes are: <ul><li><code>[[Value]]: val</code></li><li><code>[[Writable]]: true</code></li><li><code>[[Enumerable]]: true</code></li><li><code>[[Configurable]]: true</code></li></ul></li><li>Return <code>true</code>.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return <code>false</code>.</li></ol><p>Notes:</p><ul><li>If step 2 fails due to an out-of-memory or other internal error, we may have updated <code>length</code> already. So, switching steps 2 and 1.d.2 might be prudent (the check in step 1.d.1 <em>must</em> be executed before writing anything though).</li></ul><p>We&#39;ll need this variant later when creating an inlined version for the full property write processing.</p><h2 id="defineownproperty-for-some-internal-object-initialization" tabindex="-1">DefineOwnProperty for (some) internal object initialization <a class="header-anchor" href="#defineownproperty-for-some-internal-object-initialization" aria-label="Permalink to &quot;DefineOwnProperty for (some) internal object initialization&quot;">​</a></h2><p>This case occurs when internal objects or results objects are created by the implementation. We can&#39;t simply use a normal property write internally, because we need to set the property attributes to whatever combination is required by the context (many different property attribute variants are used throughout the specification).</p><p>Because user code has not had any access to the object, we can narrow down the possibilities a great deal. Here we assume that:</p><ul><li>Object is extensible</li><li>Property does not exist</li><li>Property does not have exotic behavior and is not virtual</li><li>Property descriptor is a data descriptor, which is fully populated</li></ul><p>With these assumptions, eliminating any unnecessary steps, the algorithm is simply:</p><ol><li>Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>.</li><li>Return <code>true</code>.</li></ol><p>This doesn&#39;t cover all the initialization cases, but simply illustraes that very constrained cases are very simple.</p><h2 id="put" tabindex="-1">Put <a class="header-anchor" href="#put" aria-label="Permalink to &quot;Put&quot;">​</a></h2><p>&quot;Reject&quot; below is shorthand for:</p><ul><li>If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception; else return.</li></ul><h3 id="original-algorithm-1" tabindex="-1">Original algorithm <a class="header-anchor" href="#original-algorithm-1" aria-label="Permalink to &quot;Original algorithm&quot;">​</a></h3><p>For object <code>O</code>, property <code>P</code>, and value <code>V</code>:</p><ol><li>If the result of calling the <code>[[CanPut]]</code> internal method of <code>O</code> with argument <code>P</code> is false, then a. If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception. b. Else return.</li><li>Let <code>ownDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with argument <code>P</code>.</li><li>If <code>IsDataDescriptor(ownDesc)</code> is <code>true</code>, then a. Let <code>valueDesc</code> be the Property Descriptor <code>{[[Value]]: V}</code>. b. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>valueDesc</code>, and <code>Throw</code> as arguments. c. Return.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with argument <code>P</code>. This may be either an own or inherited accessor property descriptor or an inherited data property descriptor.</li><li>If <code>IsAccessorDescriptor(desc)</code> is <code>true</code>, then a. Let <code>setter</code> be <code>desc.[[Set]]</code> which cannot be <code>undefined</code>. b. Call the <code>[[Call]]</code> internal method of setter providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument.</li><li>Else, create a named data property named <code>P</code> on object <code>O</code> as follows a. Let <code>newDesc</code> be the Property Descriptor: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> b. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>newDesc</code>, and <code>Throw</code> as arguments.</li><li>Return.</li></ol><p>Notes:</p><ul><li>Step 5.a: <code>setter</code> cannot be <code>undefined</code> at this point because <code>[[CanPut]]</code> has checked it (and throws an exception if it is <code>undefined</code>).</li></ul><h3 id="minimizing-prototype-traversal" tabindex="-1">Minimizing prototype traversal <a class="header-anchor" href="#minimizing-prototype-traversal" aria-label="Permalink to &quot;Minimizing prototype traversal&quot;">​</a></h3><p>The <code>ownDesc</code> check is necessary because a <code>[[Put]]</code> on an existing own property is a change of value; a <code>[[Put]]</code> on an inherited plain property is an addition of a new property on the <em>original</em> target object (not the ancestor where the inherited property was found).</p><p>To minimize prototype traversal, these can be combined as follows (with some cleanup):</p><ol><li>If the result of calling the <code>[[CanPut]]</code> internal method of <code>O</code> with argument <code>P</code> is false, then Reject.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with argument <code>P</code>. (Note: here we assume that we also get to know whether the property was found in <code>O</code> or in its ancestor.)</li><li>If <code>IsAccessorDescriptor(desc)</code> is <code>true</code>, then: a. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: <code>desc.[[Set]]</code> cannot be <code>undefined</code>, as this is checked by <code>[[CanPut]]</code>.)</li><li>Else if <code>desc</code> was found in <code>O</code> directly (as an &quot;own data property&quot;), then: a. Let <code>valueDesc</code> be the Property Descriptor <code>{[[Value]]: V}</code>. b. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>valueDesc</code>, and <code>Throw</code> as arguments.</li><li>Else <code>desc</code> is an inherited data property or <code>undefined</code>, then: a. Let <code>newDesc</code> be the Property Descriptor: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> b. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>newDesc</code>, and <code>Throw</code> as arguments.</li><li>Return.</li></ol><p>This still travels the prototype chain twice: once for <code>[[CanPut]]</code>, and a second time for the actual <code>[[Put]]</code>. <code>[[CanPut]]</code> can be inlined quite easily, as it does very similar checks as <code>[[Put]]</code>.</p><p>The result is:</p><ol><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with argument <code>P</code>. (Note: here we assume that we also get to know whether the property was found in <code>O</code> or in its ancestor.)</li><li>If <code>IsAccessorDescriptor(desc)</code> is <code>true</code>, then: a. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument.</li><li>Else if <code>desc</code> is an inherited (data) property, then: a. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. b. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. c. Let <code>newDesc</code> be the Property Descriptor: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> d. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>newDesc</code>, and <code>Throw</code> as arguments.</li><li>Else if <code>desc</code> was not found (is <code>undefined</code>): a. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. b. Let <code>newDesc</code> be the Property Descriptor: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> c. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>newDesc</code>, and <code>Throw</code> as arguments.</li><li>Else <code>desc</code> was found in <code>O</code> directly (as an &quot;own data property&quot;), then: a. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. b. Let <code>valueDesc</code> be the Property Descriptor <code>{[[Value]]: V}</code>. c. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>valueDesc</code>, and <code>Throw</code> as arguments.</li><li>Return.</li></ol><p>The above can be further refined to (making also the modification required to <code>[[GetProperty]]</code> explicit):</p><ol><li>Let <code>desc</code> and <code>inherited</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with argument <code>P</code>.</li><li>If <code>IsAccessorDescriptor(desc)</code> is <code>true</code>, then: a. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument.</li><li>Else if <code>desc</code> is not <code>undefined</code> and <code>inherited</code> is <code>false</code> (own data property), then: a. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. b. Let <code>valueDesc</code> be the Property Descriptor <code>{[[Value]]: V}</code>. c. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>valueDesc</code>, and <code>Throw</code> as arguments.</li><li>Else <code>desc</code> is an inherited (data) property or <code>undefined</code>: a. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. b. If <code>desc</code> is not <code>undefined</code> and <code>desc.[[Writable]]</code> is <code>false</code>, Reject. (In other words: <code>desc</code> was inherited and is non-writable.) c. Let <code>newDesc</code> be the Property Descriptor: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> d. Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> passing <code>P</code>, <code>newDesc</code>, and <code>Throw</code> as arguments.</li><li>Return.</li></ol><p>This can be further improved in actual C code.</p><h3 id="inlining-getproperty" tabindex="-1">Inlining GetProperty <a class="header-anchor" href="#inlining-getproperty" aria-label="Permalink to &quot;Inlining GetProperty&quot;">​</a></h3><p>When actually implementing, it&#39;s useful to &quot;inline&quot; the <code>[[GetProperty]]</code> loop, which changes the code structure quite a bit:</p><ol><li>Set <code>curr</code> to <code>O</code>.</li><li>While <code>curr</code> !== <code>null</code>: a. If <code>O</code> does not have own property <code>P</code>: 1. Set <code>curr</code> to <code>curr.[[Prototype]]</code> 2. Continue (while loop) b. Let <code>desc</code> be the descriptor for own property <code>P</code> c. If <code>IsDataDescriptor(desc)</code>: 1. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) a. If <code>O.[[Extensible]</code> is <code>false</code>, Reject. b. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. c. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> d. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. 2. Else (property is an own data property): a. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. b. Let <code>valueDesc</code> be <code>{ [[Value]]: V }</code>. c. Call <code>O.[[DefineOwnProperty]](P, valueDesc, Throw)</code>. d. Else (property is an accessor): 1. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. 2. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. e. Return.</li><li>Property was not found in the prototype chain: a. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. b. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> c. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>.</li></ol><h3 id="less-nested-form-1" tabindex="-1">Less nested form <a class="header-anchor" href="#less-nested-form-1" aria-label="Permalink to &quot;Less nested form&quot;">​</a></h3><p>The following is a less &quot;nested&quot; form (note that <code>curr</code> is guaranteed to be non-null in the first loop):</p><ol><li>Let <code>curr</code> be <code>O</code>.</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. d. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> e. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. f. Return.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, Reject. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 3. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> 4. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. b. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 2. Let <code>valueDesc</code> be <code>{ [[Value]]: V }</code>. 3. Call <code>O.[[DefineOwnProperty]](P, valueDesc, Throw)</code>.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument.</li><li>Return.</li></ol><h3 id="note-about-putvalue" tabindex="-1">Note about PutValue <a class="header-anchor" href="#note-about-putvalue" aria-label="Permalink to &quot;Note about PutValue&quot;">​</a></h3><p>Note that <code>PutValue()</code> has a <code>[[Put]]</code> variant with two exotic behaviors related to object coercion. The above algorithm does not take those into account.</p><h2 id="property-descriptor-algorithms" tabindex="-1">Property descriptor algorithms <a class="header-anchor" href="#property-descriptor-algorithms" aria-label="Permalink to &quot;Property descriptor algorithms&quot;">​</a></h2><p>E5 Section 8.10 describes descriptor related algorithms:</p><ul><li><code>IsAccessorDescriptor(desc)</code>: <code>true</code>, if <code>desc</code> contains <em>either</em><code>[[Set]]</code> or <code>[[Get]]</code></li><li><code>IsDataDescriptor(desc)</code>: <code>true</code>, if <code>desc</code> contains <em>either</em><code>[[Value]]</code> or <code>[[Writable]]</code></li><li><code>IsGenericDescriptor(desc)</code>: <code>true</code> if both <code>IsAccessorDescriptor(desc)</code> and <code>IsGenericDescriptor</code> are <code>false</code>; concretely: <ul><li><code>desc</code> contains none of the following: <code>[[Set]]</code>, <code>[[Get]]</code>, <code>[[Value]]</code>, <code>[[Writable]]</code></li><li><code>desc</code> may contain: <code>[[Enumerable]]</code>, <code>[[Configurable]]</code></li></ul></li></ul><p>A property descriptor may be fully populated or not. If fully populated, it is either a data descriptor or an access descriptor, not a generic descriptor.</p><p>A property descriptor may not be both a data descriptor and access descriptor (this is stated in E5 Section 8.10). However, an argument to e.g. <code>Object.defineProperty()</code> may naturally contain e.g. <code>&quot;set&quot;</code> and <code>&quot;value&quot;</code> keys. In this case:</p><ul><li><code>defineProperty()</code> uses <code>ToPropertyDescriptor()</code> to convert the ECMAScript object into an internal property descriptor</li><li><code>ToPropertyDescriptor()</code> creates a property descriptor and throws a <code>TypeError</code> if the descriptor contains conflicting fields</li></ul><p><code>ToPropertyDescriptor()</code> also coerces the values in its argument ECMAScript object (e.g. it uses <code>ToBoolean()</code> for the flags). The behavior of <code>ToPropertyDescriptor()</code> is probably easiest to &quot;inline&quot; into wherever it is needed. The E5 specification refers to <code>ToPropertyDescriptor</code> only in <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code>.</p><p>The current implementation does not have partial internal property descriptors (internal property value and attributes are always fully populated).</p><h2 id="topropertydescriptor" tabindex="-1">ToPropertyDescriptor <a class="header-anchor" href="#topropertydescriptor" aria-label="Permalink to &quot;ToPropertyDescriptor&quot;">​</a></h2><p>The <code>ToPropertyDescriptor()</code> algorithm is specified in E5 Section 8.10.5 and is as follows:</p><ol><li>If <code>Type(Obj)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>desc</code> be the result of creating a new Property Descriptor that initially has no fields.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;enumerable&quot;</code> is <code>true</code>, then: a. Let <code>enum</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with <code>&quot;enumerable&quot;</code>. b. Set the <code>[[Enumerable]]</code> field of <code>desc</code> to <code>ToBoolean(enum)</code>.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;configurable&quot;</code> is <code>true</code>, then: a. Let <code>conf</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with argument <code>&quot;configurable&quot;</code>. b. Set the <code>[[Configurable]]</code> field of <code>desc</code> to <code>ToBoolean(conf)</code>.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;value&quot;</code> is <code>true</code>, then: a. Let <code>value</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with argument <code>&quot;value&quot;</code>. b. Set the <code>[[Value]]</code> field of <code>desc</code> to <code>value</code>.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;writable&quot;</code> is <code>true</code>, then: a. Let <code>writable</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with argument <code>&quot;writable&quot;</code>. b. Set the <code>[[Writable]]</code> field of <code>desc</code> to <code>ToBoolean(writable)</code>.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;get&quot;</code> is <code>true</code>, then: a. Let <code>getter</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with argument <code>&quot;get&quot;</code>. b. If <code>IsCallable(getter)</code> is <code>false</code> and <code>getter</code> is not <code>undefined</code>, then throw a <code>TypeError</code> exception. c. Set the <code>[[Get]]</code> field of <code>desc</code> to <code>getter</code>.</li><li>If the result of calling the <code>[[HasProperty]]</code> internal method of <code>Obj</code> with argument <code>&quot;set&quot;</code> is <code>true</code>, then: a. Let <code>setter</code> be the result of calling the <code>[[Get]]</code> internal method of <code>Obj</code> with argument <code>&quot;set&quot;</code>. b. If <code>IsCallable(setter)</code> is <code>false</code> and <code>setter</code> is not <code>undefined</code>, then throw a TypeError exception. c. Set the <code>[[Set]]</code> field of <code>desc</code> to <code>setter</code>.</li><li>If either <code>desc.[[Get]]</code> or <code>desc.[[Set]]</code> are present, then: a. If either <code>desc.[[Value]]</code> or <code>desc.[[Writable]]</code> are present, then throw a <code>TypeError</code> exception.</li><li>Return <code>desc</code>.</li></ol><p>Notes:</p><ul><li>Since <code>[[Get]]</code> is used to read the descriptor value fields, they can be inherited from a parent object, and they can also be accessors.</li><li>Setter/getter values must be either callable or <code>undefined</code> if they are present. In particular, <code>null</code> is not an allowed value.</li><li>Any call to <code>[[Get]]</code> may cause an exception (e.g. if the property is an accessor with a throwing getter). In addition, there are explicit exceptions for object type check and setter/getter check. The order of checking and coercion thus matters, at least if the errors thrown have a message indicating the failing check. All the exceptions are of the same type (<code>TypeError</code>), so a chance in ordering is not strictly a compliance issue (there are no guaranteed error messages).</li><li><code>ToBoolean()</code> has no side effects and is guaranteed to succeed.</li></ul><p>The algorithm in the specification is expressed quite verbosely; the following is a reformulation with less text, the target object has also been renamed to <code>O</code>:</p><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>desc</code> be a new, empty Property Descriptor.</li><li>If <code>O.[[HasProperty]](&quot;enumerable&quot;)</code> === <code>true</code>, then set <code>desc.[[Enumerable]]</code> to <code>ToBoolean(O.[[Get]](&quot;enumerable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;configurable&quot;)</code> === <code>true</code>, then set <code>desc.[[Configurable]]</code> to <code>ToBoolean(O.[[Get]](&quot;configurable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;value&quot;)</code> === <code>true</code>, then set <code>desc.[[Value]]</code> to <code>O.[[Get]](&quot;value&quot;)</code>.</li><li>If <code>O.[[HasProperty]](&quot;writable&quot;)</code> === <code>true</code>, then set <code>desc.[[Writable]]</code> to <code>ToBoolean(O.[[Get]](&quot;writable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;get&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Get]]</code> to <code>O.[[Get]](&quot;get&quot;)</code>. b. If <code>desc.[[Get]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Get]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If <code>O.[[HasProperty]](&quot;set&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Set]]</code> to <code>O.[[Get]](&quot;set&quot;)</code>. b. If <code>desc.[[Set]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Set]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If either <code>desc.[[Get]]</code> or <code>desc.[[Set]]</code> are present, then: a. If either <code>desc.[[Value]]</code> or <code>desc.[[Writable]]</code> are present, then throw a <code>TypeError</code> exception.</li><li>Return <code>desc</code>.</li></ol><h2 id="normalizepropertydescriptor" tabindex="-1">NormalizePropertyDescriptor <a class="header-anchor" href="#normalizepropertydescriptor" aria-label="Permalink to &quot;NormalizePropertyDescriptor&quot;">​</a></h2><p>This algorithm is not defined in the E5 specification, but is used as an internal helper for implementing <code>Object.defineProperties()</code> and <code>Object.defineProperty()</code>.</p><p>The algorithm is a variant of <code>ToPropertyDescriptor()</code> which, instead of an internal descriptor, outputs an equivalent ECMAScript property descriptor which has been fully validated, and contains only &quot;own&quot; data properties. If the resulting ECMAScript object, <code>desc</code>, is later given to <code>ToPropertyDescriptor()</code>:</p><ul><li>The call cannot fail.</li><li>The call will yield the same internal descriptor as if given the original object.</li><li>There can be no user visible side effects, because <code>desc</code> only contains plain (own) values.</li></ul><p>For instance, if the input property descriptor were:</p><pre><code>{
  get value() { return &quot;test&quot;; },
  writable: 0.0,
  configurable: &quot;nonempty&quot;,
  enumerable: new Date(),
  additional: &quot;ignored&quot;   // ignored, not relevant to a descriptor
}
</code></pre><p>the normalized descriptor would be:</p><pre><code>{
  value: &quot;test&quot;,
  writable: false,
  configurable: true,
  enumerable: true
}
</code></pre><p>(The example doesn&#39;t illustrate the fact that inherited properties are converted to &quot;own&quot; properties.)</p><p>The algorithm is as follows:</p><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>desc</code> be a new, empty Object.</li><li>If <code>O.[[HasProperty]](&quot;enumerable&quot;)</code> === <code>true</code>, then call <code>desc.[[Put]]</code> with the arguments <code>&quot;enumerable&quot;</code>, <code>ToBoolean(O.[[Get]](&quot;enumerable&quot;))</code> and <code>true</code>.</li><li>If <code>O.[[HasProperty]](&quot;configurable&quot;)</code> === <code>true</code>, then call <code>desc.[[Put]]</code> with the arguments <code>&quot;configurable&quot;</code>, <code>ToBoolean(O.[[Get]](&quot;configurable&quot;))</code> and <code>true</code>.</li><li>If <code>O.[[HasProperty]](&quot;value&quot;)</code> === <code>true</code>, then call <code>desc.[[Put]]</code> with the arguments <code>&quot;value&quot;</code>, <code>O.[[Get]](&quot;value&quot;)</code> and <code>true</code>.</li><li>If <code>O.[[HasProperty]](&quot;writable&quot;)</code> === <code>true</code>, then call <code>desc.[[Put]]</code> with the arguments <code>&quot;writable&quot;</code>, <code>ToBoolean(O.[[Get]](&quot;writable&quot;))</code> and <code>true</code>.</li><li>If <code>O.[[HasProperty]](&quot;get&quot;)</code> === <code>true</code>, then: a. Let <code>getter</code> be <code>O.[[Get]](&quot;get&quot;)</code>. b. If <code>getter</code> !== <code>undefined</code> and <code>IsCallable(getter)</code> === <code>false</code>, then throw a <code>TypeError</code> exception. c. Call <code>desc.[[Put]]</code> with the arguments <code>&quot;get&quot;</code>, <code>getter</code> and <code>true</code>.</li><li>If <code>O.[[HasProperty]](&quot;set&quot;)</code> === <code>true</code>, then: a. Let <code>setter</code> be <code>O.[[Get]](&quot;set&quot;)</code>. b. If <code>setter</code> !== <code>undefined</code> and <code>IsCallable(setter)</code> === <code>false</code>, then throw a <code>TypeError</code> exception. c. Call <code>desc.[[Put]]</code> with the arguments <code>&quot;set&quot;</code>, <code>setter</code> and <code>true</code>.</li><li>Validation: a. Let <code>g</code> be <code>desc.[[HasProperty]](&quot;get&quot;)</code>. b. Let <code>s</code> be <code>desc.[[HasProperty]](&quot;set&quot;)</code>. c. Let <code>v</code> be <code>desc.[[HasProperty]](&quot;value&quot;)</code>. d. Let <code>w</code> be <code>desc.[[HasProperty]](&quot;writable&quot;)</code>. e. If <code>(g || s) &amp;&amp; (v || w)</code> then throw a <code>TypeError</code> exception.</li><li>Return <code>desc</code>.</li></ol><p>Notes:</p><ul><li>The third argument to <code>desc.[[Put]]</code> is the <code>Throw</code> flag. The value is irrelevant as the <code>[[Put]]</code> calls cannot fail.</li></ul>`,143)]))}const f=o(r,[["render",i]]);export{h as __pageData,f as default};
