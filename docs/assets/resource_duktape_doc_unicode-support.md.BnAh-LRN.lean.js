import{_ as a,c as t,a2 as o,o as r}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"Unicode support","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/unicode-support.md","filePath":"resource/duktape/doc/unicode-support.md","lastUpdated":null}'),i={name:"resource/duktape/doc/unicode-support.md"};function n(s,e,l,c,p,d){return r(),t("div",null,e[0]||(e[0]=[o(`<h1 id="unicode-support" tabindex="-1">Unicode support <a class="header-anchor" href="#unicode-support" aria-label="Permalink to &quot;Unicode support&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>ECMAScript E5 requires quite extensive Unicode support, which is difficult to implement in a very compact fashion. The subsections below discuss Unicode handling in various parts of the E5 standard. Below, the terms &quot;character&quot; and &quot;codepoint&quot; are used interchangeably.</p><p>The general principles for implementation are:</p><ul><li>Operations on ASCII characters and ASCII strings should have a fast path which avoids expensive scanning of conversion tables etc.</li><li>Simple run-time operations on non-ASCII characters like string concatenation, character lookups etc, should be reasonably fast (e.g., avoid a scan of Unicode character information ranges).</li><li>Complex run-time operations on non-ASCII characters like case conversion can have a performance penalty in exchange for small size.</li><li>Compile-time operations on non-ASCII characters can have a performance penalty in exchange for small size.</li></ul><p>Handling Unicode case conversion, character classes, etc. in a compact code size is bit challenging. The current solution is to fast path ASCII characters and to use a bit-packed format for encoding case conversion rules (e.g. range mappings). The rules are created by build-time Python scripts (see <code>tools/</code> directory) and decoded by run-time code such as the parser with the help of <code>duk_bitdecoder_ctx</code> and <code>duk_bd_decode()</code>.</p><p>::: note ::: title Note :::</p><p>There are many Unicode specifications, and I&#39;m not sure which ones apply to E5. For instance, which specification governs the &#39;end of word&#39; behavior for the Final_Sigma context? Is it #29 or something else? :::</p><p>Useful background information:</p><ul><li>Unicode Standard Annex #44: UNICODE CHARACTER DATABASE: <a href="http://unicode.org/reports/tr44/#Casemapping" target="_blank" rel="noreferrer">http://unicode.org/reports/tr44/#Casemapping</a></li><li>CLDR - Unicode Common Locale Data Repository: <a href="http://cldr.unicode.org/" target="_blank" rel="noreferrer">http://cldr.unicode.org/</a></li><li>Unicode Technical Standard #35: UNICODE LOCALE DATA MARKUP LANGUAGE (LDML): <a href="http://www.unicode.org/reports/tr35/tr35-21.html" target="_blank" rel="noreferrer">http://www.unicode.org/reports/tr35/tr35-21.html</a></li><li>Unicode Standard Annex #29: UNICODE TEXT SEGMENTATION: <a href="http://www.unicode.org/reports/tr29/" target="_blank" rel="noreferrer">http://www.unicode.org/reports/tr29/</a></li></ul><p>Unicode data:</p><ul><li><a href="http://unicode.org/Public/UNIDATA/" target="_blank" rel="noreferrer">http://unicode.org/Public/UNIDATA/</a></li><li>UnicodeData.txt: <a href="http://unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="noreferrer">http://unicode.org/Public/UNIDATA/UnicodeData.txt</a></li><li>SpecialCasing.txt: <a href="http://unicode.org/Public/UNIDATA/SpecialCasing.txt" target="_blank" rel="noreferrer">http://unicode.org/Public/UNIDATA/SpecialCasing.txt</a></li></ul><h2 id="source-text" tabindex="-1">Source text <a class="header-anchor" href="#source-text" aria-label="Permalink to &quot;Source text&quot;">​</a></h2><p>The <code>IdentifierStart</code> and <code>IdentifierPart</code> codepoint sets are rather complex. They are currently encoded into about 1.5 kilobytes of bit-packed match data generated by configure tooling.</p><h2 id="regular-expression" tabindex="-1">Regular expression <a class="header-anchor" href="#regular-expression" aria-label="Permalink to &quot;Regular expression&quot;">​</a></h2><p>The <code>Canonicalize()</code> abstract operation described in E5 Section 15.10.2.8 shares the case conversion of <code>String.prototype.toUpperCase()</code> with a few exceptions. The conversion tables can be shared so no additional tables are needed.</p><h2 id="string-case-conversion" tabindex="-1">String case conversion <a class="header-anchor" href="#string-case-conversion" aria-label="Permalink to &quot;String case conversion&quot;">​</a></h2><p>ECMAScript E5 requires case conversion for 16-bit Unicode characters with the <code>String.prototype</code> functions <code>toLowerCase()</code>, <code>toLocaleLowerCase()</code>, <code>toUpperCase()</code>, and <code>toLocaleUpperCase()</code>, see E5 Sections 15.5.4.16 to 15.5.4.19. Titlecase conversion is not required by ECMAScript E5. Regular expression abstract <code>Canonicalize()</code> operation also borrows the case conversion rules (though only for 1:1 conversions), see E5 Section 15.10.2.8.</p><p>Unicode data files describe case conversion rules in two parts:</p><ol><li><code>UnicodeData.txt</code> describes simple 1:1 mappings for lowercase, uppercase, and titlecase. The titlecase mapping, if missing, defaults to uppercase mapping.</li><li><code>SpecialCasing.txt</code> describes complex 1:many mappings for case conversion, which are also required by E5. These mappings may be locale sensitive (e.g. apply only to a certain language) and/or context sensitive (e.g. apply only if a character is preceded or followed by certain codepoints).</li></ol><p>UnicodeData.txt lists all Unicode codepoints and optionally gives case conversion rules for each. Titlecase conversion defaults to uppercase conversion, and if no conversion is given, the character is assumed to remain the same unless SpecialCasing.txt has an overriding rule. The actual case conversion rules are not random, but in many cases continuous ranges are shifted to another position in the codepoint space; the ranges may be fully continuous or have a &quot;skip&quot;, e.g. apply to every other character.</p><p>SpecialCasing.txt provides additional rules particularly for handling cases where the case conversion is not 1:1. For instance, &quot;ß&quot; converted to uppercase is &quot;SS&quot;. There are slightly over 100 such rules, almost entirely for uppercase and titlecase conversion. The special casing rules can convert an input codepoint into 1-3 result codepoints (the ligature U+FB03 uppercases to &quot;FFI&quot;, for instance). Some special casing rules are context and/or locale sensitive. <em>Context sensitivity</em> means that a rule only applies when a codepoint is (or is not) surrounded by certain other codepoints, which means that characters cannot be case converted individually. <em>Locale sensitivity</em> means that a rule might only apply for a certain language.</p><p>The configure tooling reads in UnicodeData.txt and SpecialCasing.txt, extracts the appropriate case conversion rules, scans the conversion rules to generate a compact rules database (really just a list of rules), and encodes the rules into a bit packed format. The bit packed rule format has been developed experimentally to minimize data and code space, by looking at the case conversion data and first detecting simple rules (ranges which are either continuous or have a certain &quot;skip&quot;), and then looking at what remains.</p><p>Currently the encoded format consists of three parts:</p><ol><li>range mappings with a &quot;skip&quot; of 1...6;</li><li>simple 1:1 character mappings which are not covered by the range rules;</li><li>complex 1:n character mappings.</li></ol><p>There&#39;s probably some room for improvement in optimizing the encoding further; currently it takes almost 2 KiB for uppercase and lowercase rules combined.</p><p>::: note ::: title Note :::</p><p>Context or locale specific rules are not processed now. This violates E5 requirements for both context and locale support. :::</p><p>See also:</p><ul><li><a href="http://www.unicode.org/faq/casemap_charprop.html" target="_blank" rel="noreferrer">http://www.unicode.org/faq/casemap_charprop.html</a>.</li><li><code>misc/CaseConversion.java</code> which allows easy testing of what Java does</li></ul><h2 id="context-and-locale-sensitive-rules" tabindex="-1">Context and locale sensitive rules <a class="header-anchor" href="#context-and-locale-sensitive-rules" aria-label="Permalink to &quot;Context and locale sensitive rules&quot;">​</a></h2><p>The following context and locale sensitive rules exist in SpecialCasing.txt with md5sum of 5cea3d079e2b6c6c3babb0726e47e1db.</p><p>Useful background:</p><ul><li>Unicode Standard Annex #44: UNICODE CHARACTER DATABASE, Section 5.6: <a href="http://unicode.org/reports/tr44/#Casemapping" target="_blank" rel="noreferrer">http://unicode.org/reports/tr44/#Casemapping</a><ul><li>Clarifies that contexts are not formal character properties</li></ul></li><li>CLDR - Unicode Common Locale Data Repository: <a href="http://cldr.unicode.org/" target="_blank" rel="noreferrer">http://cldr.unicode.org/</a></li><li><a href="http://unicode.org/reports/tr44/#General_Category_Values" target="_blank" rel="noreferrer">http://unicode.org/reports/tr44/#General_Category_Values</a></li></ul><h3 id="final-sigma-all-languages" tabindex="-1">Final sigma (all languages) <a class="header-anchor" href="#final-sigma-all-languages" aria-label="Permalink to &quot;Final sigma (all languages)&quot;">​</a></h3><pre><code># Special case for final form of sigma

03A3; 03C2; 03A3; 03A3; Final_Sigma; # GREEK CAPITAL LETTER SIGMA
</code></pre><p>The lowercase conversion of U+03A3: GREEK CAPITAL LETTER SIGMA depends on context as follows:</p><ul><li>Final_Sigma: lowercase is U+03C2: GREEK SMALL LETTER FINAL SIGMA</li><li>Otherwise: lowercase is U+03C3: GREEK SMALL LETTER SIGMA</li></ul><p>Other conversions (uppercase or titlecase conversions, or lowercase conversions of other sigma characters) are not context sensitive. In particular, codepoints U+03C2 and U+03C3 lowercase to themselves.</p><p>What is the definition for &quot;Final_Sigma&quot;? Not quite sure, see:</p><ul><li><a href="http://www.unicode.org/faq/greek.html#5" target="_blank" rel="noreferrer">http://www.unicode.org/faq/greek.html#5</a></li><li>&quot;Unicode demystified&quot; link below seems to indicate that: <ul><li>Let p = previous codepoint (if exists)</li><li>Let n = next codepoint (if exists)</li><li>Then final_sigma = (p exists) and (p is a letter) and ((n does not exist) or (n is not a letter))</li><li>The meaning of a &quot;letter&quot; is not clear</li></ul></li></ul><p>See also:</p><ul><li><a href="http://unicode.org/faq/greek.html#5" target="_blank" rel="noreferrer">http://unicode.org/faq/greek.html#5</a></li><li><a href="http://en.wikipedia.org/wiki/Sigma" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Sigma</a></li><li><a href="http://www.unicode.org/reports/tr29/#Word_Boundaries" target="_blank" rel="noreferrer">http://www.unicode.org/reports/tr29/#Word_Boundaries</a></li><li><a href="http://books.google.fi/books?id=wn5sXG8bEAcC&amp;pg=PA169&amp;lpg=PA169&amp;dq=%22Final_Sigma%22&amp;source=bl&amp;ots=J07ysYPbVD&amp;sig=tGhPz1VFpi-KE1InQPsjX2diVlg&amp;hl=fi&amp;ei=XHswTqmrA4aSOrSf3X4&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=5&amp;ved=0CDYQ6AEwBA#v=onepage&amp;q=%22Final_Sigma%22&amp;f=false" target="_blank" rel="noreferrer">http://books.google.fi/books?id=wn5sXG8bEAcC&amp;pg=PA169&amp;lpg=PA169&amp;dq=&quot;Final_Sigma&quot;&amp;source=bl&amp;ots=J07ysYPbVD&amp;sig=tGhPz1VFpi-KE1InQPsjX2diVlg&amp;hl=fi&amp;ei=XHswTqmrA4aSOrSf3X4&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=5&amp;ved=0CDYQ6AEwBA#v=onepage&amp;q=&quot;Final_Sigma&quot;&amp;f=false</a></li></ul><h3 id="lithuanian-lt" tabindex="-1">Lithuanian (lt) <a class="header-anchor" href="#lithuanian-lt" aria-label="Permalink to &quot;Lithuanian (lt)&quot;">​</a></h3><pre><code># Lithuanian retains the dot in a lowercase i when followed by accents.

# Remove DOT ABOVE after &quot;i&quot; with upper or titlecase

0307; 0307; ; ; lt After_Soft_Dotted; # COMBINING DOT ABOVE

# Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
# whenever there are more accents above.
# (of the accents used in Lithuanian: grave, acute, tilde above, and ogonek)

0049; 0069 0307; 0049; 0049; lt More_Above; # LATIN CAPITAL LETTER I
004A; 006A 0307; 004A; 004A; lt More_Above; # LATIN CAPITAL LETTER J
012E; 012F 0307; 012E; 012E; lt More_Above; # LATIN CAPITAL LETTER I WITH OGONEK
00CC; 0069 0307 0300; 00CC; 00CC; lt; # LATIN CAPITAL LETTER I WITH GRAVE
00CD; 0069 0307 0301; 00CD; 00CD; lt; # LATIN CAPITAL LETTER I WITH ACUTE
0128; 0069 0307 0303; 0128; 0128; lt; # LATIN CAPITAL LETTER I WITH TILDE
</code></pre><h3 id="turkish-and-azeri-tr-and-az" tabindex="-1">Turkish and Azeri (tr and az) <a class="header-anchor" href="#turkish-and-azeri-tr-and-az" aria-label="Permalink to &quot;Turkish and Azeri (tr and az)&quot;">​</a></h3><pre><code># I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
# The following rules handle those cases.

0130; 0069; 0130; 0130; tr; # LATIN CAPITAL LETTER I WITH DOT ABOVE
0130; 0069; 0130; 0130; az; # LATIN CAPITAL LETTER I WITH DOT ABOVE

# When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
# This matches the behavior of the canonically equivalent I-dot_above

0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
0307; ; 0307; 0307; az After_I; # COMBINING DOT ABOVE

# When lowercasing, unless an I is before a dot_above, it turns into a dotless i.

0049; 0131; 0049; 0049; tr Not_Before_Dot; # LATIN CAPITAL LETTER I
0049; 0131; 0049; 0049; az Not_Before_Dot; # LATIN CAPITAL LETTER I

# When uppercasing, i turns into a dotted capital I

0069; 0069; 0130; 0130; tr; # LATIN SMALL LETTER I
0069; 0069; 0130; 0130; az; # LATIN SMALL LETTER I
</code></pre><h3 id="various-i-characters" tabindex="-1">Various &#39;i&#39; characters <a class="header-anchor" href="#various-i-characters" aria-label="Permalink to &quot;Various \\&#39;i\\&#39; characters&quot;">​</a></h3><p>Case conversion rules for various &#39;i&#39; characters are particularly fun. There are four separate &#39;i&#39;-characters:</p><ul><li>U+0049: LATIN CAPITAL LETTER I</li><li>U+0069: LATIN SMALL LETTER I</li><li>U+0130: LATIN CAPITAL LETTER I WITH DOT ABOVE</li><li>U+0131: LATIN SMALL LETTER DOTLESS I</li></ul><p>Case conversion rules for these characters are locale and context dependent and differ from standard conversions at least for Lithuanian (lt), Turkish (tr), and Azeri (az) as follows (ignoring context dependent rules):</p><hr><p>Input uc/lt uc/tr uc/az uc/other lc/lt lc/tr lc/az lc/other</p><hr><p>U+0049</p><p>U+0069</p><p>U+0130</p><h2 id="u-0131" tabindex="-1">U+0131 <a class="header-anchor" href="#u-0131" aria-label="Permalink to &quot;U+0131&quot;">​</a></h2><p><strong>FIXME: FILL</strong></p><p>Java behavior:</p><p>+-----+------+------+------+------+------+------+------+------+ | In | u | u | u | uc/o | l | l | l | lc/o | | put | c/lt | c/tr | c/az | ther | c/lt | c/tr | c/az | ther | +=====+======+======+======+======+======+======+======+======+ | U+0 | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | ** | ** | &gt; U+ | | 049 | 0049 | 0049 | 0049 | 0049 | 0069 | U+01 | U+01 | 0069 | | | | | | | | 31** | 31** | | +-----+------+------+------+------+------+------+------+------+ | U+0 | &gt; U+ | ** | ** | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | | 069 | 0049 | U+01 | U+01 | 0049 | 0069 | 0069 | 0069 | 0069 | | | | 30** | 30** | | | | | | +-----+------+------+------+------+------+------+------+------+ | U+0 | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | | 130 | 0130 | 0130 | 0130 | 0130 | 0069 | 0069 | 0069 | 0069 | +-----+------+------+------+------+------+------+------+------+ | U+0 | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | &gt; U+ | | 131 | 0049 | 0049 | 0049 | 0049 | 0131 | 0131 | 0131 | 0131 | +-----+------+------+------+------+------+------+------+------+</p>`,61)]))}const g=a(i,[["render",n]]);export{u as __pageData,g as default};
