import{_ as t,c as a,a2 as o,o as r}from"./chunks/framework.DPuwY6B9.js";const p=JSON.parse('{"title":"Memory management","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/memory-management.md","filePath":"resource/duktape/doc/memory-management.md","lastUpdated":null}'),i={name:"resource/duktape/doc/memory-management.md"};function n(s,e,l,c,d,h){return r(),a("div",null,e[0]||(e[0]=[o(`<h1 id="memory-management" tabindex="-1">Memory management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory management&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Duktape memory management is based on the following basic concepts:</p><ul><li><strong>Allocation functions</strong>. The user provides a set of functions for allocating, reallocating, and freeing blocks of memory. These &quot;raw&quot; functions can be used directly, but the implementation also provides variants which behave the same as the raw functions externally but force a garbage collection if an allocation attempt fails due to out of memory. Both of these variants are used internally, and can also be used by external code.</li><li><strong>Heap element tracking</strong>. Actual memory management happens on the heap level. Heap elements are tracked after being allocated, which allows unreachable elements to be freed by reference counting or mark-and-sweep garbage collection. Freeing a heap causes all related allocations to be freed, regardless of their reference count or reachability.</li><li><strong>Reference counting and mark-and-sweep</strong>. These algorithms are used to detect which heap elements can be freed. A finalizer method may be executed when an element is about to be freed by reference counting or mark-and-sweep.</li></ul><p>This document covers the memory management related aspects of the implementation:</p><ul><li>The raw allocation functions and their behavior</li><li>The heap memory layout (for &quot;tracked&quot; allocations)</li><li>Details of the reference counting algorithm</li><li>Details of the mark-and-sweep algorithm</li><li>Implementation notes, such as how to manage reference counting correctly, how code must be structured to work correctly with potential <code>longjmp()</code>s, etc</li></ul><p>Duktape supports three basic models for memory management; one of these is selected during build:</p><ol><li>Reference counting and mark-and-sweep, has reclamation for reference loops</li><li>Reference counting alone, has no reclamation for reference loops</li><li>Mark-and-sweep alone, has reclamation for reference loops but memory usage fluctuates considerably between mark-and-sweep collections</li></ol><p>At a high level, the implementation code must ensure that reference counts and heap element reachability are consistently and correctly updated where reference relationships are changed. In particular, reachability and reference counts must be correct whenever an operation which may cause a <code>longjmp()</code> or a garbage collection is performed. This is very tricky in practice. There is a &quot;GC torture&quot; compilation option to shake out memory management bugs.</p><h2 id="some-terminology" tabindex="-1">Some terminology <a class="header-anchor" href="#some-terminology" aria-label="Permalink to &quot;Some terminology&quot;">​</a></h2><p>Heap element</p><p>: The term &quot;heap-allocated element&quot; or &quot;heap element&quot; is used to refer broadly to all memory allocations which are automatically tracked. The term &quot;heap-allocated object&quot; or &quot;heap object&quot; is not used because it is easy to confuse with other notions of an &quot;object&quot;. In particular, all ECMAScript objects are heap elements, but there are other heap element types too. Heap-allocated elements subject to memory management are:</p><pre><code>-   \`duk_hstring\`
-   \`duk_hobject\` and its subtypes
-   \`duk_hbuffer\`

Only \`duk_hobject\` contains further internal references to other
heap elements. These references are kept in the object property
table and the object internal prototype pointer. Currently only
\`duk_hobject\` or its subtypes may have a finalizer.

Heap elements have a **stable pointer** which means that the (main)
heap element is not relocated during its lifetime. Auxiliary
allocations referenced by the heap element (such as an object
property table) can be reallocated/relocated.
</code></pre><p>Reference</p><p>: A pointer from a source heap element to a target heap element. The reference count of the target heap element must be incremented when a reference is created and decremented when the reference is removed. Only <code>duk_hobject</code> heap elements currently contain references, either through object properties (keys and values) or the object internal prototype reference.</p><p>Borrowed reference</p><p>: A pointer from a source heap element to a target heap element which is not reflected in the target element&#39;s reference count. Borrowed references can be used when an actual reference is guaranteed to exist somewhere while the borrowed reference is in use. If this cannot be guaranteed, the resulting bugs will be very difficult to diagnose.</p><p>Weak reference</p><p>: A pointer to a target heap element which is not reflected in the target element&#39;s reference count. A weak reference can exist even when no other references to the target exists, and does not prevent collection of the target. However, if the target is collected, the weak reference must be deleted to avoid dangling pointers.</p><pre><code>Currently there is no user visible support for weak references as
such. Weak references would be useful for e.g. cache data
structures. However, there are specialized internal weak references
which need to be taken into account. For instance, there is a
\\&quot;string access cache\\&quot; which optimizes access to individual
characters of strings. This cache weakly references heap strings and
must be updated when strings are collected.
</code></pre><p>Finalizer</p><p>: Objects (<code>duk_hobject</code> and its subtypes) stored in the heap may have a finalizer, which is called when the object is about to be freed. This allows user code to e.g. free native resources related to the object. A finalizer could, for instance, close a native socket or free memory allocated outside Duktape tracking. Finalizers are not required or supported by the E5 standard. Finalizers require a separate implementation mechanism for reference counting and mark-and-sweep; these two implementations need to coexist peacefully.</p><h2 id="allocation-functions" tabindex="-1">Allocation functions <a class="header-anchor" href="#allocation-functions" aria-label="Permalink to &quot;Allocation functions&quot;">​</a></h2><h3 id="raw-functions" tabindex="-1">Raw functions <a class="header-anchor" href="#raw-functions" aria-label="Permalink to &quot;Raw functions&quot;">​</a></h3><p>When creating an <code>duk_heap</code>, three memory allocation related functions are associated with the heap: <code>alloc</code>, <code>realloc</code>, and <code>free</code>. The related typedefs are:</p><pre><code>typedef void *(*duk_alloc_function) (void *udata, size_t size);
typedef void *(*duk_realloc_function) (void *udata, void *ptr, size_t size);
typedef void (*duk_free_function) (void *udata, void *ptr);
</code></pre><p>The semantics of these functions are essentially the same as their ANSI C equivalents. In particular:</p><ul><li>The return value for a zero-sized <code>alloc</code> and <code>realloc</code> may be <code>NULL</code> or some non-<code>NULL</code>, unique pointer value. Whatever the return value is, it must be accepted by <code>realloc</code> and <code>free</code>.</li><li><code>realloc(NULL, size)</code> is equivalent to <code>malloc(size)</code>.</li><li><code>realloc(ptr, 0)</code> is equivalent to <code>free(ptr)</code> (assuming <code>ptr</code> is not <code>NULL</code>), and must either return <code>NULL</code> or some non-<code>NULL</code> unique pointer value accepted by <code>realloc</code> and <code>free</code>.</li><li><code>free(NULL)</code> is a no-op.</li></ul><p>The default implementations map directly to the corresponding ANSI C functions (<code>udata</code> is ignored). If the platform allocator does not fulfill the ANSI C requirements, replacement functions must be provided by user code.</p><p>The memory returned by the allocation and reallocation functions must be properly aligned to support Duktape data structures. In particular, it must be possible, as far as alignment is concerned, to store a <code>double</code> or an <code>int64_t</code> at the start of the returned memory. This does always imply alignment by 8: on x86 there is usually no alignment requirement at all, while on ARM alignment by 4 usually suffices. Even when not strictly required, some level of alignment is often good for performance. (Technically these alignment requirements differ from the ANSI C requirements, especially when the allocation size is smaller than 8 bytes, but these cases don&#39;t really matter with Duktape.)</p><h3 id="internal-macros" tabindex="-1">Internal macros <a class="header-anchor" href="#internal-macros" aria-label="Permalink to &quot;Internal macros&quot;">​</a></h3><p>The following internal macros use the raw allocation functions and do not trigger garbage collection or any other side effects:</p><ul><li><code>DUK_ALLOC_RAW</code></li><li><code>DUK_REALLOC_RAW</code></li><li><code>DUK_FREE_RAW</code></li></ul><p>The natural downside of using these functions is that an allocation or reallocation may fail even if some memory would be available after a garbage collection.</p><p>The following internal macros may trigger a garbage collection (even when not strictly out of memory):</p><ul><li><code>DUK_ALLOC</code></li><li><code>DUK_ALLOC_ZEROED</code></li><li><code>DUK_REALLOC</code></li><li><code>DUK_REALLOC_INDIRECT</code></li><li><code>DUK_FREE</code></li></ul><p>Triggering a garbage collection has a wide set of possible side effects. If a finalizer is executed, arbitrary ECMAScript or even native code may run. Garbage collection side effects are discussed in detail in a separate section below.</p><p>Memory reallocation (e.g. <code>DUK_REALLOC()</code>) has a particularly nasty interaction with garbage collection. Mark-and-sweep side effects may potentially change the original pointer being reallocated. This must be taken into account when retrying the reallocation operation. There is a separate macro for these cases, <code>DUK_REALLOC_INDIRECT()</code>, see detailed discussion below.</p><p>Note that even if user code is allocating buffers to be used outside of automatic memory management, the garbage collection triggering variants are usually preferable because memory pressure is then communicated properly between user allocations and Duktape managed allocations. Use the raw variants only when invoking a garbage collection would be detrimental; this is rarely the case, especially for user code.</p><p>Because a (non-raw) memory allocation or reallocation may invoke garbage collection, any function or macro call which allocates memory directly or indirectly may have such side effects. Any direct or indirect checked memory allocations may also throw an out-of-memory error (leading ultimately to a <code>longjmp()</code>).</p><h3 id="public-api" tabindex="-1">Public API <a class="header-anchor" href="#public-api" aria-label="Permalink to &quot;Public API&quot;">​</a></h3><p>The heap-associated memory allocation functions can also be called by user code through the exposed API. This is useful for e.g. C functions which need temporary buffers. Note, however, that such allocations are, of course, not automatically managed so care must be taken to avoid memory leaks caused by e.g. errors (<code>longjmp()</code>s) in user code and the functions it calls.</p><p>The raw API calls behave essentially as direct wrappers for the memory management functions registered into the heap. The API calls providing garbage collection are unchecked and simply return a <code>NULL</code> on errors. A <code>NULL</code> is only returned when an allocation request cannot be satisfied even after garbage collection. Expect in fatal errors, the API calls are guaranteed to return and will hide e.g. errors thrown by finalizer functions.</p><p>Another alternative, perhaps more robust, is to push a <code>buffer</code> object into the value stack; the buffer will be automatically memory managed. Also, if the buffer is a fixed size one, a stable pointer can be obtained after allocation and passed anywhere in user code without further checks. The buffer is viable until it is no longer reachable (i.e. is pushed off the value stack and is not stored in any reachable object or variable).</p><p>The public API is:</p><pre><code>/* no garbage collection */
void *duk_alloc_raw(duk_context *ctx, size_t size);
void duk_free_raw(duk_context *ctx, void *ptr);
void *duk_realloc_raw(duk_context *ctx, void *ptr, size_t size);

/* may cause garbage collection, doesn&#39;t longjmp() */
void *duk_alloc(duk_context *ctx, size_t size);
void duk_free(duk_context *ctx, void *ptr);
void *duk_realloc(duk_context *ctx, void *ptr, size_t size);
</code></pre><h3 id="duk-realloc-issues-with-mark-and-sweep-duk-realloc-indirect" tabindex="-1">DUK_REALLOC() issues with mark-and-sweep; DUK_REALLOC_INDIRECT() <a class="header-anchor" href="#duk-realloc-issues-with-mark-and-sweep-duk-realloc-indirect" aria-label="Permalink to &quot;DUK_REALLOC() issues with mark-and-sweep; DUK_REALLOC_INDIRECT()&quot;">​</a></h3><p>There is a subtle gotcha when using DUK_REALLOC(). If the initial attempt to reallocate fails, the DUK_REALLOC() implementation will trigger a mark-and-sweep and then retry the reallocation. This does not work if the mark-and-sweep may have an effect on the original pointer being reallocated. In that case, the second attempt to reallocate will use an invalid &quot;original pointer&quot;!</p><p>A more conrete example of reallocating a valuestack (<code>thr-&gt;valstack</code>):</p><ul><li>Calling code calls <code>DUK_REALLOC(thr, thr-&gt;valstack, new_size)</code>. Assume that the value of <code>thr-&gt;valstack</code> is <code>P1</code> at this point.</li><li>The <code>DUK_REALLOC()</code> implementation attempts to use the raw realloc, giving <code>P1</code> as its pointer argument. This attempt fails.</li><li>A mark-and-sweep is triggered. The mark-and-sweep invokes a number of finalizer methods, which cause <strong>the same valstack</strong> to be resized. This resize succeeds, and <code>thr-&gt;valstack</code> pointer is updated to <code>P2</code>.</li><li>The <code>DUK_REALLOC()</code> implementation retries the raw realloc, again giving <code>P1</code> as its pointer argument. Here, <code>P1</code> is a garbage pointer and the realloc call has undefined behavior.</li></ul><p>The correct pointer for the second realloc would be <code>P2</code>. However, the helper behind the macro doesn&#39;t know where the pointer came from.</p><p>A naive approach is to use an indirect realloc function which gets a pointer to the storage location of the pointer being reallocated (e.g. <code>(void **) &amp;thr-&gt;valstack</code>). The realloc implementation then re-lookups the current pointer right before every reallocation, which works correctly even if the pointer has changed by garbage collection. Note that heap headers have stable pointers so that the header which contains the pointer is never relocated so the location of the pointer itself never changes. Even so, this approach suffers from C type-punning and strict aliasing issues. Such issues could be fixed by changing all the base pointers to a union but this would be very invasive, of course.</p><p>The current solution is to use an indirect realloc function which gets a callback function with a userdata pointer as its argument. The callback is used to request for the current value of the pointer being reallocated. This bloats code to be strict aliasing compatible, but is the most portable way.</p><p>Implications:</p><ul><li>DUK_REALLOC_RAW() can be used reliably for anything, but is not guaranteed to succeed (even if memory would be available after garbage collection).</li><li>DUK_REALLOC() can be used reliably for pointers which are guaranteed not to be affected by mark-and-sweep -- considering that mark-and-sweep runs arbitrary code, including even arbitrary native function, e.g. as part of object finalization.</li><li>DUK_REALLOC_INDIRECT() (or DUK_ALLOC() + DUK_FREE()) should be used for pointers which are not stable across a mark-and-sweep. The storage location of such pointers must be stable, e.g. reside in the meain allocation of a heap object.</li></ul><h2 id="heap-structure" tabindex="-1">Heap structure <a class="header-anchor" href="#heap-structure" aria-label="Permalink to &quot;Heap structure&quot;">​</a></h2><h3 id="overview-1" tabindex="-1">Overview <a class="header-anchor" href="#overview-1" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>All heap-allocated elements must be recorded in the <code>duk_heap</code>, either as part of the string table (for <code>duk_hstring</code> elements) or as part of the &quot;heap allocated&quot; list (or temporary work queues). This is required so that all allocated elements can always be enumerated and freed, regardless of their reference counts or reachability.</p><p>Heap elements which are currently in use somewhere must have a positive reference count, and they must be reachable through the actual reachability roots starting from the <code>duk_heap</code> structure. These form the actual reachability graph from a garbage collection point of view; any objects tracked by the heap but not part of the reachability graph are garbage and can be freed. Such objects, assuming reference counts are correct, either have a zero reference count or belong to a reference cycle.</p><p>The following figure summarizes the elements managed by a single heap structure, with arrows indicating basic reachability or ownership relationships:</p><pre><code>All non-string heap elements reside in one of the
following object lists:

* &quot;heap allocated&quot;
* &quot;refzero work list&quot;
* &quot;finalization work list&quot;

+-------------+  h_next  +-------------+  h_next
.------&gt;| duk_hobject |&lt;--------&gt;| duk_hbuffer |&lt;--------&gt; ...
|       +-------------+ (h_prev) +-------------+ (h_prev)
|
+==========+    (Above illustrates &quot;heap allocated&quot;, there are
| duk_heap |    similar lists for &quot;refzero&quot; and &quot;finalization&quot;)    
+==========+                    
|    |
|    |
|    |       All duk_hstrings reside in the string table.
|    |
|    |       +--------+
|    |       : string :      +-------------+
|    +------&gt;: intern :-----&gt;| duk_hstring |
|    |       : table  :      +-------------+
|    |       +--------+         ^      ^
|    |                          |      :
|    |       +------+           |      :
|    +------&gt;: strs :-----------&#39;      :
|    |       +------+   (built-in      :
|    |                   strings)      :
|    |       +--------+                :
|    \`------&gt;: string :                :
|            : access :- - - - - - - - &#39;
|            : cache  :  (weak refs)
|            +--------+
|
|
|    (reachability graph roots)
|
|     +-------------+
+---&gt; | duk_hthread |     heap_thread: internal thread, also used
|     +-------------+                  for (some) finalization
|
|     +-------------+
\`---&gt; | duk_hthread |     curr_thread: currently running thread
+-------------+
|
|
|    +----------+      +-------------+
+---&gt;: builtins :-----&gt;| duk_hobject |
|    +----------+      +-------------+
|                            |
|                            +--&gt; object properties
|                            |
|                            \`--&gt; (type specific)
+--&gt;  object properties
|
+--&gt;  value stack
|
+--&gt;  call stack --&gt;  duk_activations (linked list)
|                       |
|                       \`--&gt; duk_catchers (linked list)
|
|                          +-------------+
\`--&gt;  resumer -----------&gt; | duk_hthread |
(another duk_hthread    +-------------+
or NULL)
</code></pre><p>Notation:</p><pre><code>+=====+          +-----+          +-----+
| xxx |          | xxx |          : xxx :
+=====+          +-----+          +-----+    

backbone       heap element      auxiliary
</code></pre><p>(Many details are omitted from the figure; for instance, there are back pointers and duplicate pointers for faster access which are not illustrated at all.)</p><p>The primary memory management models relate to the figure as follows (omitting details such as recursion depth limits, finalization, interaction between reference counting and mark-and-sweep, etc):</p><ul><li>Reference counting works by inspecting a reference count field which is a part of the header of every heap allocated element (including strings). Whenever a reference is removed, the reference count of the target is decreased, and if the reference count becomes zero, the target object can be freed. Before freeing, any outgoing references from object must be iterated and the reference count of the target heap elements needs to be decreased, possibly setting off a cascade of further &quot;refzero&quot; situations. Note that incoming references don&#39;t need to be considered: if reference counts are correct and the reference count of the current object is zero, there cannot be any live incoming references.</li><li>Mark-and-sweep works by traversing the reachability graph originating from the <code>duk_heap</code> structure referenced, marking all reachable objects, and then walking the comprehensive &quot;heap allocated&quot; list to see which objects are unreachable and can be freed.</li></ul><p>The only &quot;backbone&quot; element which is not itself a heap element is the <code>duk_heap</code> object. Heap elements include both internal and external objects which may reference each other in an arbitrary conceptual graph. Finally, auxiliary elements are either struct members or additional allocations &quot;owned&quot; by the main heap element types. They are an integral part of their parent element and cannot be referenced directly by other elements. They are freed when their parent is freed.</p><p>The primary roots for reachability are the threads referenced by the heap object. In particular, the currently running thread is reachable, and the thread structure maintains a pointer to the thread which resumed the current thread (if any). All heap element references ultimately reside in:</p><ul><li>Object properties</li><li>Thread value stack</li><li>Thread call stack (including catchers)</li><li>Thread resumer reference</li><li>Compiled function constant table</li><li>Compiled function inner function table</li></ul><p>These references form the heap-level reachability graph, and provides the basis for mark-and-sweep collection.</p><p>There are, of course, temporary references to both heap-allocated and non-heap-allocated memory areas in CPU registers and the stack frames of the C call stack. Such references must be very carefully maintained: an abrupt completion (concretely, a <code>longjmp()</code>) will unwind the C stack to some catch point (concretely, a <code>setjmp()</code>) and any such references are lost. Also, any unreachable heap elements may be freed if a mark-and-sweep is triggered directly or indirectly. See separate discussion on error handling and memory management.</p><h3 id="heap-elements" tabindex="-1">Heap elements <a class="header-anchor" href="#heap-elements" aria-label="Permalink to &quot;Heap elements&quot;">​</a></h3><p>All heap tracked elements have a shared header structure, <code>duk_heaphdr</code>, defined in <code>duk_heaphdr.h</code>. String elements use a smaller <code>duk_heaphdr_string</code> header which is a prefix of <code>duk_heaphdr</code>. The difference between these two headers is that <code>duk_heaphdr_string</code> does not contain next/previous links required to maintain heap allocated objects in a single or double linked list. These are not needed because strings are always kept in the heap-level string intern table, and are thus enumerable (regardless of their reachability) through the string intern hash table.</p><p>Heap-allocated elements are always allocated with a fixed size, and are never reallocated (and hence never moved) during their life cycle. This allows all heap-allocated elements to be pointed to with <em>stable pointers</em>. Non-fixed parts of an element are allocated separately and pointed to by the main heap element. Such allocations are &quot;owned&quot; by the heap element and are automatically freed when the heap element is freed. The upside of having stable pointers is simplicity and compatibility with existing allocators. The downside is that memory fragmentation may become an issue over time because there is no way to compact the heap. The full size of the fixed part of the heap element needs to be known at the time of allocation.</p><p>Normally, heap elements are typed by the tagged value (<code>duk_tval</code>) which holds the heap pointer, or if the heap element reference is in a struct field, the field is usually already correctly typed through its C type (e.g. a field might have the type &quot;<code>duk_hcompfunc *</code>&quot;). However, heap elements do have a &quot;heap type&quot; field as part of the <code>h_flags</code> field of the header; this is not normally used, but is needed by e.g. reference counting. As a separate issue, some heap types (such as <code>duk_hobject</code>) have &quot;sub-types&quot; with various extended memory layouts; these are not reflected in the heap type.</p><p>The current specific heap element types are:</p><ul><li><code>duk_hstring</code> (heap type <code>DUK_HTYPE_STRING</code>): <ul><li>Fixed size allocation consisting of a header with string data following the header. Header only contains a &#39;next&#39; pointer (uses <code>duk_heaphdr_string</code>).</li><li>No references to other heap elements.</li></ul></li><li><code>duk_hobject</code> (heap type <code>DUK_HTYPE_OBJECT</code>): <ul><li>Fixed size allocation consisting of a header, whose size depends on the object type (<code>duk_hobject</code>, <code>duk_hthread</code>, <code>duk_hcompfunc</code>, <code>duk_hnatfunc</code>, etc).</li><li>The specific &quot;sub type&quot; and its associated struct definition can be determined using object flags, using the macros: <ul><li><code>DUK_HOBJECT_IS_COMPFUNC</code></li><li><code>DUK_HOBJECT_IS_NATFUNC</code></li><li><code>DUK_HOBJECT_IS_THREAD</code></li><li>(and other sub types added later)</li><li>If none of the above are true, the object is a plain object (<code>duk_hobject</code> without any extended structure)</li></ul></li><li>Properties are stored in a separate, dynamic allocation, and contain references to other heap elements.</li><li>For <code>duk_hcompfunc</code>, function bytecode, constants, and references to inner functions are stored in a fixed <code>duk_hbuffer</code> referenced by the <code>duk_hcompfunc</code> header. These provide further references to other heap elements.</li><li>For <code>duk_hthread</code> the heap header contains references to the value stack, call stack, etc, which provide references to other heap elements.</li></ul></li><li><code>duk_hbuffer</code> (heap type <code>DUK_HTYPE_BUFFER</code>): <ul><li>Fixed buffer (<code>DUK_HBUFFER_HAS_DYNAMIC()</code> is false): <ul><li>Fixed size allocation consisting of a header with buffer data following the header.</li></ul></li><li>Dynamic buffer (<code>DUK_HBUFFER_HAS_DYNAMIC()</code> is true): <ul><li>Fixed size allocation consisting of a header with a pointer to the current buffer allocation following the header.</li><li>Buffer data is allocated separately and the buffer may be resized. The address of the buffer data may change during a resize.</li></ul></li><li>No references to other heap elements.</li></ul></li></ul><h2 id="string-table" tabindex="-1">String table <a class="header-anchor" href="#string-table" aria-label="Permalink to &quot;String table&quot;">​</a></h2><h3 id="string-interning" tabindex="-1">String interning <a class="header-anchor" href="#string-interning" aria-label="Permalink to &quot;String interning&quot;">​</a></h3><p>All strings are <a href="http://en.wikipedia.org/wiki/String_interning" target="_blank" rel="noreferrer">interned</a> into the hash level string table: only one, immutable copy of any particular string is ever stored at a certain point in time.</p><p>When a new string is constructed e.g. by string concatenation, the string table is checked to see if the resulting string has already been interned. If yes, the existing string is used; if not, the string is added to the string table. Regardless, the string is represented by an <code>duk_hstring</code> pointer which is stable for the lifetime of the string.</p><p>String interning has many nice features:</p><ul><li>When a string is interned, precomputations can be done and stored as part of the string representation. For example, a string hash can be precomputed and used elsewhere in e.g. hash tables. Other precomputations would also be possible, e.g. numeric conversions (not currently used).</li><li>Strings can be compared using direct pointer comparisons without comparing actual string data, since at any given time, a given string can only have one <code>duk_hstring</code> instance with a stable address.</li><li>Memory is saved for strings which occur multiple times. For instance, object properties of the same name are simply referenced with a string pointer instead of storing multiple instances of the same property name.</li></ul><p>But, there are downsides as well:</p><ul><li>String manipulation is slower because any intermediate, referenceable results need to be interned (which implies string hashing, a lookup from the string table, etc). This can be mitigated e.g. by doing string concatenation of multiple parts in an atomic fashion.</li><li>For small strings which only occur once or twice in the heap, there is additional overhead in the interned <code>duk_hstring</code> heap element compared to simply storing the string in an object&#39;s property table, for instance.</li><li>Using string values as &quot;data buffers&quot; which are continuously manipulated (appended or predended to, sliced, etc) is very inefficient and causes a lot of garbage collection churn. Buffer objects should be used instead, but these are not part of the ECMAScript standard.</li></ul><h3 id="memory-management-of-strings" tabindex="-1">Memory management of strings <a class="header-anchor" href="#memory-management-of-strings" aria-label="Permalink to &quot;Memory management of strings&quot;">​</a></h3><p>Interned strings are garbage collected normally when they are no longer needed. They are later re-interned if they are needed again; at this point they usually get a different pointer than before.</p><h3 id="string-table-algorithm" tabindex="-1">String table algorithm <a class="header-anchor" href="#string-table-algorithm" aria-label="Permalink to &quot;String table algorithm&quot;">​</a></h3><p>The string table structure is similar to the &quot;entry part&quot; of the <code>duk_hobject</code> property allocation:</p><ul><li>Closed hash table (probe sequences). Probe sequences use an initial index based on string hash value, and a probe step looked up from a precomputed table of step values using a string hash value based index.</li><li>Hash table size is rounded upwards to a prime in a precomputed sequence. Hash table load factor is kept within a certain range by resizing whenever necessary.</li><li>Deleted entries are explicitly marked DELETED to avoid breaking hash probe chains. DELETED entries are eliminated on rehashing, and are counted as &quot;used&quot; entries before a resize to ensure there are always NULL entries in the string table to break probe sequences.</li></ul><p>For more details, see:</p><ul><li><code>hstring-design.rst</code> for discussion on the string hash algorithm.</li><li><code>hobject-design.rst</code>, entry part hash algorithm, for discussion on the basic closed hash structure.</li></ul><p>::: note ::: title Note :::</p><p>This discussion should be expanded. :::</p><h2 id="reference-counting" tabindex="-1">Reference counting <a class="header-anchor" href="#reference-counting" aria-label="Permalink to &quot;Reference counting&quot;">​</a></h2><h3 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h3><p>For background, see:</p><ul><li><a href="http://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Reference_counting</a></li></ul><p>In basic reference counting each heap object has a reference count field which indicates how many other objects in the heap point to this object. Whenever a new reference is created, its target object&#39;s reference count is incremented; whenever a reference is destroyed, its target object&#39;s reference counter is decreased. If a reference count goes to zero when it is decreased, the object can be freed directly. When the object is freed, any heap objects it refers to need to have their reference counts decremented, which may trigger an arbitrarily long chain of objects to be freed recursively.</p><p>There are variations of reference counting where objects are not freed immediately after their reference count goes to zero. Objects-to-be-freed can be managed in a work list and freed later. However, for our purposes it is useful to free any reference counted objects as soon as possible (otherwise we could just use the mark-and-sweep collector).</p><p>There are also reference counting variants which handle reference loops correctly without resorting to mark-and-sweep. These seem to be too complex in practice for a small interpreter.</p><p>Reference counting increases code size, decreases performance due to reference count updates, and increases heap header size for every object. On the other hand it minimizes variance in memory usage (compared to plain mark-and-sweep, even an incremental one) and is very useful for small scripts running without a pre-allocated heap. Reference counting also reduces the impact of having non-relocatable heap elements: memory fragmentation still happens, but is comparable to memory fragmentation encountered by ordinary C code.</p><h3 id="reference-count-field" tabindex="-1">Reference count field <a class="header-anchor" href="#reference-count-field" aria-label="Permalink to &quot;Reference count field&quot;">​</a></h3><p>The reference count field is embedded into the <code>duk_heaphdr</code> structure whose layout varies depending on the memory management model chosen for the build. The reference count field applies to all heap allocated elements, including strings, so it appears in the header before the next/previous pointers required for managing non-string heap elements.</p><p>The current struct definitions are in <code>duk_heaphdr.h</code>. Two structures are defined:</p><ul><li><code>duk_heaphdr</code>: applies to all heap elements except strings.</li><li><code>duk_heaphdr_string</code>: applies to strings, beginning of struct matches <code>duk_heaphdr</code>.</li></ul><p>The reference count field must have enough bits to ensure that it will never overflow. This is easy to satisfy by making the field as large as a data pointer type. Currently <code>size_t</code> is used which is technically incorrect (one could for instance have a platform with maximum allocation size of 32 bits but a memory space of 64 bits).</p><h3 id="reference-count-macros" tabindex="-1">Reference count macros <a class="header-anchor" href="#reference-count-macros" aria-label="Permalink to &quot;Reference count macros&quot;">​</a></h3><p>Macros:</p><ul><li><code>DUK_TVAL_INCREF</code></li><li><code>DUK_TVAL_DECREF</code></li><li><code>DUK_HEAPHDR_INCREF</code></li><li><code>DUK_HEAPHDR_DECREF</code></li><li>and a bunch of heap element type specific INCREF/DECREF macros and helpers, defined in <code>heaphdr.h</code></li></ul><p>Notes on macro semantics:</p><ul><li>The macros are optimized for performance and don&#39;t tolerate a <code>NULL</code> pointer by default. There are <code>_ALLOWNULL</code> variants for cases where NULLs may actually occur.</li><li>An <code>INCREF</code> is guaranteed not to have any side effects.</li><li>A <code>DECREF</code> may have a wide variety of side effects. <ul><li><code>DECREF</code> may free the target object and an arbitrary number of other objects whose reference count drops to zero as a result.</li><li>If a finalizer is invoked, arbitrary C or ECMAScript code is executed which may have essentially arbitrary side effects, including triggering the mark-and-sweep garbage collector.</li><li>The mark-and-sweep garbage collector may also be voluntarily invoked at the end of &quot;refzero&quot; handling.</li><li>Any <code>duk_tval</code> pointers pointing to dynamic structures (like a value stack) may be invalidated; heap element pointers are not affected because they are stable.</li></ul></li></ul><p>See discussion on &quot;side effects&quot; below for more particulars on the implementation impact.</p><h3 id="updating-reference-counts" tabindex="-1">Updating reference counts <a class="header-anchor" href="#updating-reference-counts" aria-label="Permalink to &quot;Updating reference counts&quot;">​</a></h3><p>Updating reference counts is a bit tricky. Some important rules:</p><ul><li>Whenever a <code>longjmp()</code> or garbage collection may occur, reachability and reference counts must be correct.</li><li>If a reference count drops to zero, even temporarily, the target is <em>immediately</em> freed. If this is not desired, <code>INCREF</code>/<code>DECREF</code> order may need to be changed.</li><li>A <code>DECREF</code> call may invalidate <em>any</em> <code>duk_tval</code> pointers to resizable locations, such as the value stack. It may also invalidate indices to object property structures if a property allocation is resized. So, <code>DECREF</code> must be called with utmost care.</li></ul><p>Note that it is <em>not enough</em> to artificially increase a target&#39;s reference count to prevent the object from being freed, at least when mark-and-sweep collection is also enabled. Mark-and-sweep may be triggered very easily, and <em>will</em> free an unreachable object, regardless of its reference count, unless specific measures are taken to avoid it. In fact, mark-and-sweep <em>must</em> collect unreachable objects with a non-zero reference count, to deal with reference loops which cannot be collected using reference counting alone. Even if mark-and-sweep issues were avoided (perhaps with a flag preventing collection), if a reference count is artificially increased without there being a corresponding, actual heap-based reference to the target, there must be a guarantee that the reference count is also decreased later. This would require a <code>setjmp()</code> catchpoint.</p><p>Specific considerations:</p><ul><li><code>DECREF</code> + <code>INCREF</code> on the same target object is dangerous. If the refcount drops to zero between the calls, the object is freed. It&#39;s usually preferable to do <code>INCREF</code> + <code>DECREF</code> instead to avoid this potential issue.</li></ul><h3 id="the-incref-algorithm" tabindex="-1">The INCREF algorithm <a class="header-anchor" href="#the-incref-algorithm" aria-label="Permalink to &quot;The INCREF algorithm&quot;">​</a></h3><p>The <code>INCREF</code> algorithm is very simple:</p><ol><li>If the target reference is <code>NULL</code> or the target is not a heap element, return.</li><li>Increase the target&#39;s reference count by one.</li></ol><p>The practical implementation depends on whether <code>INCREF</code> is used on a tagged value pointer or a heap element pointer.</p><h3 id="the-decref-algorithm" tabindex="-1">The DECREF algorithm <a class="header-anchor" href="#the-decref-algorithm" aria-label="Permalink to &quot;The DECREF algorithm&quot;">​</a></h3><p>The <code>DECREF</code> algorithm is a bit more complicated:</p><ol><li>If the target reference is <code>NULL</code> or the target is not a heap element, return.</li><li>Decrease the target&#39;s reference count by one.</li><li>If the reference count dropped to zero: a. If mark-and-sweep is currently running, ignore and return. (Note: mark-and-sweep is expected to perform a full reachability analysis and have correct reference counts at the end of the mark-and-sweep algorithm.) b. If the target is a string, remove the string from the string table, remove any weak references (e.g. from string access cache), and then free the string structure. c. If the target is a buffer: 1. Remove the buffer from the &quot;heap allocated&quot; list, free any related allocations (if the buffer is dynamic, the separately allocated buffer), and then free the buffer structure. d. Else the target is an object: 1. This case is relatively complicated, see code for details: - If the object doesn&#39;t have a finalizer, queue it to &quot;refzero list&quot;. If no-one is processing refzero_list now, process it until it becomes empty; new objects may be queued as previous ones are refcount finalized and freed. When the list is empty, run any pending finalizers queued up during the process. If a previous call is already processing the list, just queue the object and finish. - If the object has a finalizer, queue it to finalize_list. If no-one is processing the refzero_list or finalize_list, process the finalize_list directly. Otherwise just queue the object and finish.</li></ol><h3 id="the-refzero-algorithm" tabindex="-1">The REFZERO algorithm <a class="header-anchor" href="#the-refzero-algorithm" aria-label="Permalink to &quot;The REFZERO algorithm&quot;">​</a></h3><p>The <code>DECREF</code> algorithm ensures that only one instance of the &quot;refzero&quot; algorithm may run at any given time. The &quot;refzero&quot; work list model is used to avoid an unbounded C call stack depth caused by a cascade of reference counts which drop to zero.</p><p>See code for details, also see <code>doc/side-effects.rst</code>.</p><h3 id="background-on-the-refzero-algorithm-limiting-c-recursion-depth" tabindex="-1">Background on the refzero algorithm, limiting C recursion depth <a class="header-anchor" href="#background-on-the-refzero-algorithm-limiting-c-recursion-depth" aria-label="Permalink to &quot;Background on the refzero algorithm, limiting C recursion depth&quot;">​</a></h3><p>When a reference count drops to zero, the heap element will be freed. If the heap element contains references (like an ECMAScript object does), all target elements need to be <code>DECREF</code>&#39;d before the element is freed. These <code>DECREF</code> calls may cause the reference count of further elements to drop to zero; this &quot;cascade&quot; of zero reference counts may be arbitrarily long. Since we need to live with limited and sometimes very small C stacks in some embedded environments (some environments may have less than 64 kilobytes of usable stack), the reference count zero handling must have a limited C recursion level to work reliably.</p><p>This is currently handled by using a &quot;work list&quot; model. Heap elements whose reference count has dropped to zero are placed in a &quot;to be freed&quot; work list (see <code>duk_heap</code> structure, <code>refzero_list</code> member in <code>duk_heap.h</code>). The list is then freed using a loop which frees one element at a time until the list is free. New elements may be added to the list while it is being iterated. The C recursion level is fixed.</p><p>The <code>h_prev</code>/<code>h_next</code> fields of the <code>duk_heaphdr</code> structure, normally used for the &quot;heap allocated&quot; list, are used for the &quot;refzero&quot; work list. Because <code>duk_hstring</code>s do not have embedded references so they are freed directly when their reference count drops to zero.</p><p><em>Finalization</em> of an object whose refcount becomes zero is very useful for e.g. freeing any native resources or handles associated with an object. For instance, socket or file handles can be closed when the object is being freed. The finalizer is an internal method associated with an <code>duk_hobject</code> which is called just before the object is freed either by reference counting or by the mark-and-sweep collector. The finalizer gets a reference to the object in question, and may &quot;rescue&quot; the reference.</p><p>There are many side effects to consider, see <code>doc/side-effects.rst</code>.</p><h2 id="mark-and-sweep" tabindex="-1">Mark-and-sweep <a class="header-anchor" href="#mark-and-sweep" aria-label="Permalink to &quot;Mark-and-sweep&quot;">​</a></h2><h3 id="introduction-1" tabindex="-1">Introduction <a class="header-anchor" href="#introduction-1" aria-label="Permalink to &quot;Introduction&quot;">​</a></h3><p>For background, see:</p><ul><li><a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noreferrer">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a></li></ul><p>The variant used is a &quot;stop the world&quot; mark-and-sweep collector, which is used instead of an incremental one for simplicity and small footprint. When combined with reference counting, the mark-and-sweep collector is only required for handling reference cycles anyway, so the particular variant is not that important. A definite downside of a &quot;stop the world&quot; collector is that it introduces an annoying pause in application behavior which is otherwise avoided by reference counting.</p><p>The mark-and-sweep algorithm used has support for:</p><ul><li>object finalization (requires two collector passes)</li><li>object compaction (in emergency mode)</li><li>string table resizing</li></ul><p>An &quot;emergency mode&quot; is provided for situations where allocation fails repeatedly, even after a few ordinary mark-and-sweep attempts. In emergency mode the collector tries to find memory even by expensive means (such as forcibly compacting object property allocations).</p><p>Control flags are also provided to limit side effects of mark-and-sweep, which is required to implement a few critical algorithms: resizing the string table, and resizing object property allocation. During these operations mark-and-sweep must avoid interfering with the object being resized.</p><h3 id="mark-and-sweep-flags" tabindex="-1">Mark-and-sweep flags <a class="header-anchor" href="#mark-and-sweep-flags" aria-label="Permalink to &quot;Mark-and-sweep flags&quot;">​</a></h3><p>Mark-and-sweep control flags are defined in <code>duk_heap.h</code>, e.g.:</p><ul><li><code>DUK_MS_FLAG_EMERGENCY</code></li><li><code>DUK_MS_FLAG_NO_FINALIZERS</code></li><li><code>DUK_MS_FLAG_NO_OBJECT_COMPACTION</code></li></ul><p>In addition to the explicitly requested flags, the bit mask in <code>ms_base_flags</code> in <code>duk_heap</code> is bitwise ORed into the requested flags to form effective flags. The flags added to the &quot;base flags&quot; control restrictions on mark-and-sweep side effects, and are used for certain critical sections.</p><p>To protect against such side effects, the critical algorithms:</p><ul><li>Store the original value of <code>heap-&gt;ms_base_flags</code></li><li>Set the suitable restriction flags into <code>heap-&gt;ms_base_flags</code></li><li>Attempt the allocation / reallocation operation, <em>without throwing errors</em></li><li>Restore the <code>heap-&gt;ms_base_flags</code> to its previous value</li><li>Examine the allocation result and act accordingly</li></ul><p>It is important not to throw an error without restoring the base flags field. See <code>duk_heap.h</code> for the flag details.</p><h3 id="heap-header-flags" tabindex="-1">Heap header flags <a class="header-anchor" href="#heap-header-flags" aria-label="Permalink to &quot;Heap header flags&quot;">​</a></h3><p>The following flags in the heap element header are used for controlling mark-and-sweep:</p><ul><li><code>DUK_HEAPHDR_FLAG_REACHABLE</code>: element is reachable through the reachability graph.</li><li><code>DUK_HEAPHDR_FLAG_TEMPROOT</code>: element&#39;s reachability has been marked, but its children have not been processed; this is required to limit the C recursion level.</li><li><code>DUK_HEAPHDR_FLAG_FINALIZABLE</code>: element is not reachable after the first marking pass (see algorithm), has a finalizer, and the finalizer has not been called in the previous mark-and-sweep round; object will be moved to the finalization work list and will be considered (temporarily) a reachability root.</li><li><code>DUK_HEAPHDR_FLAG_FINALIZED</code>: element&#39;s finalizer has been executed, and if still unreachable, object can be collected. The finalizer will not be called again until this flag is cleared; this prevents accidental re-entry of the finalizer until the object is explicitly rescued and this flag cleared.</li></ul><p>These are referred to as <code>REACHABLE</code>, <code>TEMPROOT</code>, <code>FINALIZABLE</code>, and <code>FINALIZED</code> below for better readability. All the flags are clear when a heap element is first allocated. Explicit &quot;clearing passes&quot; are avoided by careful handling of the flags so that the flags are always in a known state when mark-and-sweep begins and ends.</p><h3 id="basic-algorithm" tabindex="-1">Basic algorithm <a class="header-anchor" href="#basic-algorithm" aria-label="Permalink to &quot;Basic algorithm&quot;">​</a></h3><p>The mark-and-sweep algorithm is triggered by a failed memory allocation either in &quot;normal&quot; mode or &quot;emergency&quot; mode. Emergency mode is used if a normal mark-and-sweep pass did not resolve the allocation failure; the emergency mode is a more aggressive attempt to free memory. Mark-and-sweep is controlled by a set of flags. The effective flags set is a bitwise OR of explicit flags and &quot;base flags&quot; stored in <code>heap-&gt;ms_base_flags</code>. The &quot;base flags&quot; essentially prohibit specific garbage collection operations when a certain critical code section is active.</p><p>The mark-and-sweep algorithm is as follows:</p><ol><li>The <code>REACHABLE</code> and <code>TEMPROOT</code> flags of all heap elements are assumed to be cleared at this point. <ul><li>Note: this is the case for all elements regardless of whether they reside in the string table, the &quot;heap allocated&quot; list, the &quot;refzero&quot; work list, or anywhere else.</li></ul></li><li><strong>Mark phase</strong>. The reachability graph is traversed recursively, and the <code>REACHABLE</code> flags is set for all reachable elements. This is complicated by the necessity to impose a limit on maximum C recursion depth: a. At the beginning the heap level flag <code>DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED</code> is asserted to be cleared. b. The reachability graph of the heap is traversed with a depth-first algorithm: 1. Marking starts from the reachability roots: - the heap structure itself (including the current thread, its resuming thread, etc) - the &quot;refzero_list&quot; for reference counting 2. If the reachability traversal hits the C recursion limit (<code>mark_and_sweep_recursion_limit</code> member of the heap) for some heap element <code>E</code>: a. The <code>DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED</code> flag is set. b. The reachability status of <code>E</code> is updated, but its internal references are not processed (to avoid further recursion). c. The <code>TEMPROOT</code> flag is set for <code>E</code>, indicating that it should be processed later. 3. Unreachable objects which need finalization (but whose finalizers haven&#39;t been executed in the last round) are marked FINALIZABLE and are marked as reachable with the normal recursive marking algorithm. 4. The algorithm of step 2 (handling <code>TEMPROOT</code> markings) is repeated to ensure reachability graph has been fully processed (elements are marked reachable and TEMPROOT flags are set), also for the objects just marked FINALIZABLE. c. While the <code>DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED</code> flag is set for the heap: 1. Clear the <code>DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED</code> flag of the heap. 2. Scan all elements in the &quot;heap allocated&quot; or &quot;refzero work list&quot; (note that &quot;refzero work list&quot; <em>must</em> be included here but not in the sweep phase). For each element with the <code>TEMPROOT</code> flag set: a. Clear the <code>TEMPROOT</code> flag. b. Process the internal references of the element recursively, imposing a similar recursion limit as before (i.e. setting the <code>DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED</code> flag etc).</li><li><strong>Sweep phase 1 (refcount adjustments)</strong>. Inspect all heap elements in the &quot;heap allocated&quot; list (string table doesn&#39;t need to be considered as strings have no internal references): a. If the heap element would be freed in sweep phase 2 (i.e., element is not reachable, and has no finalizer which needs to be run): 1. Decrease reference counts of heap elements the element points to, but don&#39;t execute &quot;refzero&quot; queueing or the &quot;refzero&quot; algorithm. Any elements whose refcount drops to zero will be dealt with by mark-and-sweep and objects in the refzero list are handled by reference counting.</li><li><strong>Sweep phase 2 (actual freeing)</strong>. Inspect all heap elements in the &quot;heap allocated&quot; list and the string table (note that objects in the &quot;refzero&quot; work list are NOT processed and thus never freed here): a. If the heap element is <code>REACHABLE</code>: 1. If <code>FINALIZED</code> is set, the object has been rescued by the finalizer. This requires no action as such, but can be debug logged. 2. Clear <code>REACHABLE</code> and <code>FINALIZED</code> flags. 3. Continue with next heap element. b. Else the heap element is not reachable, and: 1. If the heap element is an <code>duk_hobject</code> (its heap type is <code>DUK_HTYPE_OBJECT</code>) and the object has a finalizer (i.e. it has the internal property <code>_Finalizer</code>), and the <code>FINALIZED</code> flag is not set: a. Move the heap element from &quot;heap allocated&quot; to &quot;to be finalized&quot; work list. b. Continue with next heap element. 2. Free the element and any of its &quot;auxiliary allocations&quot;. 3. Continue with next heap element.</li><li>For every heap element in the &quot;refzero&quot; work list: a. Clear the element&#39;s <code>REACHABLE</code> flag. (See notes below why this seemingly unnecessary step is in fact necessary.)</li><li>If doing an emergency mark-and-sweep and object compaction is not explicitly prohibited by heap flags: a. Compact the object&#39;s property allocation in the hopes of freeing memory for the emergency.</li><li>If string table resize is not explicitly prohibited by heap flags: a. Compact and rehash the string table. This can be controlled by build flags as it may not be appropriate in all environments.</li><li>Finish. a. All <code>TEMPROOT</code> and <code>REACHABLE</code> flags are clear at this point. b. All &quot;heap allocated&quot; elements either (a) are reachable and have a non-zero reference count, or (b) were finalized and their reachability status is unknown. c. The &quot;to be finalized&quot; list is empty. d. No object in the &quot;refzero&quot; work list has been freed.</li><li>Execute pending finalizers unless finalizer execution is prevented or an earlier call site is already finalizing objects. Finalizer execution is outside of mark-and-sweep prevention lock, so mark-and-sweep may run while finalizers are being processed. However, rescue decisions are postponed until the finalize_list is empty to avoid incorrect rescue decisions caused by finalize_list being treated as a reachability root.</li></ol><p>Notes:</p><ul><li>Elements on the refzero list are considered reachability roots, as we need to preserve both the object itself (which happens automatically because we don&#39;t sweep the refzero_list) and its children. (This is no longer relevant because refzero_list is always NULL when mark-and-sweep runs.)</li><li>Elements marked FINALIZABLE are considered reachability roots to ensure that their children (e.g. property values) are not swept during the sweep phase. This would obviously be problematic for running the finalizer, regardless of whether the object would be rescued or not.</li><li>While mark-and-sweep is running: <ul><li>Another mark-and-sweep cannot execute.</li><li>A <code>DECREF</code> resulting in a zero reference count is not processed at all (other than updating the refcount). The object is not placed into the &quot;refzero&quot; work list, as mark-and-sweep is assumed to be a comprehensive pass, including running finalizers.</li></ul></li><li>Finalizers are executed after the sweep phase to ensure that finalizers have as much available memory as possible. Since Duktape 2.1 mark-and-sweep runs outside the mark-and-sweep algorithm, and mark-and-sweep may run while finalizers are being processed, with the limitation that rescue decisions are postponed until finalize_list is empty.</li><li>The sweep phase is divided into two separate scans: one to adjust refcounts and one to actually free the objects. If these were performed in a single heap scan, refcount adjustments might refer to already freed heap elements (dangling pointers). This may happen even without reference counting bugs for unreachable reference loops.</li><li>Clearing the <code>REACHABLE</code> flags explicitly for objects in the &quot;refzero&quot; list is necessary: <ul><li>The &quot;refzero&quot; work list is not processed at all in the sweep phase but the marking phase could theoretically mark objects in the &quot;refzero&quot; work list. Since the sweeping phase is the only place where <code>REACHABLE</code> flags are cleared, some object in the &quot;refzero&quot; work list might be left with its <code>REACHABLE</code> flag set at the end of the algorithm. At first it might seem that this can never happen if reference counts are correct: all objects in the &quot;refzero&quot; work list are unreachable by definition. However, this is not the case for objects with finalizers. (As of Duktape 2.1 refzero_list is freed inline without side effects, so it&#39;s always NULL when mark-and-sweep runs.)</li></ul></li></ul><h2 id="interactions-between-reference-counting-and-mark-and-sweep" tabindex="-1">Interactions between reference counting and mark-and-sweep <a class="header-anchor" href="#interactions-between-reference-counting-and-mark-and-sweep" aria-label="Permalink to &quot;Interactions between reference counting and mark-and-sweep&quot;">​</a></h2><p>If mark-and-sweep is triggered e.g. by an out-of-memory condition, reference counting is essentially &quot;disabled&quot; for the duration of the mark-and-sweep phase:</p><ul><li>Reference counts are updated normally. In fact, mark-and-sweep uses the same refcount macros to update element refcounts while freeing them.</li><li>If a reference count reaches zero due after a <code>DECREF</code> operation, the object is not freed nor is it placed on the &quot;refzero&quot; work list because mark-and-sweep is expected to deal with the object directly.</li></ul><p>If the &quot;refzero&quot; algorithm is triggered first (with some objects in the &quot;refzero&quot; work list), since Duktape 2.1 mark-and-sweep is not triggered while the refzero_list is being processed as refzero_list handling is side effect free.</p><h2 id="finalizer-behavior" tabindex="-1">Finalizer behavior <a class="header-anchor" href="#finalizer-behavior" aria-label="Permalink to &quot;Finalizer behavior&quot;">​</a></h2><p>General notes:</p><ul><li>If reference counting is used, finalizers are called either when reference count drops to zero, or when mark-and-sweep wants to collect the object (which is required for circular references and may also happen if reference counts have been incorrectly updated for whatever reason).</li><li>If mark-and-sweep is used, finalizers are called only when mark-and-sweep wants to collect the object.</li><li>Regardless of whether reference counting or mark-and-sweep (or both) is used, finalizers are executed for all objects (even reachable ones) when a heap is freed.</li><li>Finalizer may reinstate a reference to the target object. In this case the object is &quot;rescued&quot; and its finalizer may be called again if it becomes unreachable again. Regardless of whether an object is rescued or not, it&#39;s a good practice to make the finalizer re-entrant, i.e. allow multiple finalizer calls even if the finalizer doesn&#39;t rescue the object.</li><li>Finalizers are guaranteed to run when objects are collected or when a heap is destroyed forcibly. The Duktape API <code>duk_destroy_heap()</code> call runs a few rounds of mark-and-sweep to allow finalizers for unreachable objects to run normally, and then runs finalizers for all objects on the heap_allocated list regardless of their reachability status. This allows user code to e.g. free any native resources more or less reliably even for reachable objects.</li><li>The finalizer return value is ignored. Also, if the finalizer throws an error, this is only debug logged but is considered to be a successful finalization.</li><li>Finalizers are always executed using <code>heap-&gt;heap_thread</code> in Duktape 2.1. Before Duktape 2.0 the thread used depended on whether the object was finalized via refcounting or mark-and-sweep.</li><li>The finalizer may technically launch other threads and do arbitrary things in general, but it is a good practice to make the finalizer very simple and unintrusive. Ideally it should only operate on the target object and its properties.</li><li>A finalizer should not be able to terminate any threads in the active call stack, in particular the thread which triggered a finalization or the finalizer thread (if these are different).</li></ul><h2 id="voluntary-mark-and-sweep-interval" tabindex="-1">Voluntary mark-and-sweep interval <a class="header-anchor" href="#voluntary-mark-and-sweep-interval" aria-label="Permalink to &quot;Voluntary mark-and-sweep interval&quot;">​</a></h2><p>There are many ways to decide when to do a voluntary mark-and-sweep pass: byte count based, object count based, probabilistic, etc.</p><p>The current approach is to count the number of heap objects and heap strings kept at the end of a mark-and-sweep pass, and initialize the voluntary sweep trigger count based on that as (the computation actually happens using fixed point arithmetic):</p><pre><code>trigger_count = ((kept_objects + kept_strings) * MULT) + ADD

// MULT and ADD are tuning parameters
</code></pre><p>The trigger count is decreased on every memory (re)allocation and free, to roughly measure allocation activity. If the trigger count is below zero when memory is about to be (re)allocated, a a voluntary mark-and-sweep pass is done. When <code>MULT</code> is 1 and <code>ADD</code> is 0, a voluntary sweep is done when the number of alloc/free operations matches the previous heap object/string count.</p><p>When reference counting is enabled, <code>MULT</code> can be quite large (e.g. 10) because only circular references need to be swept. When reference counting is not enabled, <code>MULT</code> should be closer to 1 (or even below). The <code>ADD</code> tuning parameter is not that important; its purpose is to avoid too frequent mark-and-sweep on very small heaps and to counteract some inaccuracy of fixed point arithmetic.</p><h2 id="implementation-issues" tabindex="-1">Implementation issues <a class="header-anchor" href="#implementation-issues" aria-label="Permalink to &quot;Implementation issues&quot;">​</a></h2><h3 id="error-handling" tabindex="-1">Error handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error handling&quot;">​</a></h3><p>When a <code>longjmp()</code> takes place, the C stack is unwound and all references to the unwound part of the stack are lost. To avoid memory leaks and other correctness issues, care must be taken to:</p><ul><li>Ensure that the reference count of every heap-allocated element is correct whenever entering code which may <code>longjmp()</code>.</li><li>Ensure that all heap-allocated objects which should be subject to automatic garbage collection are reachable whenever entering code which may <code>longjmp()</code>.</li><li>Use a <code>setjmp()</code> catchpoint whenever control must be regained to clean up properly.</li></ul><p>To avoid the need for <code>setjmp()</code> catchpoints, many innermost helper functions return error codes rather than throwing errors. This makes error handling a bit easier.</p><h3 id="side-effects-of-memory-management" tabindex="-1">Side effects of memory management <a class="header-anchor" href="#side-effects-of-memory-management" aria-label="Permalink to &quot;Side effects of memory management&quot;">​</a></h3><p>See <code>doc/side-effects.rst</code>.</p><h2 id="misc-notes" tabindex="-1">Misc notes <a class="header-anchor" href="#misc-notes" aria-label="Permalink to &quot;Misc notes&quot;">​</a></h2><h3 id="garbage-collection-of-value-stacks" tabindex="-1">Garbage collection of value stacks <a class="header-anchor" href="#garbage-collection-of-value-stacks" aria-label="Permalink to &quot;Garbage collection of value stacks&quot;">​</a></h3><p>While an ECMAScript function is running, the value stack frame allocated for it has a minimum size matching the &quot;register count&quot; of the function. All of these registers are reachable from a mark-and-sweep viewpoint, even if the values held by the registers are never referenced by the bytecode of the function.</p><p>For instance, any temporaries created during expression evaluation may leave unused but technically reachable values behind. Consider for instance:</p><pre><code>function f(x,y,z) {
  var w = (x + y) + z;
}
</code></pre><p>the bytecode created for this will:</p><ul><li>Compute <code>x + y</code> into a temporary register <code>T</code>.</li><li>Compute <code>T + z</code> into the register allocated for <code>w</code>.</li></ul><p>Before exiting the function, <code>T</code> is reachable for mark-and-sweep. If <code>T</code> is a heap element (e.g. a string), it has a positive reference count.</p><p>The situation is fixed if the function exits or the temporary register <code>T</code> is reused by the evaluation of another expression, so this is not usually a relevant issue. However:</p><ul><li>If a function runs in an infinite loop, such references may never become collectable. Consider, for instance, a main event loop which never exits.</li><li>Even if the function eventually exits, such references may cause an out-of-memory situation before the function exits. The out-of-memory situation may not be recoverable using garbage collection because the values are technically reachable until the exit.</li></ul><p>There is currently no actual solution to this issue, but any code containing an infinite loop should be structured to avoid &quot;dangling values&quot;, e.g. by using an auxiliary function for any computations:</p><pre><code>function stuff() {
  // ...
}

function infloop() {
  for (;;) {
    stuff();
  }
}
</code></pre><p>The issue could be fixed technically by:</p><ul><li>Making the function use an actual stack of values instead of direct register references. This would make function evaluation slower.</li><li>Add a bytecode instruction to &quot;wipe&quot; any registers above a certain index to ensure they contain no bogus references. These could be issued after expression evaluation or in loop headers. This would bloat bytecode.</li></ul><h3 id="function-closures-are-reference-loops-by-default" tabindex="-1">Function closures are reference loops by default <a class="header-anchor" href="#function-closures-are-reference-loops-by-default" aria-label="Permalink to &quot;Function closures are reference loops by default&quot;">​</a></h3><p>Function closures contain a reference loop by default:</p><pre><code>var f = function() {};
print(f.prototype.constructor === f);  // --&gt; true
</code></pre><p>Unless user code explicitly sets a different <code>f.prototype</code>, every function closure requires a mark-and-sweep to be collected which makes plain reference counting unattractive if there are a lot of function temporaries. Such temporaries will then be reachable and only freed when the heap is destroyed. This should be fixed in the future somehow if possible.</p><h3 id="requirements-for-tracking-heap-allocated-objects" tabindex="-1">Requirements for tracking heap allocated objects <a class="header-anchor" href="#requirements-for-tracking-heap-allocated-objects" aria-label="Permalink to &quot;Requirements for tracking heap allocated objects&quot;">​</a></h3><p>Mark-and-sweep only requires a single (forward) linked list to track objects. Objects are inserted at the head, and scanned linearly during mark and sweep. The sweep phase can remove an object by keeping track of its predecessor when traversing the list. The same applies to work lists.</p><p>Reference counting requires the ability to remove an arbitrarily chosen object to be removed from the heap allocated list. To do this efficiently, a double linked list is needed to avoid scanning the list from the beginning.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><ul><li>During object property allocation resize, don&#39;t prevent compaction of other objects in mark-and-sweep.</li><li>Special handling for built-in strings and objects, so that they can be allocated from a contiguous buffer, only freed when heap is freed.</li><li>Incremental mark-and-sweep at least as an option in semi real-time environments.</li><li>Optimize reference count handling in performance critical code sections. For instance: <ul><li>a primitive to INCREF a slice of tagged values would be useful</li><li>often the target of an INCREF can be assumed to be non-NULL; a fast path macro could assert for this but avoid otherwise checking for it</li></ul></li><li>Develop a fix for the function temporary register reachability issue.</li><li>Develop a fix for function instance prototype reference loop issue.</li><li>Add a figure of where objects may reside (string table, heap allocated, refzero work list, mark-and-sweep to be finalized work list).</li></ul>`,204)]))}const f=t(i,[["render",n]]);export{p as __pageData,f as default};
