import{_ as t,c as i,a2 as o,o as n}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"Number-to-string and string-to-number conversions","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/number-conversion.md","filePath":"resource/duktape/doc/number-conversion.md","lastUpdated":1732350347000}'),a={name:"resource/duktape/doc/number-conversion.md"};function r(s,e,l,c,u,d){return n(),i("div",null,e[0]||(e[0]=[o(`<h1 id="number-to-string-and-string-to-number-conversions" tabindex="-1">Number-to-string and string-to-number conversions <a class="header-anchor" href="#number-to-string-and-string-to-number-conversions" aria-label="Permalink to &quot;Number-to-string and string-to-number conversions&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Accurate number-to-string and string-to-number conversion is a non-trivial problem. Duktape incorporates built-in algorithms for these operations to avoid dependence on platform primitives. This is important for several reasons, including: (1) platform primitives may not behave consistently across platforms; (2) they almost never provide enough functionality to fulfill ECMAScript requirements which include, for instance, formatting fractional values in arbitrary radix in the range 2 to 36; (3) and they may have a large code or memory footprint which is a specific concern in Duktape.</p><p>The current number conversion primitives have been implemented in <code>duk_numconv.c</code>, with the header <code>duk_numconv.h</code> providing flags and constants. The script <code>gennumdigits.py</code> is used to generate some tables needed by the implementation.</p><p>The implementation is based on the Dragon4 number-to-string algorithm, with some modifications for handling ECMAScript requirements. Dragon4 requires the use of big integers, so a limited functionality bigint implementation is included in <code>duk_numconv.c</code>; the bignum implementation uses fixed size stack buffers to avoid dynamic memory allocation. Dragon4 is also currently used, rather awkwardly, for string-to-number conversion.</p><p>The current number-to-string approach should produce optimal shortest form (free form) strings, but may not produce optimal fixed format strings. String parsing may not produce optimal results either. These limitations should be fixed later. Known bugs are documented in failing bug testcases.</p><h2 id="ecmascript-number-conversions" tabindex="-1">ECMAScript number conversions <a class="header-anchor" href="#ecmascript-number-conversions" aria-label="Permalink to &quot;ECMAScript number conversions&quot;">​</a></h2><p>ECMAScript requires number-to-string conversion (or more specifically, IEEE double to string conversion) in the following places:</p><ul><li><code>ToString()</code> coercion of numbers, E5.1 Section 9.8.1. ToString() only uses decimal conversion (radix 10).</li><li><code>Number.prototype.toString([radix])</code> allows conversion to arbitary radix in the range 2 to 36. E5.1 Section 15.7.4.2 states that the algorithm used should be a generalization of E5.1 Section 9.8.1.</li><li><code>Number.prototype.toFixed(fractionDigits)</code> converts a number to a string with a specified number of fraction digits (0 to 20), radix 10 only. If the absolute value of the input is &gt;= 10^21, <code>ToString()</code> is used instead.</li><li><code>Number.prototype.toExponential(fractionDigits)</code> converts a number to a string in exponential notation with a specified number of fraction digits following the single lead digit and the decimal point, radix 10 only. If <code>fractionDigits</code> is not given, outputs the shortest</li><li><code>Number.prototype.toPrecision(precision)</code> converts a number to a string with a specified number of digits, radix 10 only. The N-digit representation is rounded if necessary, and exponent notation is used if certain conditions are triggered (the specifics are a bit complicated and discussed below).</li><li><code>JSON.stringify()</code> serializes numbers using <code>ToString()</code>.</li></ul><p>String-to-number conversion (or more specifically, string to IEEE double conversion) is required in the following places:</p><ul><li>ECMAScript compilation uses a <code>NumericLiteral</code> production, whose parsing semantics are given in E5.1 Section 7.8.3. Radix 10 only.</li><li><code>ToNumber()</code> coercion of strings, E5.1 Section 9.3.1. Radix 10 only.</li><li>Global object <code>parseInt(string,radix)</code>, E5.1 Section 15.1.2.2. Parses only integer values, in any radix, and stops parsing when a non-digit is encountered (e.g. &quot;1.234&quot; is parsed as &quot;1&quot;).</li><li>Global object <code>parseFloat(string)</code>, E5.1 Section 15.1.2.3. Radix 10 only.</li><li><code>JSON.parse()</code> parses JSON data as a restricted form of ECMAScript syntax. JSON number literals match the production <code>JSONNumber</code> which is a subset of <code>NumericLiteral</code>. Notably, <code>JSONNumber</code> does not allow hex literals, does not allow fractions without a leading integer part (e.g. &quot;.123&quot; is rejected), and only allows an optional negative sign (not a plus sign).</li></ul><p>The specific requirements for each of these primitives is discussed below (not exhaustively though).</p><p>At a high level, the functionality needed for number-to-string conversion includes:</p><ul><li>Conversion of an IEEE double into a string in an arbitrary radix in the range 2 to 36, supporting fractional digits even for non-decimal radix values.</li><li>Shortest form (free form) and fixed form formatting. Fixed form formatting needs to support both relative precision (number of digits) as well as absolute precision (formatting to a certain number of fractions).</li><li>Plain and exponential format. Exponential format for non-base-10 is not explicitly required.</li><li>Special handling of NaN and +/- Infinity (output &quot;NaN&quot;, &quot;Infinity&quot;, or &quot;-Infinity&quot;).</li><li>The primitive should produce the shortest possible string which converts back exactly to the original number. However, this is not actually required (just nice to have).</li><li>The specification does <em>not</em> require that <code>ToNumber(ToString(x)) === x</code> (except for -0, which loses its sign in the process). However, this property is very desirable.</li></ul><p>For string-to-number conversion, the high level functionality includes:</p><ul><li>Conversion of an arbitrary decimal number into an IEEE double. Support for parsing arbitrary numbers in radix values other than 10 is not required.</li><li>Conversion of an arbitrary integer in any radix in the range 2 to 36 into an IEEE double.</li><li>Supporting a variety of small lexical differences in the ECMAScript &quot;call sites&quot;: recognizing &quot;0x&quot;/&quot;0X&quot; hex notation and leading zero octal notation, allowing or rejecting leading and trailing whitespace, allowing or rejecting trailing garbage, treating the empty string as zero (vs. NaN), etc.</li><li>In some cases <code>Infinity</code> (and <code>-Infinity</code>) need to be recognized. <code>NaN</code> is not recognized but some primitives produce a NaN for any number which cannot be parsed correctly (e.g. both &quot;NaN&quot; and &quot;foobar&quot; would produce a NaN).</li></ul><p>Note that although it is possible to format an arbitrary number into any radix in the range 2 to 36 (even fractions), there is no primitive to parse non-integer numbers back in any other radix than 10.</p><h2 id="notes-on-ecmascript-number-to-string-conversion" tabindex="-1">Notes on ECMAScript number-to-string conversion <a class="header-anchor" href="#notes-on-ecmascript-number-to-string-conversion" aria-label="Permalink to &quot;Notes on ECMAScript number-to-string conversion&quot;">​</a></h2><h3 id="tostring-and-number-prototype-tostring" tabindex="-1">ToString() and Number.prototype.toString() <a class="header-anchor" href="#tostring-and-number-prototype-tostring" aria-label="Permalink to &quot;ToString() and Number.prototype.toString()&quot;">​</a></h3><p>The algorithm in E5.1 Section 9.8.1 has specific rules when to fall back to exponent notation.</p><p>In case the final digit is not well defined (two digits are equally acceptable) ToString() doesn&#39;t strictly require that either one be chosen. However, the specification recommends that an even last digit be favored over an odd last digit. (E5.1 Section 9.8.1, NOTE 2.)</p><p>When the radix is not 10, E5.1 does not specify exact requirements but suggests that something analogous to the decimal conversion algorithm be used. The specification leaves open, for instance, what to do with exponential notation when radix is not 10. The Dragon4 paper formats the exponent value in the target radix (B); another reasonable choice is to format the exponent always in base 10. Regardless, the exponent separator character (&#39;e&#39;) becomes difficult to parse when radix is 15 or above, and the digit &#39;e&#39; is also used for the digits. Consider, for instance, the base 16 value:</p><pre><code>1.faecee+1c == 1.faece * 16^(0x1c)
</code></pre><p>Let&#39;s look at the format selection process; from E5.1 Section 9.8.1:</p><ul><li>Step 5: Otherwise, let n, k, and s be integers such that k &gt;= 1, 10^(k-1) &lt;= s &lt; 10^k, the Number value for s x 10^(n-k) is m, and k is as small as possible. Note that k is the number of digits in the decimal representation of s, that s is not divisible by 10, and that the least significant digit of s is not necessarily uniquely determined by these criteria.</li><li>Step 6: If k &lt;= n &lt; 21, return the String consisting of the k digits of the decimal representation of s (in order, with no leading zeroes), followed by n-k occurrences of the character &#39;0&#39;.</li><li>Step 7: If 0 &lt; n &lt;= 21, return the String consisting of the most significant n digits of the decimal representation of s, followed by a decimal point &#39;.&#39;, followed by the remaining k-n digits of the decimal representation of s.</li><li>Step 8: If -6 &lt; n &lt;= 0, return the String consisting of the character &#39;0&#39;, followed by a decimal point &#39;.&#39;, followed by -n occurrences of the character &#39;0&#39;, followed by the k digits of the decimal representation of s.</li><li>Step 9: Otherwise, if k = 1, return the String consisting of the single digit of s, followed by lowercase character &#39;e&#39;, followed by a plus sign &#39;+&#39; or a minus sign &#39;-&#39; according to whether n-1 is positive or negative, followed by the decimal representation of the integer abs(n-1) (with no leading zeroes).</li></ul><p>First, examples of the selection of n, k, and s:</p><pre><code>1.2345  --&gt; s = 12345, k = 5, n = 1
        --&gt; s x 10^(n-k) = 12345 * 10^(1-5) = 12345 * 10^(-4)
                         = 1.2345
</code></pre><p>Note that the naming of the variables differs from that used e.g. in the Burger-Dybvig paper:</p><ul><li><code>s</code> is the integer representation of digits (minimal length); in Burger-Dybvig this is named <code>f</code>.</li><li><code>k</code> is the digit length of <code>s</code>.</li><li><code>n</code> indicates the position of the leading digit of <code>s</code>, with n=0 being the first fraction (0.X), n=1 being the least significant integer position (X.0), n=2 being the &quot;tens&quot; position (X0.0) etc. In Burger-Dybvig this is named <code>k</code> (!).</li></ul><h3 id="tofixed" tabindex="-1">toFixed() <a class="header-anchor" href="#tofixed" aria-label="Permalink to &quot;toFixed()&quot;">​</a></h3><p>If the absolute value of the input is 1e21 or above, behaves like ToString(). Otherwise outputs the number in decimal notation with fractionDigits trailing the decimal point. If no fractionDigits is given, behaves as if the value was zero, in which case no decimal point and no fractional digits are output.</p><p>Example:</p><ul><li>(123).toFixed(3) -&gt; &quot;123.000&quot;</li><li>(0.1).toFixed(0) -&gt; &quot;0&quot;</li><li>(0.9).toFixed(0) -&gt; &quot;1&quot; (rounds up)</li><li>(1e21).toFixed(10) -&gt; &quot;1e+21&quot; (falls back to ToString())</li></ul><h3 id="toexponential" tabindex="-1">toExponential() <a class="header-anchor" href="#toexponential" aria-label="Permalink to &quot;toExponential()&quot;">​</a></h3><p>If 0 digits are requested, the decimal period is omitted:</p><ul><li>(123).toExponential(0) -&gt; &quot;1e+2&quot;</li></ul><p>If &gt; 0 digits (but less than 21; fractionDigits must be in range [0,20]) are requested, a single leading digit (0-9) followed by a decimal point and fractionDigits are output:</p><ul><li>(12345).toExponential(2) -&gt; &quot;1.23e+4&quot;</li></ul><p>If fractionDigits is <code>undefined</code>, the shortest form which ensures that the number parses back appropriately (&quot;free form&quot;) is used:</p><ul><li>(12345).toExponential() -&gt; &quot;1.2345e+4&quot;</li><li>(0.1).toExponential() -&gt; &quot;1e-1&quot;</li></ul><h3 id="toprecision" tabindex="-1">toPrecision() <a class="header-anchor" href="#toprecision" aria-label="Permalink to &quot;toPrecision()&quot;">​</a></h3><p>If N digits are requested and the digits end before the decimal period or if the topmost (most significant) digit has an exponent of -7 or less (in other words, it is the seventh or later digit after the decimal point), toPrecision() uses an exponent notation. Examples:</p><ul><li>(1234).toPrecision(4) -&gt; &quot;1234&quot;</li><li>(1234).toPrecision(3) -&gt; &quot;1.23e+3&quot;</li><li>(9876).toPrecision(3) -&gt; &quot;9.88e+3&quot; (rounding up is necessary)</li><li>(9999).toPrecision(3) -&gt; &quot;1.00e+4&quot; (rounding up and carrying over the leading digit is necessary)</li><li>(0.000001).toPrecision(2) -&gt; &quot;0.0000010&quot;</li><li>(0.0000001).toPrecision(2) -&gt; &quot;1.0e-7&quot;</li></ul><p>Note that leading fractional zeroes are prepended if necessary. Trailing zeroes are not appended to reach the decimal point from above.</p><h2 id="notes-on-ecmascript-string-to-number-conversion" tabindex="-1">Notes on ECMAScript string-to-number conversion <a class="header-anchor" href="#notes-on-ecmascript-string-to-number-conversion" aria-label="Permalink to &quot;Notes on ECMAScript string-to-number conversion&quot;">​</a></h2><h3 id="lexical-trivia-differences-in-call-sites" tabindex="-1">Lexical trivia differences in call sites <a class="header-anchor" href="#lexical-trivia-differences-in-call-sites" aria-label="Permalink to &quot;Lexical trivia differences in call sites&quot;">​</a></h3><p>The following table summarizes the lexical trivia differences between the variants appearing in the specification:</p><hr><p>Feature NumericLiteral ToNumber() parseInt() parseFloat() JSON.parse()</p><hr><p>Leading no [1a] yes yes yes no [5a] whitespace</p><p>Trailing no [1a] yes yes yes no [5a] whitespace</p><p>Trailing garbage no [1a] no yes [3a] yes [4a] no [5a]</p><p>Leading zeroes no yes yes [3b] yes no</p><p>Allow plus sign no [1b] yes yes yes no</p><p>Allow minus sign no [1b] yes yes yes yes</p><p>Allow fractions yes (decimal) yes no yes yes</p><p>Allow fraction yes yes n/a (= NaN) yes no w/o leading<br> integer (e.g.<br> &quot;.123&quot;)</p><p>Allow fraction yes yes yes [3c] yes no w/o fraction<br> digits (e.g.<br> &quot;123.&quot;)</p><p>Allow hex yes yes yes no no (integer)</p><p>0x/0X hex yes yes yes [3d] no no (integer)</p><p>Empty == zero no yes no (= NaN) no (= NaN) no</p><p>Allow arbitrary no no yes no no radix</p><p>Parse Infinity no [1c] yes no (= NaN) yes no</p><p>Parse +Infinity no [1c] yes no (= NaN) yes no</p><p>Parse -Infinity no [1c] yes no (= NaN) yes no</p><h2 id="parse-nan-no-1c-no-2a-no-nan-no-4b-nonan-nan" tabindex="-1">Parse NaN no [1c] no [2a] (= no (= NaN) no [4b] (= no NaN) NaN) <a class="header-anchor" href="#parse-nan-no-1c-no-2a-no-nan-no-4b-nonan-nan" aria-label="Permalink to &quot;Parse NaN        no \\[1c\\]        no \\[2a\\] (= no (= NaN)   no \\[4b\\] (=   no
                                    NaN)                      NaN)&quot;">​</a></h2><p>Notes:</p><ul><li>[1a]: Lexer will eat whitespace and terminate numeric literal at unexpected characters, e.g. &quot; 1+2&quot; parses as the tokens &quot;1&quot;, &quot;+&quot;, &quot;2&quot;. The literal must not be followed immediately by a DecimalDigit or IdentifierStart (e.g. &quot;3in&quot; is a SyntaxError, and is not parsed as &quot;3&quot; followed by &quot;in&quot;).</li><li>[1b]: An explicit sign is parsed as an unary plus/minus operator, e.g. &quot;+123&quot; is parsed as the tokens &quot;+&quot;, &quot;123&quot;.</li><li>[1c]: &quot;NaN&quot; and &quot;Infinity&quot; are value properties of the global object, so the expressions &quot;Infinity, &quot;+Infinity&quot;, &quot;-Infinity&quot;, &quot;NaN&quot; will evaluate to the expected numeric values. However, these expressions are not handled through number parsing but through identifier resolution. For instance, &quot;-Infinity&quot; parses as &quot;-&quot; (unary minus) and identifier reference &quot;Infinity&quot;.</li><li>[2a]: &quot;NaN&quot; is not included in the StringNumericLiteral production, but any non-parseable number will parse back as a NaN. For instance, both &quot;NaN&quot; and &quot;foobar&quot; will parse back as NaN.</li><li>[3a]: Allows trailing whitespace, because parsing tolerates trailing non-digit garbage. Also a decimal point is interpreted as garbage, e.g. &quot;1.23&quot; is parsed as &quot;1&quot;.</li><li>[3b]: Leading zeroes may trigger automatical octal mode in some implementations. E.g. in V8, parseInt(&quot;0009&quot;) returns 0 because V8 switches to octal mode, and treats &#39;9&#39; as garbage; parseInt(&quot;0009&quot;, 10) returns the correct value 9.</li><li>[3c]: Decimal point is interpreted as a garbage digit and terminates literal, so &quot;123.&quot; is interpreted as &quot;123&quot;, so it gets the right numeric value even though a decimal point is not explicitly allowed (same as e.g. &quot;123@&quot;).</li><li>[3d]: Interprets leading &quot;0x&quot; and &quot;0X&quot; specially if radix not given or radix is 16.</li><li>[4a]: Allows trailing garbage; the algorithm in E5.1 Section 15.1.2.3 finds the longest prefix which matches <code>StrDecimalLiteral</code> (the same production used by string <code>ToNumber()</code>) and thus essentially chops off trailing garbage.</li><li>[4b]: &quot;NaN&quot; is not included in StrDecimalLiteral, but all non-parseable values parse as NaN.</li><li>[5a]: JSON parser will eat whitespace.</li></ul><h3 id="white-space" tabindex="-1">White space <a class="header-anchor" href="#white-space" aria-label="Permalink to &quot;White space&quot;">​</a></h3><ul><li><p>ToNumber() accepts white space StrWhiteSpaceChar:</p><pre><code>StrWhiteSpaceChar::
  WhiteSpace
  LineTerminator

WhiteSpace::
  &lt;TAB&gt; | &lt;VT&gt; | &lt;FF&gt; | &lt;SP&gt; | &lt;NBSP&gt; | &lt;BOM&gt;
  &lt;USP&gt;   (Other category &quot;Zs&quot;)

LineTerminator::
  &lt;LF&gt; | &lt;CR&gt; | &lt;LS&gt; | &lt;PS&gt;
</code></pre><p>StrWhiteSpaceChar matches the characters that String.prototype.trim() considers white space (E5.1 Section 15.5.4.20).</p></li><li><p>parseInt() and parseFloat() strip using StrWhiteSpaceChar.</p></li><li><p>NumericLiteral and JSONNumber do not accept white space (it&#39;s not necessary because the ECMAScript/JSON parser will deal with whitespace on its own)</p></li></ul><h3 id="infinity" tabindex="-1">Infinity <a class="header-anchor" href="#infinity" aria-label="Permalink to &quot;Infinity&quot;">​</a></h3><p>The string &quot;Infinity&quot; is parsed as an infinity-value in some contexts. In other contexts, it may be a valid number value, e.g.:</p><pre><code>&gt; parseFloat(&#39;Infinity&#39;)
Infinity
&gt; parseInt(&#39;Infinity&#39;, 36)
1461559270678
</code></pre><h3 id="zero" tabindex="-1">Zero <a class="header-anchor" href="#zero" aria-label="Permalink to &quot;Zero&quot;">​</a></h3><p>Zero sign must be respected, e.g.:</p><pre><code>&gt; 1/JSON.parse(&#39;0&#39;)
Infinity
&gt; 1/JSON.parse(&#39;-0&#39;)
-Infinity
</code></pre><h3 id="numericliteral-notes" tabindex="-1">NumericLiteral notes <a class="header-anchor" href="#numericliteral-notes" aria-label="Permalink to &quot;NumericLiteral notes&quot;">​</a></h3><p>Decimal numbers can have fractions and an exponent part. Hexadecimal values are prefixed with &quot;0x&quot; or &quot;0X&quot; and can only be integers.</p><p>Octal values are optional to support and begin with a leading zero. Implementations have varying behavior for dealing with inputs like &quot;0779&quot;.</p><p>The specification explicitly allows ignoring decimal digits beyond the 20th digit and allows the 20th digit to be rounded upwards. This makes it easier to parse numbers with extremely large mantissa values, e.g. &quot;1&lt;million zeros&gt;e-1000000&quot; which has the numeric value 1. The parser can parse the first 20 digits (&#39;1&#39; followed by 19 &#39;0&#39; digits), and ignore the rest of the digits (999981 zero digits), keeping track of their count. The exponent part is then adjusted by the number of ignored digits, yielding &quot;10000000000000000000&quot; as the mantissa and -1000000 + 999981 = -19 as the exponent; in other words, the number is treated the same as &quot;10000000000000000000e-19&quot;. This is easier to process and ensures that there is an upper bound to the size of the internal big integers representing intermediate values.</p><p>Similar mantissa chopping limits can be established for non-decimal inputs. See <code>gennumdigits.py</code>.</p><h3 id="tonumber" tabindex="-1">ToNumber() <a class="header-anchor" href="#tonumber" aria-label="Permalink to &quot;ToNumber()&quot;">​</a></h3><p>Trailing garbage produces a NaN:</p><pre><code>&gt; +&quot;   123&quot;
123
&gt; +&quot;   123foo&quot;
NaN
</code></pre><h3 id="parseint-notes" tabindex="-1">parseInt() notes <a class="header-anchor" href="#parseint-notes" aria-label="Permalink to &quot;parseInt() notes&quot;">​</a></h3><p>None.</p><h3 id="parsefloat-notes" tabindex="-1">parseFloat() notes <a class="header-anchor" href="#parsefloat-notes" aria-label="Permalink to &quot;parseFloat() notes&quot;">​</a></h3><p>None.</p><h3 id="json-parse-notes" tabindex="-1">JSON.parse() notes <a class="header-anchor" href="#json-parse-notes" aria-label="Permalink to &quot;JSON.parse() notes&quot;">​</a></h3><p>A leading plus sign is not allowed for the significand:</p><pre><code>1.23    // allowed
-1.23   // allowed
+1.23   // rejected
</code></pre><p>However, the exponent part uses the <code>ExponentPart</code> production which allows all of the following:</p><pre><code>1.23e1
1.23e+1
1.23e-1
</code></pre><h3 id="octal-support" tabindex="-1">Octal support <a class="header-anchor" href="#octal-support" aria-label="Permalink to &quot;Octal support&quot;">​</a></h3><p>Section B.1.1 of the E5.1 specification includes octal syntax for parsing literal numbers; there is no official octal syntax for numbers converted with ToNumber() or its equivalents. However, practical implementations will parse octal also in such contexts; as an example, V8 and Rhino:</p><pre><code>&gt; parseInt(&#39;077&#39;)
63
</code></pre><p>Octal syntax is similar to automatic hex syntax, in that (1) it is detected based on a prefix (a leading zero followed by at least one octal digit), and (2) it is only applied to integers.</p><p>Both Rhino and V8 also have a feature that if a number begins with an octal prefix but turns out to contain decimal digits other than octal digits (i.e. &#39;8&#39; and &#39;9&#39;), the number is parsed as a decimal integer (this behavior requires multiple passes or back-tracking):</p><pre><code>js&gt; eval(&#39;077&#39;)
63
js&gt; eval(&#39;088&#39;)
88
js&gt; eval(&#39;099&#39;)
99
</code></pre><p>However, this is not the case in contexts which allow trailing garbage to end number parsing. Behavior also differs; V8 stops parsing at the offending digit and emitting the result of the valid prefix:</p><pre><code>&gt; parseInt(&#39;077&#39;)
63
&gt; parseInt(&#39;088&#39;)
0
&gt; parseInt(&#39;099&#39;)
0
&gt; parseInt(&#39;0789&#39;)    // parsed as &#39;07&#39;
7
&gt; parseInt(&#39;07789&#39;)   // parsed as &#39;077&#39;
63
</code></pre><p>Rhino will return a NaN if the offending digit follows the leading octal zero immediately, but otherwise behaves like V8:</p><pre><code>js&gt; parseInt(&#39;077&#39;)
63
js&gt; parseInt(&#39;088&#39;)
NaN
js&gt; parseInt(&#39;099&#39;)
NaN
js&gt; parseInt(&#39;0789&#39;)
7
js&gt; parseInt(&#39;07789&#39;)
63
</code></pre><h2 id="literature" tabindex="-1">Literature <a class="header-anchor" href="#literature" aria-label="Permalink to &quot;Literature&quot;">​</a></h2><h3 id="number-to-string-output-problem" tabindex="-1">Number-to-string (&quot;output problem&quot;) <a class="header-anchor" href="#number-to-string-output-problem" aria-label="Permalink to &quot;Number-to-string (\\&quot;output problem\\&quot;)&quot;">​</a></h3><p>Number-to-string conversion is a well researched problem, with a lot of solutions. Dragon4 is an old but well established algorithm which requires big integer arithmetic for ensuring correct and minimal length output. It is described in:</p><ul><li>Guy L. Steele Jr., Jon L. White: &quot;How to Print Floating-Point Numbers Accurately&quot;, 1990.</li></ul><p>Many improvements on the basic algorithm exist. For instance, Burger and Dybvig optimize one aspect of the algorithm (scaling) using a logarithm estimate (this paper is also the basis for the current implementation):</p><ul><li>Robert G. Burger, R. Kent Dybvig: &quot;Printing Floating-Point Numbers Quickly and Accurately&quot;, 1996.</li></ul><p>Gay discusses many practical optimizations and other implementation issues, and also discusses the reverse problem of number parsing:</p><ul><li>David M. Gay: &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot;, 1990.</li><li>This (and <code>dtoa</code>) is also referred to in the E5.1 specification, see Section 9.8.1.</li></ul><p>Gay&#39;s observations have been incorporated in the <code>dtoa</code> implementation:</p><ul><li><a href="http://www.netlib.org/fp/dtoa.c" target="_blank" rel="noreferrer">http://www.netlib.org/fp/dtoa.c</a></li></ul><p>Grisu3 is a quite recent hybrid algorithm which handles about 99.5% of input numbers very quickly, using a fixed-size software floating point approach (with a mantissa of 64 bits); the remaining 0.5% of inputs need to fall back to a traditional approach (e.g. Dragon4).</p><ul><li>Florian Loitsch: &quot;Printing Floating-Point Numbers Quickly and Accurately With Integers&quot;, 2010. <a href="http://www.sengupta.net/musings/2012/07/grisu/" target="_blank" rel="noreferrer">http://www.sengupta.net/musings/2012/07/grisu/</a></li></ul><p>Grisu3 is the basis of number conversion in Google V8, and has been encapsulated in the following library:</p><ul><li><a href="https://code.google.com/p/double-conversion/" target="_blank" rel="noreferrer">https://code.google.com/p/double-conversion/</a></li></ul><p>This library has (comparatively) a very large memory footprint, as it incorporates two libraries and uses large lookup tables.</p><h3 id="string-to-number-input-problem" tabindex="-1">String-to-number (&quot;input problem&quot;) <a class="header-anchor" href="#string-to-number-input-problem" aria-label="Permalink to &quot;String-to-number (\\&quot;input problem\\&quot;)&quot;">​</a></h3><p>Superficially string-to-number conversion is similar to number-to-string conversion: in both cases, a number is converted from one radix to another. However, the problems are actually different, which is also reflected in the algorithms:</p><ul><li>A string-to-number conversion may result in an overflow (infinity) or an underflow (zero) even when the input is not infinity/zero.</li><li>A string-to-number conversion may need to deal with arbitrarily large mantissa values and exponent values, even when the number represented is finite. For instance, 123 can be represented as &quot;123000e-3&quot; or equivalently as &quot;123&lt;million zeroes&gt;e-1000000&quot;. For number-to-string conversion, the mantissa and exponent are always in strict, unique format.</li><li>A string-to-number conversion converts from a representation without a fixed accuracy limit (decimal digits of arbitrary length) to a representation with a fixed accuracy limit (IEEE double). In number-to-string conversion the roles are reversed: conversion is from a limited accuracy representation to an unlimited accuracy representation.</li></ul><p>The input problem is also well researched. One important paper is:</p><ul><li>William D. Clinger: &quot;How to Read Floating Point Numbers Accurately&quot;, 1990.</li></ul><h3 id="notes-on-existing-algorithms" tabindex="-1">Notes on existing algorithms <a class="header-anchor" href="#notes-on-existing-algorithms" aria-label="Permalink to &quot;Notes on existing algorithms&quot;">​</a></h3><p>There don&#39;t seem to be any accurate algorithm which doesn&#39;t need bigints for at least some input values.</p><p>Some conversion algorithms prefer speed over code size; for instance, Grisu3 suggests using 8 kilobytes of precomputed powers of 10. This is unacceptable for Duktape, considering that the entire regular expression engine is about 8 kilobytes in code footprint.</p><p>It&#39;s important to optimize for typical cases, but simultaneously correctness needs to be preserved for all inputs. Many different shortcuts have been incorporated into practical conversion algorithms. For embedded use, printing small integers should be very fast (and can easily bypass the generic hard case algorithm).</p><h2 id="current-solution" tabindex="-1">Current solution <a class="header-anchor" href="#current-solution" aria-label="Permalink to &quot;Current solution&quot;">​</a></h2><p>The current algorithm is a variant of Dragon4, based on the unoptimized (basic) algorithm in Figure 1 the Burger-Dybvig paper for free-format output. Fixed format output has been implemented on top of the free-format algorithm by working in options to generate additional digits, and then rounding explicitly (instead of generating the correct result directly). String-to-number conversion uses the same basic algorithm with minor tweaks. The basic algorithm allows input and output bases to be arbitrary to support both conversion directions.</p><p>The current solution should be correct for free-form output but there are some fixed-format corner cases which don&#39;t work correctly now (all known cases should have bug testcases illustrating the problem).</p><p>The implementation uses a bigint implementation which has an upper limit on integer size, and the buffers needed are stack allocated. This is good in general and also improves cache coherence. However, the bigint code is pure, portable C, and inefficient compared to an assembler implementation.</p><p>There is a fast path for 32-bit integers (the range [-2*<em>32-1,2</em>*32-1]). Embedded software is likely to work a lot with small integers, and is also likely to print out many integers. Other Dragon4 optimizations have not been included in the implementation, in an attempt to keep code footprint as small as possible.</p><h2 id="implementation-notes" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h2><h3 id="bigint-operations-and-size-limit" tabindex="-1">Bigint operations and size limit <a class="header-anchor" href="#bigint-operations-and-size-limit" aria-label="Permalink to &quot;Bigint operations and size limit&quot;">​</a></h3><p>Dragon4 requires &gt;= 1050-bit integer arithmetic for IEEE doubles. Operations needed include: add, subtract, compare, multiply, divide by radix, divide one bigint by another with the result known to be in the range 0...radix-1 (allowing some special case code). 1050 bits rounds up to 33 x 32-bit integers, i.e. 132 bytes. Allocating, say, 4 such slots from the stack should not be an issue.</p><p>Typical number-to-string conversion requires much fewer bits, so the arithmetic should be tuned to small numbers.</p><p>The current implementation has bignum size limits larger than this to accommodate string-to-number conversion in addition to number-to-string conversion. See <code>BI_MAX_PARTS</code> in <code>duk_numconv.c</code>.</p><h3 id="precomputed-tables" tabindex="-1">Precomputed tables <a class="header-anchor" href="#precomputed-tables" aria-label="Permalink to &quot;Precomputed tables&quot;">​</a></h3><p>Having 10^k tabulated for 326 values would take too much memory: each value would be a big integer. One could use a more sparse table, e.g. for every Nth power (10^10, 10^20, 10^30) and multiply the remaining 0-9 steps normally. One could also store binary powers of 10 (10^1, 10^2, 10^4, 10^8, 10^16, 10^32, 10^64, 10^128, and 10^256; a total of 9 values), and use &quot;binary exponentiation&quot; for faster computation:</p><pre><code>10^365 = 10^(1*256 + 0*128 + 1*64 + 1*32 + 0*16 + 1*8 + 1*4 + 0*2 + 1*1)
       = 10^1 * 10^4 * 10^8 * 10^32 * 10^64 * 10^256
</code></pre><p>Given that the current bigint implementation requires about 144 bytes per bigint value, this means a table of about 1.3 kilobytes. By optimizing the memory layout (requiring some ugly C casting) this can be reduced considerably.</p><p>One can also create the exponents on the fly, i.e. compute 10^(2n) from 10^n as 10^n * 10^n = 10^(2n). This technique requires no precomputations and works in every base, and is used by the current implementation for exponentiation.</p><h3 id="fixed-format-output" tabindex="-1">Fixed-format output <a class="header-anchor" href="#fixed-format-output" aria-label="Permalink to &quot;Fixed-format output&quot;">​</a></h3><p>The current approach to fixed-format output is a shortcut: we generate an extra digit and use simple rounding to fix up the digit before that. This may require a carry, which is propagated as needed. If the carry propagates up to the first digit, an extra &#39;1&#39; digit is prepended and &#39;k&#39; is updated.</p><p>Simple case, 4-digit output of 8.88888888:</p><pre><code>8 8 8 8 8      generate one extra digit; k = 1
8 8 8 9 #      round and carry (last digit is irrelevant afterwards)
\`-----&#39;

4-digit result is &quot;8.889&quot;
</code></pre><p>Complex case, for 4-digit output of 9.99999999:</p><pre><code>9 9 9 9 9      generate one extra digit; k = 1
1 0 0 0 0 #      round and carry (last digit is irrelevant afterwards)
\`-----&#39;          carry goes beyond first -&gt; k++ -&gt; k = 2

4-digit result is &quot;10.00&quot;
</code></pre><p>::: note ::: title Note :::</p><p>The current implementation probably does not implement the Number.prototype.toPrecision() semantics exactly correctly. In particular, E5.1 Section 15.7.4.7 step 10.a specifies a specific rounding tie-breaker which we may not follow properly. :::</p><h3 id="stripping-and-unicode" tabindex="-1">Stripping and Unicode <a class="header-anchor" href="#stripping-and-unicode" aria-label="Permalink to &quot;Stripping and Unicode&quot;">​</a></h3><p>Actual number parsing only supports ASCII characters, and will consider any non-ASCII characters garbage. Since the number productions which allow whitespace include non-ASCII characters, whitespace is always trimmed first with a Unicode-aware process. The resulting string can then be processed in pure ASCII.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><ul><li>Improve fixed-format output to be more robust (perhaps adopt an actual, documented algorithm). Currently the fixed-format output approach has several problems.</li><li>In very constrained environments it may be a reasonable tradeoff to use ANSI C number formatting and parsing (and drop a bunch of features, such as arbitrary radix support, some of the precision modes etc), even if it is not fully compatible with ECMAScript semantics. The impact of custom number formatting is about 8-9 kilobytes of code footprint at the moment.</li></ul>`,155)]))}const g=t(a,[["render",r]]);export{h as __pageData,g as default};
