import{_ as i,c as a,a2 as n,o as h}from"./chunks/framework.CuCbyi2k.js";const g=JSON.parse('{"title":"Cスタイル","description":"","frontmatter":{},"headers":[],"relativePath":"resource/dev_guideline/c/c_style.md","filePath":"resource/dev_guideline/c/c_style.md","lastUpdated":1732720247000}'),l={name:"resource/dev_guideline/c/c_style.md"};function t(p,s,k,e,d,r){return h(),a("div",null,s[0]||(s[0]=[n(`<h1 id="cスタイル" tabindex="-1">Cスタイル <a class="header-anchor" href="#cスタイル" aria-label="Permalink to &quot;Cスタイル&quot;">​</a></h1><p><a href="https://github.com/mcinglis/c-style" target="_blank" rel="noreferrer">原文</a></p><p>これらは私が好きなC言語プログラミングの実践方法です。スタイルと同じくらい些細なルールもあれば、もっと入り組んだルールもあります。私はいくつかのルールには忠実に従いますが、他のルールはガイドラインとして使っています。私は、スピードよりも、正しさ、読みやすさ、シンプルさ、保守性を優先しています。なぜなら、「早まった最適化は諸悪の根源」(<a href="http://c2.com/cgi/wiki?PrematureOptimization" target="_blank" rel="noreferrer">http://c2.com/cgi/wiki?PrematureOptimization</a>)だからです。</p><p><strong>正しく、読みやすく、シンプルでメンテナンス可能なソフトウェアを書き、完成したらチューニングする</strong>、ベンチマークでチョークポイントを特定する。また、最新のコンパイラは、計算の複雑さを変えることができます。配列が成長するよりもリンクリストを書く方が簡単ですが、配列のインデックスを作るよりもリストのインデックスを作る方が難しいのです。</p><p>後方互換性（例：ANSI C）は、私にとってほとんど重要ではありません。私の考えでは、後方互換性は皆の足を引っ張ります。できることなら新しい技術や新しい手法を使って、みんなを少しでも前に進ませるべきだと思うのです。</p><p>もし、ここに書かれていることに同意できなくても、それはまったく問題ありません。自分の好きなもの、自分の状況に合ったものを選んでください。これらのルールは、品質に関する普遍的な勧告を意図したものではありません。これは私の好みに過ぎず、私が行うこと、そして私が気にかけることに対してうまく機能しています。</p><p>このガイドを書くことで、私はC言語のベストプラクティスについて深く考え、再考することになりました。この文書に書かれている多くの規則について、私は何度も意見を変えました。</p><p>だから、さらに多くの点で間違っていることは間違いない。これは常に進行中の作業です。問題やプルリクエストは非常に歓迎されます。このガイドは Creative Commons Attribution-ShareAlike] の下でライセンスされていますので、あなたがこれを使って何をしようとも、私は責任を負いません。</p><hr><h4 id="常にすべての警告を表示した状態で開発・コンパイルする。" tabindex="-1">常にすべての警告を表示した状態で開発・コンパイルする。 <a class="header-anchor" href="#常にすべての警告を表示した状態で開発・コンパイルする。" aria-label="Permalink to &quot;常にすべての警告を表示した状態で開発・コンパイルする。&quot;">​</a></h4><p>ここでは言い訳はしません。常に警告をオンにして開発・コンパイルしてください。しかし、<code>-Wall</code> と <code>-Wextra</code> は実際には「すべての」警告を有効にしないことがわかりました。他にも本当に役に立つものがいくつかあります。</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CFLAGS += -Wall -Wextra -Wpedantic </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          -Wformat=2 -Wno-unused-parameter -Wshadow </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          -Wwrite-strings -Wstrict-prototypes -Wold-style-definition </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          -Wredundant-decls -Wnested-externs -Wmissing-include-dirs</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># GCC warnings that Clang doesn&#39;t provide:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ifeq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CC</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,gcc)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CFLAGS += -Wjump-misses-init -Wlogical-op</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">endif</span></span></code></pre></div><p>また、最適化をオンにしてコンパイルすることで、エラーを検出することもできます。</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CFLAGS += -O2</span></span></code></pre></div><h4 id="gcc-と-clang-の-m-を使って、オブジェクトファイルの依存関係を自動生成する。" tabindex="-1">GCC と Clang の <code>-M</code> を使って、オブジェクトファイルの依存関係を自動生成する。 <a class="header-anchor" href="#gcc-と-clang-の-m-を使って、オブジェクトファイルの依存関係を自動生成する。" aria-label="Permalink to &quot;GCC と Clang の \`-M\` を使って、オブジェクトファイルの依存関係を自動生成する。&quot;">​</a></h4><p>GNU Make マニュアル <a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites" target="_blank" rel="noreferrer">touches</a> に、ソースファイルの <code>#include</code>s からオブジェクトファイルの依存関係を自動生成する方法について書かれています。このマニュアルに示されているルールの例は少し複雑です。以下は私が使っているルールです。</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depfiles = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objects:.o=.d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Have the compiler output dependency files with make targets for each</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># of the object files. The \`MT\` option specifies the dependency file</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># itself as a target, so that it&#39;s regenerated when it should be.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.dep.mk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.c</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CC</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -M -MP -MT &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;:.c=.o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&#39; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CPPFLAGS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$@</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Include each of those dependency files; Make will run the rule above</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># to generate each dependency file (if it needs to).</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depfiles</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span></code></pre></div><h4 id="できるだけ最新の規格で書きましょう" tabindex="-1">できるだけ最新の規格で書きましょう <a class="header-anchor" href="#できるだけ最新の規格で書きましょう" aria-label="Permalink to &quot;できるだけ最新の規格で書きましょう&quot;">​</a></h4><p>C11 は C99 よりも優れており、C89 よりも (はるかに) 優れています。C11のサポートはGCCとClangではまだこれからですが、多くの機能があります。もし、中期的に他のコンパイラをサポートする必要があるならば、C99に書きましょう。</p><p>常に <code>-std=c11</code> のように <em>標準</em> で書いてください。<code>gnu11</code> のような方言で書いてはいけない。非標準の言語拡張はなるべく使わないようにしましょう。</p><h4 id="タブがうまく使えないので、スペースを多用する。" tabindex="-1">タブがうまく使えないので、スペースを多用する。 <a class="header-anchor" href="#タブがうまく使えないので、スペースを多用する。" aria-label="Permalink to &quot;タブがうまく使えないので、スペースを多用する。&quot;">​</a></h4><p>タブのアイデアは、インデントレベルにタブを使い、アライメントにスペースを使うというものでした。これにより、列の整列を崩すことなく、自分の好きなインデント幅を選択することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pigs_can_fly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">developers_can_use_tabs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;and align columns &quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                         &quot;with spaces!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tab   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>しかし、残念なことに、私たち（そして編集者）は、それが正しく行われることはほとんどありません。タブとスペースの使い分けがもたらす問題は、主に4つあります。</p><ul><li>インデント用のタブは、行の長さに関する意見に矛盾を生じさせます。タブ幅8を使う人は、タブ幅2を使う人よりずっと早く80文字に達してしまいます。これを避ける唯一の方法は、タブ幅を要求することですが、これではタブの利点がなくなってしまいます。</li><li>プロジェクトごとにタブとスペースを正しく処理するようにエディタを設定するのは、スペースだけを処理するよりもはるかに困難です。こちらもご覧ください。<a href="http://www.jwz.org/doc/tabs-vs-spaces.html" target="_blank" rel="noreferrer">タブ vs スペース: 永遠の聖戦</a></li><li>スペースバーだけで整列するのは難しいです。スペースバーを8文字分押し続けるより、タブを2回押す方がずっと簡単です。あなたのプロジェクトの開発者は、いずれこの間違いを犯すでしょう。インデントと位置合わせにスペースを使えば、どちらの状況でもタブキーを押すことができ、素早く、簡単に、ミスが起こりにくくなります。</li><li>スペースだけを使うプロジェクトでは、タブ/スペースのエラーを防ぐのは簡単です。なぜなら、必要なのは、タブがまったくないかどうかを検出するだけだからです。タブを使うプロジェクトで、整列のために使われるタブに対して防止するには、正規表現を考える必要があります。</li></ul><p>複雑なものはカットし、随所にスペースを使用する。時々、他の人のインデント幅に合わせなければならないかもしれません。大変ですね。</p><h4 id="_1行の文字数が79文字を超えてはならない" tabindex="-1">1行の文字数が79文字を超えてはならない <a class="header-anchor" href="#_1行の文字数が79文字を超えてはならない" aria-label="Permalink to &quot;1行の文字数が79文字を超えてはならない&quot;">​</a></h4><p>79文字以上の行は絶対に書かないでください。</p><p>80文字/行は、コードを見るための事実上の標準です。この標準に依存している読者は、ターミナルやエディタを80文字幅に設定していますが、ウィンドウを横に並べれば、より多くの文字を画面に収められます。</p><p>最後の列に常にスペースがあるように、最大79文字にこだわる必要があります。こうすることで、行が次の行に続かないことがより明確になります。また、右側の余白も確保します。</p><p>80文字を超えると、80カラムの標準に依存しようとする人々にとって、あなたのコードが著しく読みにくくなります。行が折り返して読みにくくなるか、読者が最後の数文字を取得するためにウィンドウを右にスクロールしなければならなくなります。いずれにしても、自分で改行した場合よりも読みにくいコードになってしまいます。</p><p>長い行を読むと、次の行の先頭に到達するまでに目が遠くなり、さらに目が遠くなればなるほど、視覚的に再調整しなければならない可能性が高くなるからです。100字幅や120字幅は、書くのは簡単ですが、読むのは大変です。</p><p>79字を超える行があると、読者はその代償を払うことになります。79文字というのはハードリミットのようなもので、「もしも」や「でも」は許されません。長い行をどのように区切るのがベストなのか、読者はあなたに感謝することでしょう。</p><p>他の人たちがやっているように、80カラムの表示を前提に書けば、私たちはより良くなるはずです。</p><ul><li><a href="http://www.emacswiki.org/emacs/EightyColumnRule" target="_blank" rel="noreferrer">Emacs Wiki: Eighty Column Rule</a></li><li><a href="http://programmers.stackexchange.com/questions/604/is-the-80-character-limit-still-relevant-in-times-of-widescreen-monitors" target="_blank" rel="noreferrer">Programmers&#39; Stack Exchange: Is the 80 character limit still relevant?</a></li></ul><h4 id="どこでも-コメントを使用し、決して-を使用しないでください。" tabindex="-1">どこでも <code>//</code> コメントを使用し、決して <code>/* ... を使用しないでください。*/</code> <a class="header-anchor" href="#どこでも-コメントを使用し、決して-を使用しないでください。" aria-label="Permalink to &quot;どこでも \`//\` コメントを使用し、決して \`/* ... を使用しないでください。*/\`&quot;">​</a></h4><p>単一行コメントにこだわり、複雑さを軽減する。単一行コメントと比較して、複数行コメント。</p><ul><li>空白のマージンと共に使用されることはほとんどないため、文字数が多くなってしまいます。</li><li>スタイルを指定し、それに従わなければならない。</li><li>しばしば <code>*/</code> が一行で表示されるため、行数が多くなります。</li><li>埋め込み <code>/*</code> や <code>*/</code> に関する奇妙なルールがある</li><li>ブロック編集や拡張が難しい/できない</li><li>は <code>//</code> よりも視覚的に邪魔になります。</li></ul><p>インラインコメントには <code>/*</code> ... を使用しなければならないしかし、複数行の <code>#define</code> のインラインコメントには <code>/* ...................*/</code> を使わなければなりません。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAGIC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Voodoo magic happens here. */</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span></code></pre></div><p>しかし、私はしばしば <code>//</code> コメントをマクロ本体の後に追加して、トリッキーな部分を説明することを好みます。これにより、マクロ本体が読みやすくなり、かつ（必要な）ドキュメントを提供することができると思います。</p><h4 id="アメリカ英語プログラム" tabindex="-1">アメリカ英語プログラム <a class="header-anchor" href="#アメリカ英語プログラム" aria-label="Permalink to &quot;アメリカ英語プログラム&quot;">​</a></h4><p>同じ言語、同じスペル、同じ語彙で開発することは重要です。これは、世界中の協力者がいるフリーソフトのプロジェクトでは特にそうです。あなたのプロジェクトでは、コード、コメント、文書において、一貫して同じ言語を使うべきです。</p><p>ですから、アメリカ英語では <code>color</code>, <code>flavor</code>, <code>center</code>, <code>meter</code>, <code>neighbor</code>, <code>defense</code>, <code>routing</code>, <code>sizable</code>, <code>burned</code>, などと書きます (<a href="https://en.wikipedia.org/wiki/American_and_British_English_spelling_differences" target="_blank" rel="noreferrer">see more</a>)．私はオーストラリア人ですが、ほとんどのプログラマがアメリカ英語を学び、使っていることを理解しています。また、アメリカ英語のスペリングはイギリス英語よりも一貫して音声的で一貫性があります。このような理由から、イギリス英語はアメリカ英語に向かって進化する傾向があるのだと思います。</p><h4 id="非標準ライブラリの-include-をコメントし、そこからどのシンボルを使用するかを示す" tabindex="-1">非標準ライブラリの <code>#include</code> をコメントし、そこからどのシンボルを使用するかを示す <a class="header-anchor" href="#非標準ライブラリの-include-をコメントし、そこからどのシンボルを使用するかを示す" aria-label="Permalink to &quot;非標準ライブラリの \`#include\` をコメントし、そこからどのシンボルを使用するかを示す&quot;">​</a></h4><p>名前空間は、ソフトウェア開発の大きな進歩の一つです。残念ながら、C言語はこれに乗り遅れました（スコープは名前空間ではありません）。しかし、名前空間はとても素晴らしいものなので、コメントでそれをシミュレートしてみるべきでしょう。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;test.c/test.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Test, tests_run</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;trie.h&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Trie, Trie_*</span></span></code></pre></div><p>これにはいくつかのメリットがあります。</p><ul><li>読者は、シンボルがどこで定義されているか（あるいは、以下のルールに従わない場合、シンボルがどこから来たのか）を知るために、ドキュメントを参照したり、<code>grep</code>を使うことを強制されません：あなたのコードはそれを教えてくれるだけです。</li><li>開発者は、どの <code>#include</code> が削除できて、どの <code>#include</code> が削除できないかを判断できるようになります。</li><li>開発者は名前空間の汚染を考慮することを余儀なくされ、(ほとんどの C コードでは無視される) 小さな、よく定義されたヘッダのみを提供するよう奨励される</li></ul><p>欠点は <code>#include</code> コメントがチェックされない、または強制されないことです。私は長い間、このためのチェッカーを書くつもりでいましたが、今のところ、コメントが間違ってしまうのを止めるものはありません - もう使われていないシンボルに言及したり、使われているシンボルに言及しなかったりします。プロジェクトでは、このような問題の芽を摘み、蔓延を食い止めるようにしましょう。自分のコードを常に信頼できるようにすることです。 このメンテナンスは確かに煩わしいですが、<code>#include</code>コメントは全体で見ればそれだけの価値があると思います。</p><p>コードベースを学習する際に、物事がどこから来たのかを見つけることは、いつも私の大きな課題の一つです。これをもっと簡単にすることができます。このように <code>#include</code> コメントを書いているプロジェクトは見たことがありませんが、ぜひそうなってほしいものです。</p><h4 id="使用するすべてのものの定義を-include-します。" tabindex="-1">使用するすべてのものの定義を <code>#include</code> します。 <a class="header-anchor" href="#使用するすべてのものの定義を-include-します。" aria-label="Permalink to &quot;使用するすべてのものの定義を \`#include\` します。&quot;">​</a></h4><p>ヘッダがインクルードしているものに依存しないようにしましょう。もしあなたのコードがシンボルを使うなら、そのシンボルが定義されているヘッダファイルをインクルードしてください。そうすれば、ヘッダがインクルードするものを変えても、あなたのコードは壊れません。</p><p>また、上記の <code>#include</code> のコメントルールと組み合わせることで、読者や他の開発者が、あなたが使用しているシンボルの定義を見つけるために、インクルードのトレイルをたどる必要がなくなります。あなたのコードは、それがどこから来たのかを伝えるだけで良いのです。</p><h4 id="ヘッダーの統一を避ける" tabindex="-1">ヘッダーの統一を避ける <a class="header-anchor" href="#ヘッダーの統一を避ける" aria-label="Permalink to &quot;ヘッダーの統一を避ける&quot;">​</a></h4><p>なぜなら、ヘッダを統一することで、疎結合のモジュールを目的や抽象度によって明確に分離して提供する責任を、ライブラリ開発者から解放してしまうからです。たとえ開発者（のつもり）でも、統一ヘッダはコンパイル時間を増加させ、ユーザーのプログラムが必要かどうかにかかわらず、ライブラリ全体を結合してしまいます。その他にも、上記の点で触れたように、多くのデメリットがあります。</p><p>Programmers&#39; Stack Exchange](<a href="http://programmers.stackexchange.com/questions/185773/library-design-provide-a-common-header-file-or-multiple-headers" target="_blank" rel="noreferrer">http://programmers.stackexchange.com/questions/185773/library-design-provide-a-common-header-file-or-multiple-headers</a>)で、統一ヘッダに関する良い解説がありました。ある回答は、GTK+のようなものが単一のヘッダーファイルしか提供しないのは合理的であると述べています。私は同意しますが、それはGTK+の設計が悪いからであり、グラフィカルツールキットに内在するものではありません。</p><p>ユーザーが型を書くのが難しいのと同じように、ユーザーが複数の <code>#include</code> を書くのは難しいのです。そこに難しさを持ち込むことは、木を見て森を見ずです。</p><h4 id="すべてのヘッダーにインクルードガードを設け、二重インクルードを防止する。" tabindex="-1">すべてのヘッダーにインクルードガードを設け、二重インクルードを防止する。 <a class="header-anchor" href="#すべてのヘッダーにインクルードガードを設け、二重インクルードを防止する。" aria-label="Permalink to &quot;すべてのヘッダーにインクルードガードを設け、二重インクルードを防止する。&quot;">​</a></h4><p><a href="https://en.wikipedia.org/wiki/Include_guard" target="_blank" rel="noreferrer">インクルードガード</a> は、コンパイルを中断することなく、ヘッダーファイルを「2回」インクルードできるようにします。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifndef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> INCLUDED_ALPHABET_H</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> INCLUDED_ALPHABET_H</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ifndef INCLUDED_ALPHABET_H</span></span></code></pre></div><p><a href="http://www.lysator.liu.se/c/pikestyle.html" target="_blank" rel="noreferrer">Rob Pikeはインクルードガードに反対しています</a>。インクルードファイルの中に決してファイルを含めないようにすればいいと言っています。彼は、インクルードガードは依然として「字句解析器を通過する何千行もの不要なコードをもたらす」と述べています。</p><p>実際、<a href="http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html" target="_blank" rel="noreferrer">GCCはインクルードガードを検出します</a>。そして、そのようなファイルを二度読みすることはありません。ほかのコンパイラがこの最適化を行うかどうか、わたしは知りません。</p><p>わたしは、ユーザがあなたのヘッダファイルの依存関係をインクルードすることを要求するのは良い考えだとは思いません。あなたのヘッダーファイルの依存関係は、本当は「公開」とみなされるべきではないのです。ヘッダファイルがインクルードしているものには依存しない」というルールを強制することになりますが、ヘッダファイルが <code>FILE</code> や <code>bool</code> のような必要ないものを使っているとすぐに崩れてしまいます。ユーザは、自分が必要としないのであれば、そんなことを気にする必要はないはずです。</p><p>ですから、常にインクルードガードを書き、ユーザを楽にしてあげましょう。</p><h4 id="大きな条件部分は必ず-endif-をコメントする。" tabindex="-1">大きな条件部分は必ず <code>#endif</code> をコメントする。 <a class="header-anchor" href="#大きな条件部分は必ず-endif-をコメントする。" aria-label="Permalink to &quot;大きな条件部分は必ず \`#endif\` をコメントする。&quot;">​</a></h4><h4 id="グローバル変数やスタティック変数の使用は避けてください。" tabindex="-1">グローバル変数やスタティック変数の使用は避けてください。 <a class="header-anchor" href="#グローバル変数やスタティック変数の使用は避けてください。" aria-label="Permalink to &quot;グローバル変数やスタティック変数の使用は避けてください。&quot;">​</a></h4><p>グローバル変数は、それを使用するすべての関数の隠れた引数に過ぎません。そのため、関数が何をしているのか、どのように制御されているのかを理解するのがとても難しくなっています。</p><p>Mutable なグローバル変数は特に悪であり、何としてでも避けるべきものです。概念的には、グローバル変数の代入は、隠された静的な変数を設定するための <code>longjmp</code> の束なのです。うっそー。</p><p>関数は常に引数で完全に制御できるように設計することを心がけなければなりません。たとえ多くの関数に渡さなければならない変数があったとしても、それが関数の計算に影響を与えるのであれば、それは引数か引数のメンバであるべきです。これは、常に、より良いコードとより良い設計につながります。</p><p>例えば、私の <a href="https://github.com/mcinglis/trie.c" target="_blank" rel="noreferrer">Trie.c</a> プロジェクトからグローバル変数と定数を削除した結果、<code>Alphabet</code> 構造体が生まれました。また、同じTrieに対してアルファベットを瞬時に交換するような、とてもクールな動的能力も生まれました。</p><p>関数内の静的変数は、その関数にスコープされたグローバル変数に過ぎず、上記の引数はそれらにも等しく適用されます。グローバル変数と同様に、静的変数もモジュール化された純粋な関数を提供することから逃れるための簡単な方法としてよく使われます。静的変数は、パフォーマンスという名目で擁護されることがよくあります (ベンチマークが先です!)。グローバル変数が不要なのと同じように、スタティック変数も不要です。永続的な状態が必要なら、関数にその状態を引数として受け取らせればいい。永続的なものを返す必要があるなら、そのためのメモリを確保する。</p><h4 id="公開するものを最小限にし、トップレベルの名前を-static-と宣言して、それが可能な場所に置く。" tabindex="-1">公開するものを最小限にし、トップレベルの名前を <code>static</code> と宣言して、それが可能な場所に置く。 <a class="header-anchor" href="#公開するものを最小限にし、トップレベルの名前を-static-と宣言して、それが可能な場所に置く。" aria-label="Permalink to &quot;公開するものを最小限にし、トップレベルの名前を \`static\` と宣言して、それが可能な場所に置く。&quot;">​</a></h4><p>ヘッダーファイルは、ユーザがライブラリを使用するために必要なものだけを含めるようにします。内部関数や構造体、マクロはここで提供するべきではありません。複数のソースファイルの間で必要な場合は、内部ヘッダーファイルを用意します。</p><p>関数やグローバル変数がヘッダでエクスポートされない場合、ソースファイル内で <code>static</code> と宣言し、内部リンクを与える。これにより、オブジェクトファイル間の名前の衝突がなくなり、いくつかの最適化が可能になり、リンク速度が向上します。</p><h4 id="不変性が命を救う-できる限り-const-を使おう" tabindex="-1">不変性が命を救う: できる限り <code>const</code> を使おう <a class="header-anchor" href="#不変性が命を救う-できる限り-const-を使おう" aria-label="Permalink to &quot;不変性が命を救う: できる限り \`const\` を使おう&quot;">​</a></h4><p>const\` はコンパイル時の正しさを向上させます。これは、読み取り専用のポインタを文書化するためだけではありません。すべての読み取り専用変数とポインタのために使用されるべきです。</p><p><code>const</code> は、読者が機能の一部を理解する上で、 <em>非常に</em> 役立ちます。初期化を見て、その値がスコープ全体で変化しないことを確認できれば、スコープの残りの部分についてより簡単に推論することができます。何が変更され、何が変更されないかを理解するために、読者はスコープ全体を理解することを余儀なくされます。もしあなたが一貫して <code>const</code> を使っていれば、読者はあなたを信頼し始め、 <code>const</code> で修飾されていない変数は、スコープのどこかの時点で変更されるシグナルであると仮定できるようになります。</p><p>あらゆるところで <code>const</code> を使用することは、開発者として、プログラムの制御フローで何が起こっているのか、どこで変異が広がっているのかを推論するのにも役立ちます。特にポインターやポインティーに関しては、<code>const</code>を使うと、コンパイラーがどれだけ助けてくれるかは驚くべきことです。コンパイラは常にあなたの味方でありたいものです。</p><p>コンパイラは関数呼び出しの際にポインティが <code>const</code>ness を失うと警告を出しますが、ポインティが <code>const</code>ness を得ても文句は言いません。したがって、ポインタの引数が読み取り専用である場合に <code>const</code> として指定しなければ、ユーザが自分のコードで <code>const</code> を使用するのを阻止することになります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い点：sumはその配列をconstとして定義する必要がある。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// なぜなら、そうしないとコンパイル時の警告になるからです。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( xs, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; 警告: 引数 2 の &#39;sum&#39; を渡すと、ポインタのターゲット型から &#39;const&#39; 修飾子が削除されます。</span></span></code></pre></div><p>したがって、少なくとも関数のシグネチャについては、 <code>const</code> を使うことはあまり選択肢ではありません。多くの人が <code>const</code> を使うことは有益だと考えているので、好むと好まざるとにかかわらず、誰もが <code>const</code> を使うことを必須と考えるはずです。もし <code>const</code> を使わないのであれば、ユーザは関数へのすべての呼び出しをキャストするか (ヤバイ)、 <code>const</code> の警告を無視するか (面倒くさい)、 <code>const</code> 修飾子を取り除くか (コンパイル時の正しさを失う) のいずれかを迫られることになるのです。</p><p>もし、 <code>const</code> を無視するようなライブラリを使わざるを得ない場合は、代わりにキャストしてくれるマクロを書けばいいのです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`sum\` は指定された配列を変更しない。 \`const\` ポインタに対してはキャストする。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) xs, n )</span></span></code></pre></div><p>関数プロトタイプのポインティには <code>const</code> 修飾子のみを与える - 引数名自体への <code>const</code> は単なる実装の詳細でしかない。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Unnecessary</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><p>残念ながら、C 言語は const でない Pointee-pointees から const の Pointee-pointees への変換を扱うことができません。したがって、点状体を <code>const</code> にしないことをお勧めします。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> yss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xss;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 警告: 互換性のないポインタ型からの初期化</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xss;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;no warning&gt;</span></span></code></pre></div><p>もし、内部構造体のポインティーを<code>const</code>にできるのであれば、そうしてください。ポインティが一定でないと、ミュータビリティが不必要に広がってしまい、残りの <code>const</code> 修飾子から情報を得ることが難しくなります。内部構造体を完全に制御することができるので、将来的に <code>const</code> を削除する必要がある場合は、削除することができます。</p><p>通常、外部構造体のポインティは <code>const</code> するべきではありません。パブリックインターフェイスの一部である場合は、柔軟性が重要です。よく考えてみてください。私がよくやる例外は、 <code>error</code> フィールドのような、文字列リテラルに代入するのが最適なフィールドの場合です。この場合、 <code>char const *</code> 型を使用することで、あなたやあなたのユーザーが、セグメンテーションフォールトを引き起こすような文字列リテラルを変更することを防ぐことができます。</p><p>構造体フィールドの <em>pointees</em> を <code>const</code> するのは合理的ですが、構造体フィールドそのものを <code>const</code> するのは決して有益ではありません。例えば、その構造体の値を <code>malloc</code> (<a href="http://stackoverflow.com/questions/9691404/how-to-initialize-const-in-a-struct-in-c-with-malloc" target="_blank" rel="noreferrer">http://stackoverflow.com/questions/9691404/how-to-initialize-const-in-a-struct-in-c-with-malloc</a>) するのが面倒になります。もし、フィールドが元の値以上に変化しないようにすることが本当に意味があるなら、必要な品質を強制する <a href="#document-your-struct-invariants-and-provide-invariant-checkers">invariants</a> を定義すればいいのです。また、構造体の個々の変数を <code>const</code> として定義することで、同じ効果を得ることができます。</p><p>リターン型のポインタを <code>const</code> にするのは、必要な場合だけ、そして慎重に検討した後だけにしてください。コンパイラが戻り値の型に <code>const</code> を追加するようにほのめかしているとき、それは <code>const</code> を追加するのではなく、どこかで <em>remove</em> するべきだという意味であることが多いことに気がつきました。これは柔軟性を損なう可能性があるので、注意が必要です。</p><p>最後に、型キャストやポインタを使用して <code>const</code> 修飾子を回避することは、少なくとも自分がコントロールする場合には、絶対にしないでください。もし変数が定数でないなら、定数にしないでください。</p><h4 id="常に-const-を右に置き、型を右から左に読んでいく" tabindex="-1">常に <code>const</code> を右に置き、型を右から左に読んでいく <a class="header-anchor" href="#常に-const-を右に置き、型を右から左に読んでいく" aria-label="Permalink to &quot;常に \`const\` を右に置き、型を右から左に読んでいく&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> word;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 悪い点：コンスト的でないこと</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> word;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 悪い点：文字が非常に読みづらくなる</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> word;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 悪い点：配置が変</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良好：右から左へ、ワードは定数charへの定数ポインタ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> word;</span></span></code></pre></div><p>このルールのため、<code>*</code>型修飾子は常に空白で埋める必要があります。</p><h4 id="関数のプロトタイプに引数名を書かない-型を繰り返すだけ-。" tabindex="-1">関数のプロトタイプに引数名を書かない（型を繰り返すだけ）。 <a class="header-anchor" href="#関数のプロトタイプに引数名を書かない-型を繰り返すだけ-。" aria-label="Permalink to &quot;関数のプロトタイプに引数名を書かない（型を繰り返すだけ）。&quot;">​</a></h4><p>しかし、ポインタの引数が配列へのポインタ（複数形）か値へのポインタ（単数形）かを伝えるために、常にその名前を宣言してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">trie1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Trie </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">trie2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie, Trie );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                     // 良い</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い点 - これらは修正用のポインタなのか、ヌルなのか、それともアレイなのか？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> trie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><h4 id="特別な理由がない限り、-float-ではなく-double-を使用する。" tabindex="-1">特別な理由がない限り、 <code>float</code> ではなく <code>double</code> を使用する。 <a class="header-anchor" href="#特別な理由がない限り、-float-ではなく-double-を使用する。" aria-label="Permalink to &quot;特別な理由がない限り、 \`float\` ではなく \`double\` を使用する。&quot;">​</a></h4><p>Ben Klemens著「<em>21st Century C</em>」より。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%f\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">333334126.98</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 333334112.000000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%f\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">333334125.31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 333334112.000000</span></span></code></pre></div><p>最近のアプリケーションの大部分では、スペースは問題になりませんが、浮動小数点数のエラーは依然として脅威となります。フロートよりもダブルの方が、数値のドリフトが問題になりにくいのです。よほど特殊な理由がない限り、 <code>float</code>s を使用する代わりに <code>double</code>s を使用してください。なぜなら、ベンチマークを行わないと、それが実際に目に見える違いを生むかどうかわからないからです。開発を終えてから、ベンチマークを実施してチョークポイントを特定し、その部分で <code>float</code>s を使って、それが実際に役に立つかどうかを見てください。その前に、パフォーマンスの向上よりも他のことを優先してください。早まって最適化しないこと。</p><h4 id="変数の宣言はできるだけ遅くする" tabindex="-1">変数の宣言はできるだけ遅くする <a class="header-anchor" href="#変数の宣言はできるだけ遅くする" aria-label="Permalink to &quot;変数の宣言はできるだけ遅くする&quot;">​</a></h4><p>変数を使用する場所で宣言することで、読者は自分が扱っている型について思い出すことができます。また、変数のスコープを最小にするために、関数を抽出する場所を示唆します。さらに、それぞれの変数がどこに関係しているのかを読者に知らせることができます。必要なときに変数を宣言すると、ほとんどの場合、単なる宣言(<code>int x;</code>)ではなく初期化(<code>int x = 1;</code>)を行うことになります。変数を初期化するということは、たいていの場合、その変数を <code>const</code> することもできるということです。</p><p>私にとって、すべての宣言（＝非初期化）はシビれるものです。</p><h4 id="変数の定義は1行にまとめる。" tabindex="-1">変数の定義は1行にまとめる。 <a class="header-anchor" href="#変数の定義は1行にまとめる。" aria-label="Permalink to &quot;変数の定義は1行にまとめる。&quot;">​</a></h4><p>これは、アトム行の編集が容易なため、将来的にタイプを変更することが容易になります。もし、すべての型を一緒に変更する必要がある場合は、エディタのブロック編集モードを使用する必要があります。</p><p>構造体の定義は、アクティブなコードよりも理解しやすいので、意味的につながりのある構造体メンバを束ねるのはいいと思いますけど。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ファイン</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Color {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r, g, b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} Color;</span></span></code></pre></div><h4 id="短い変数名を恐れない" tabindex="-1">短い変数名を恐れない <a class="header-anchor" href="#短い変数名を恐れない" aria-label="Permalink to &quot;短い変数名を恐れない&quot;">​</a></h4><p>もしスコープが画面に収まり、その変数が多くの場所で使われていて、それを表すのに明らかな文字が1つか2つあれば、それを試してみて、可読性を高めることができるかどうか見てみてください。きっと読みやすくなりますよ</p><h4 id="関数間で変数名を統一する" tabindex="-1">関数間で変数名を統一する <a class="header-anchor" href="#関数間で変数名を統一する" aria-label="Permalink to &quot;関数間で変数名を統一する&quot;">​</a></h4><p>一貫性を持たせることで、読者は何が起こっているのか理解しやすくなります。関数内で同じ値に対して異なる名前を使うのは怪しく、読者に重要でないことを推論させることになります。</p><h4 id="ブール値を使用する場合は、stdbool-h-の-bool-を使用します。" tabindex="-1">ブール値を使用する場合は、<code>stdbool.h</code> の <code>bool</code> を使用します。 <a class="header-anchor" href="#ブール値を使用する場合は、stdbool-h-の-bool-を使用します。" aria-label="Permalink to &quot;ブール値を使用する場合は、\`stdbool.h\` の \`bool\` を使用します。&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> print_steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 悪いこと - これは歩数を数えているのでしょうか？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> print_steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 良い - 意図が明確である</span></span></code></pre></div><h4 id="真偽に頼らず、明示的に価値を比較する。" tabindex="-1">真偽に頼らず、明示的に価値を比較する。 <a class="header-anchor" href="#真偽に頼らず、明示的に価値を比較する。" aria-label="Permalink to &quot;真偽に頼らず、明示的に価値を比較する。&quot;">​</a></h4><p>明示的な比較は、C言語では必ずしも明らかでないため、読者に何を扱っているのかを教えてくれます。それはC言語では必ずしも明らかではないからです。C言語で真偽を問われる変数を見たとき、私が最初にすることは、その型を見つけるために宣言を探し出すことです。プログラマーが比較で教えてくれればよかったのにと本当に思います。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い点 - これらの表現は実際に何をテストしているのか（もしそうなら）？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( on_fire );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">character;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">something</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( xs ) );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">at_work );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い - 情報を提供し、曖昧さをなくす。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( on_fire </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> character </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">something</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( xs ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( at_work </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><p>私は、 <code>is_edible</code> や <code>has_client</code> のような述語として名付けられたブーリアン関数については、このルールをスキップすることがよくあります。しかし、私は通常、このような状況では <code>== true</code> や <code>== false</code> のような視覚的な混乱は、読者の助けになるというよりも、むしろ面倒なものだと考えています。あなたの判断でどうぞ。</p><h4 id="式の中で状態を変化させない-例-代入や-など" tabindex="-1">式の中で状態を変化させない（例：代入や<code>++</code>など） <a class="header-anchor" href="#式の中で状態を変化させない-例-代入や-など" aria-label="Permalink to &quot;式の中で状態を変化させない（例：代入や\`++\`など）&quot;">​</a></h4><p>読みやすい（命令形）プログラムは、右から左ではなく、上から下へ流れます。残念ながら、C言語プログラミングでは、このようなことが多すぎるのです。この習慣と慣習は<em>The C Programming Language</em>によって始められ、それ以来、多くの文化に根付いているのだと思います。これは本当に悪い習慣で、プログラムが何をしているのかを追うのがとても難しくなります。式の中で状態を変更してはいけません。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trie_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">word );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 悪い</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trie_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, word </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 良い</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// よかった、もし \`word\` を修正する必要があるのなら</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">word </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trie_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, word );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 技術的には式中の代入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">atoms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( atoms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 良い</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        atoms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// いいんです、これ以上の方法はない、繰り返さないで</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calc_width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( shape ),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valid_width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( w ) ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shape </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( shape, w );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>変数の値が意味的にリンクしていない限り、多重代入は使わないでください。もし、偶然にも同じ値を持つ2つの変数が近くにあったとしても、行を節約するためだけにそれらを多重代入に放り込まないようにしましょう。</p><p>カンマ演算子は、上記のように慎重に使用してください。できれば、カンマは使わないでください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, limit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_limit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( m ); i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> limit; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// より良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> limit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_limit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> limit; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="式中の純粋でない関数呼び出しや自明でない関数の呼び出しを避ける" tabindex="-1">式中の純粋でない関数呼び出しや自明でない関数の呼び出しを避ける <a class="header-anchor" href="#式中の純粋でない関数呼び出しや自明でない関数の呼び出しを避ける" aria-label="Permalink to &quot;式中の純粋でない関数呼び出しや自明でない関数の呼び出しを避ける&quot;">​</a></h4><p>たとえ変数が <code>int result</code> のような単純なものであっても、関数呼び出しを変数に割り当てて、それが何であるかを記述します。こうすることで、条件文の中に隠された純粋でない関数による状態の変化で読者を驚かせることを避けることができます。私にとっては、<code>if ( ... )</code> の中の式が外界の状況を変化させると考えるのは実に不自然なことなのです。その状態変化の結果を変数に代入して、その値をチェックする方がよっぽどわかりやすい。</p><p>たとえそれが当たり前のことで、行数を減らすことができると思っていても、失敗する可能性があることには価値がありません。このルールを守って、何も考えないでください。</p><p>関数名が <code>is_adult</code> や <code>in_tree</code> のような述語で、条件文脈で自然に読めるのであれば、結果の代入を省略してもいいと思うんだ。必要であれば、このような関数をブール式で結合することもできますが、ご自分の判断でお願いします。複雑なブーリアン式は、関数に抽出することが多いはずです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( fd, backlog );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    perror</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;listen&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_tasty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( banana ) ) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( banana );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="単一ステートメントブロックであっても、必ず括弧を使用します。" tabindex="-1">単一ステートメントブロックであっても、必ず括弧を使用します。 <a class="header-anchor" href="#単一ステートメントブロックであっても、必ず括弧を使用します。" aria-label="Permalink to &quot;単一ステートメントブロックであっても、必ず括弧を使用します。&quot;">​</a></h4><p>安全で、変更しやすく、一貫性があるので読みやすいという理由から、常に括弧を使用します。同じ理由で、一行文を条件と同じ行に書かないようにしましょう。</p><p>以下は、<em>The C Programming Language</em>の実際のコードです。こんなことはしないでください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">argc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">argv)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;-&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *++</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (argc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Usage: find -x -n pattern</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line, MAXLINE) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h4 id="整数の変換規則が複雑なため-符号なし型を避ける" tabindex="-1">整数の変換規則が複雑なため，符号なし型を避ける <a class="header-anchor" href="#整数の変換規則が複雑なため-符号なし型を避ける" aria-label="Permalink to &quot;整数の変換規則が複雑なため，符号なし型を避ける&quot;">​</a></h4><p><a href="https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules" target="_blank" rel="noreferrer">CERTは整数変換規則を説明しようとする</a>と述べている。</p><blockquote><p>整数変換規則を誤解していると、エラーが発生し、それが脆弱性の悪用につながる可能性があります。深刻度：中、可能性：あり。</p></blockquote><p>ANSI標準を探求する素晴らしい本である<em>Expert C Programming</em>も、その最初の章でこのことを説明しています。ここから得られるのは、「負の値であってはならないからと言って、 <code>unsigned</code> 変数を宣言してはいけない」ということです。もし、より大きな最大値が欲しいなら、 <code>long</code> か <code>long long</code> (次のサイズ) を使ってください。</p><p>もし関数が負の数で失敗するなら、それはおそらく大きな数でも失敗するでしょう。もし関数が負の数で失敗するなら、正の数であると断言すればよいのです。多くの動的言語では、どちらの符号にも対応できる単一の整数型が使用されていることを思い出してください。</p><p>符号なし値は型安全性を提供しません。<code>-Wall</code> と <code>-Wextra</code> を使っても、GCC は <code>unsigned int x = -1;</code> に目をつぶってくれません。</p><p>また、<em>Expert C Programming</em> では、符号なし値に評価されるすべてのマクロをキャストする理由についての例を示しています。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NELEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) ( ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ) )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NELEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( xs ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>NELEM</code> は (<code>sizeof</code> によって) <code>unsigned int</code> と評価されるため、<code>if</code> ブランチは実行されません。そのため、<code>d</code> は <code>unsigned int</code> に昇格します。2 の補数](<a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Two&#39;s_complement</a>) の <code>-1</code> は可能な限り大きな符号なし値 (ビット単位) を表すので、この式は false となり、プログラムは <code>0</code> を返します。この場合の解決策は、 <code>NELEM</code> の結果をキャストすることです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NELEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )( ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] ) )</span></span></code></pre></div><p><a href="http://stackoverflow.com/questions/4009885/arithmetic-bit-shift-on-a-signed-integer" target="_blank" rel="noreferrer">よく定義されたビット演算</a>とモジュール算術のオーバーフローを提供するために、符号なし値を使用する必要があります。しかし、これらの値を保持し、符号付き値と相互作用させないようにします。</p><h4 id="_1-と-1-を-と-よりも使用する。" tabindex="-1"><code>+= 1</code> と <code>-= 1</code> を <code>++</code> と <code>--</code> よりも使用する。 <a class="header-anchor" href="#_1-と-1-を-と-よりも使用する。" aria-label="Permalink to &quot;\`+= 1\` と \`-= 1\` を \`++\` と \`--\` よりも使用する。&quot;">​</a></h4><p>実は、できればどちらの形式も使わないでください。状態を変更することは常に避けるべきです (無理のない範囲で)。しかし、どうしても必要な場合には、 <code>+=</code> と <code>-=</code> は <code>++</code> や <code>--</code> よりも明白でシンプル、かつ暗号化されておらず、他の文脈や他の値でも役に立ちます。また、 <code>+=</code> と <code>-=</code> の評価にはトリックがなく、別の評価を提供するための奇妙な双子の演算子もありません。Pythonには <code>++</code> と <code>--</code> 演算子がありませんし、Douglas CrockfordはそれらをJavaScriptのGood Partsから除外しました。このルールに従うことで、式の中で状態を変化させないようにすることもできます。</p><h4 id="演算子の優先順位が明らかでない式には、括弧を使用する" tabindex="-1"><a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence" target="_blank" rel="noreferrer">演算子の優先順位</a>が明らかでない式には、括弧を使用する <a class="header-anchor" href="#演算子の優先順位が明らかでない式には、括弧を使用する" aria-label="Permalink to &quot;[演算子の優先順位](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence)が明らかでない式には、括弧を使用する&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 良い</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sockaddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sin_addr;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( sockaddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sin_addr );</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 良い</span></span></code></pre></div><p>よく見かける操作の組み合わせについては、例外を設けることができますし、そうすべきです。例えば、等号演算子とブール演算子を組み合わせる際に演算子を省略することは問題ありません。なぜなら、読者はおそらくそれに慣れていて、その結果に自信を持っているからです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ファイン</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hungry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( legs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fridge.empty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><h4 id="switch-を使わず、複雑な条件文も避ける。" tabindex="-1"><code>switch</code> を使わず、複雑な条件文も避ける。 <a class="header-anchor" href="#switch-を使わず、複雑な条件文も避ける。" aria-label="Permalink to &quot;\`switch\` を使わず、複雑な条件文も避ける。&quot;">​</a></h4><p>スイッチのフォールスルーメカニズムはエラーが起こりやすく、ケースをフォールスルーさせることはほとんどないので、ほとんどのスイッチのコードは <code>if</code> と同等のものより長くなります。さらに悪いことに、<code>break</code>がなくてもコンパイルすることができます。私が <code>switch</code> を使っていたときは、いつもこれでつまづいていました。また、 <code>case</code> の値は積分定数式でなければならないので、他の変数にマッチすることはできません。このため、ロジックを関数に展開することができません。さらに、<code>switch</code> の中のどの文もラベル付けしてジャンプすることができるので、例えば <code>defau1t</code> とタイプミスしたときに非常にわかりにくいバグを助長します。</p><p>もし、異なる定数値を動作に対応させる必要がある場合、次のようになります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    do_something_for_a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x, y, z );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    do_something_for_b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x, y, z ):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x, y, z );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// これらの関数は明示的な関数ではないかもしれません（つまり、これらの変数のいくつかを使用する一連のステートメントであるかもしれません）。</span></span></code></pre></div><p>より明示的でテスト可能かつ再利用可能なアプローチとしては、3項式を用いて正しい型の関数ポインタを返す関数を定義することです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">action_fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_x_action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> do_something_for_a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> do_something_for_b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">action_fn action </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_x_action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x );</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x, y, z );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// または単に</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_x_action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( x )( x, y, z );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`action\` はひどい名前で、例として使われているに過ぎません。もっと情報量の多い名前を考えてみてください。</span></span></code></pre></div><p>このように、相関のない定数値の2つのセットの間でマッピングする必要がある場合にも、同様のことをする必要があります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> X;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Y;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Z;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ERR;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> X</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Y</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Z</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ERR;</span></span></code></pre></div><p>ブーリアン式で済むところを <code>switch</code> を使わないでください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// あるいは、名前が長い場合は、通常、この方が読みやすい。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON_TYPE_null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON_TYPE_boolean</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON_TYPE_number;</span></span></code></pre></div><p>このように、<code>switch</code>のフォールスルー動作が必要な場合。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Aのもの、Bに落ちる</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // B stuff</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // デフォルトのもの</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これと同等の <code>if</code> はもっと読みやすく、何がどうして起こるのかが一目瞭然です。Bに関すること」は実際には <code>x == A</code> の場合にも適用され、これは <code>if</code> を使用する際に明示的に宣言されます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // A stuff</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // B stuff</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // default stuff</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>switch</code> を使う必要があるのは、パフォーマンスチューニングのときだけです (ベンチマークでホットスポットを特定したらね!)。そうでなければ、より安全で、より短く、よりテストしやすく、再利用可能な代替案が常にあります。</p><h4 id="関数と構造体の定義を2行で区切る" tabindex="-1">関数と構造体の定義を2行で区切る <a class="header-anchor" href="#関数と構造体の定義を2行で区切る" aria-label="Permalink to &quot;関数と構造体の定義を2行で区切る&quot;">​</a></h4><p>関数内の空行を最大1行に制限すれば、このルールによってグローバルな要素を視覚的に明確に分離することができます。これは、PythonのPEP8スタイルガイドから学んだ習慣です。</p><h4 id="変数のスコープを最小にする" tabindex="-1">変数のスコープを最小にする <a class="header-anchor" href="#変数のスコープを最小にする" aria-label="Permalink to &quot;変数のスコープを最小にする&quot;">​</a></h4><p>もし、いくつかの変数が連続した行の中でしか使われず、その行の後に一つの値しか使われないのであれば、それらの最初の行は関数に抽出するのに最適な候補となります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good: addrはhandle_requestの最初の部分でのみ使用された。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> listenfd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr addr;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( listenfd, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addr, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">socklen_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> addr } );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handle_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> listenfd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reqfd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( listenfd );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... addrに関係なく、reqfdに関係するもの。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>もし <code>accept_request</code> のボディが <code>handle_request</code> に残っていた場合、 <code>addr</code> 変数は <code>reqfd</code> を取得するためだけに使用されるにもかかわらず、 <code>handle_request</code> 関数の残りの部分でスコープ内に存在することになります。このようなことは、関数を理解する上での負担になるので、可能な限り修正されるべきです。</p><p>変数の露出を制限するもう一つの戦術は、複雑な式を次のようにブロックに分割することです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// というより、むしろ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> trie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( trie, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                &amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child, string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// childは条件分岐の後半にしか使われないので、次のように露出を制限することができます。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> trie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( trie, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            &amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Trie_has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child, string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="単純な定数式は変数よりも読みやすい場合がある" tabindex="-1">単純な定数式は変数よりも読みやすい場合がある <a class="header-anchor" href="#単純な定数式は変数よりも読みやすい場合がある" aria-label="Permalink to &quot;単純な定数式は変数よりも読みやすい場合がある&quot;">​</a></h4><p>定数式にしか代入されない変数を、その定数式に置き換えると、コードの可読性が向上することがよくあります。</p><p>上の <code>trie_has</code> の例を考えてみましょう。<code>string[ 0 ]</code> 式が2回繰り返されています。もし、<code>char</code>変数を定義するために余分な行を挿入したら、読むのも追うのも大変になるでしょう。これは、読者が念頭に置かなければならないもう一つのことなのです。他の言語の多くのプログラマーは、配列のアクセスを繰り返すことを考えもしないでしょう。</p><h4 id="余計な変数より複合リテラルを優先する" tabindex="-1">余計な変数より複合リテラルを優先する <a class="header-anchor" href="#余計な変数より複合リテラルを優先する" aria-label="Permalink to &quot;余計な変数より複合リテラルを優先する&quot;">​</a></h4><p>これは、変数の範囲を最小化するのと同じ理由で有益です。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪いことに、\`sa\` が二度と使われないとしたら。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigaction sa </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .sa_handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigchld_handler,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .sa_flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SA_RESTART</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( SIGCHLD, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( SIGCHLD, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigaction ){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .sa_handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigchld_handler,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .sa_flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SA_RESTART</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setsockopt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( fd, SOL_SOCKET, SO_REUSEADDR, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setsockopt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( fd, SOL_SOCKET, SO_REUSEADDR, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><h4 id="for-のような制御構造をラップするマクロを使用したり、提供したりしてはいけません。" tabindex="-1"><code>for</code> のような制御構造をラップするマクロを使用したり、提供したりしてはいけません。 <a class="header-anchor" href="#for-のような制御構造をラップするマクロを使用したり、提供したりしてはいけません。" aria-label="Permalink to &quot;\`for\` のような制御構造をラップするマクロを使用したり、提供したりしてはいけません。&quot;">​</a></h4><p>データ構造の要素をループするマクロは、余計な構文があり、読者は定義を調べないと制御の流れが分からないので、非常に紛らわしいです。</p><p>プログラムを理解するためには、読者がその制御フローを理解できることが重要です。</p><p>コントロールマクロはオプションとしてでも提供しないでください。それらは普遍的に有害なので、有効にしないでください。ユーザーが本当に望むなら、自分で定義すればいいのです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TRIE_EACH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">TRIE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">INDEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INDEX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; INDEX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( TRIE ).alphabet.size; INDEX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ここで実際に何が起こるのか、まったく予想がつきません。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TRIE_EACH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( trie, i ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Trie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> trie.children[ i ];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="マクロが関数呼び出しと異なる動作をする場合のみ、大文字にします。" tabindex="-1">マクロが関数呼び出しと異なる動作をする場合のみ、大文字にします。 <a class="header-anchor" href="#マクロが関数呼び出しと異なる動作をする場合のみ、大文字にします。" aria-label="Permalink to &quot;マクロが関数呼び出しと異なる動作をする場合のみ、大文字にします。&quot;">​</a></h4><p>「異なる動作」というのは、ユーザーが予期しないときに物事が壊れるかどうかということです。マクロの見た目が違うだけなら（例：名前付き引数のテクニック）、大文字の名前を正当化する理由にはならないと思います。マクロに大文字の名前を付けるべきは、次のような場合です。</p><ul><li>はその本体で引数を繰り返しますが、これは純粋でない式では壊れてしまうからです。多くのコンパイラはこれを防ぐために<a href="http://stackoverflow.com/questions/6440021/compiler-support-of-gnu-statement-expression" target="_blank" rel="noreferrer">statement expressions</a>を提供していますが、これは非標準的です。ステートメント式を使用する場合、マクロ名を大文字にする必要はありません。</li><li>がブロックや制御構造でラップされている場合、式として使用できないからです。</li><li>は、例えば <code>return</code> や <code>goto</code> などで、周囲のコンテキストを変更します。</li><li>は名前付き引数として配列リテラルを取ります。(<a href="http://stackoverflow.com/questions/5503362/passing-array-literal-as-macro-argument" target="_blank" rel="noreferrer">なぜ</a>)</li></ul><h4 id="マクロが関数に固有のものである場合は、本文中で-define-してください。" tabindex="-1">マクロが関数に固有のものである場合は、本文中で <code>#define</code> してください。 <a class="header-anchor" href="#マクロが関数に固有のものである場合は、本文中で-define-してください。" aria-label="Permalink to &quot;マクロが関数に固有のものである場合は、本文中で \`#define\` してください。&quot;">​</a></h4><p>変数のスコープを常に最小にするのと同じ理由で、マクロのスコープを制限することが理にかなっている場合は、そうすべきです。</p><h4 id="文字列を配列として初期化し、バイトサイズに-sizeof-を使用する。" tabindex="-1">文字列を配列として初期化し、バイトサイズに <code>sizeof</code> を使用する。 <a class="header-anchor" href="#文字列を配列として初期化し、バイトサイズに-sizeof-を使用する。" aria-label="Permalink to &quot;文字列を配列として初期化し、バイトサイズに \`sizeof\` を使用する。&quot;">​</a></h4><p>文字列リテラルは常に配列として初期化することで、<code>sizeof str</code>だけでバイトサイズを取得できるからです。ポインタとして初期化した場合は、<code>strlen( str ) + 1</code> でバイトサイズを取得しなければなりません。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;always use arrays for strings!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( output, message, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><p>また、ポインタの初期化は配列の初期化よりも安全ではありません。 *ただし、文字列リテラルを <code>char const *</code> 型で初期化するように <code>-Write-strings</code> を指定してコンパイルする場合は例外です。残念ながら、 <code>-Wwrite-strings</code> は <code>-Wall</code> や <code>-Wextra</code> に含まれていないため、明示的に有効化する必要があります。 Write-strings<code>がなければ、文字列リテラルを</code>char *\` に代入することができます。しかし、そのポインタの要素を再割り当てすると、プログラムがセグメンテーションフォールトを起こします。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Write-stringsを指定しない場合、警告を出さずにコンパイルできますが、2行目でsegmentation faultが発生します。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// このプログラムは、正常にコンパイル・実行されます。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>文字列リテラルをポインタとして初期化することの利点は、これらのポインタが読み取り専用のメモリを指すようになるため、いくつかの最適化が可能になる可能性があることです。文字列リテラルを配列として初期化すると、基本的に変更可能な文字列が作成されます。これは、 <code>const</code> による変更に対して「人為的に」保護されているだけですが、これはキャストで破ることができます。</p><p>繰り返しになりますが、早まった最適化をしないことをお勧めします。開発を終えてベンチマークを行うまでは、パフォーマンスを最も優先させるべきです。文字列リテラルの定義に関するテストは見たことがありませんが、文字列リテラルをポインタとして定義することによって、顕著な速度向上が見られるのは非常に驚きです。</p><p>すべてのものを<code>const</code>するルールで述べたように、<code>const</code>を決して捨ててはいけません。代わりに <code>const</code> を削除してください。人工的な」保護については心配しないでください。私は、定数値は、違反するとセグメンテーション違反になるような暗黙のルールよりも、コンパイル時に警告が出るような明示的な構文構造で保護されている方がずっといいと考えています。</p><p>最後に、配列の初期化にこだわることで、ポインタの初期化と配列の初期化を、ミュータビリティが必要かどうかによって切り替えるという概念上のオーバーヘッドを、あなたや読者に節約させることができるのです。</p><p>ただ、文字列リテラルは常に配列として初期化し、シンプルに保つようにします。</p><h4 id="可能であれば、型ではなく-sizeof-を変数に使用します。" tabindex="-1">可能であれば、型ではなく <code>sizeof</code> を変数に使用します。 <a class="header-anchor" href="#可能であれば、型ではなく-sizeof-を変数に使用します。" aria-label="Permalink to &quot;可能であれば、型ではなく \`sizeof\` を変数に使用します。&quot;">​</a></h4><p>そうすれば、後で変数の型を変更しても、一度だけ変更すればよいのです。常に正しいサイズを得ることができるのです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a ) );</span></span></code></pre></div><p>複合リテラルではできませんが。一度しか使わない変数を削除するのは、トレードオフとして価値があると思います。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setsockopt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( fd, SOL_SOCKET, SO_REUSEADDR, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) );</span></span></code></pre></div><h4 id="関数の引数定義に配列構文を使用しない" tabindex="-1">関数の引数定義に配列構文を使用しない <a class="header-anchor" href="#関数の引数定義に配列構文を使用しない" aria-label="Permalink to &quot;関数の引数定義に配列構文を使用しない&quot;">​</a></h4><p><a href="http://c-faq.com/aryptr/aryptrequiv.html" target="_blank" rel="noreferrer">配列はほとんどの式でポインタになる</a>し、<a href="http://c-faq.com/aryptr/aryptrparam.html" target="_blank" rel="noreferrer">関数への引数として渡される場合</a>も含まれる。関数は決して配列を引数として受け取ることはできません。<a href="http://c-faq.com/aryptr/aryptr2.html" target="_blank" rel="noreferrer">配列へのポインタのみ</a>です。sizeof\` は配列の引数宣言のようには動作しません：ポインタのサイズを返すのであって、指された配列を返すのではありません。</p><p><a href="http://hamberg.no/erlend/posts/2013-02-18-static-array-indices.html" target="_blank" rel="noreferrer">関数の引数で静的配列インデックスを指定するのはいい</a> が、リテラルに <code>NULL</code> が与えられたときのような非常につまらない状況に対してしか保護されないのです。また、GCCはその違反について警告しませんが<a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50584" target="_blank" rel="noreferrer">まだ</a>、Clangだけは警告します。私は紛らわしいとは思っていません。non-obvious syntax to be worth the small compilation check.</p><p>そう、<code>[]</code>は引数が配列として扱われることを示唆しますが、<code>requests</code>のような複数形の名前も同様なので、その代わりにそうしてください。</p><h4 id="ポインタ演算よりも配列インデックスを常に優先する" tabindex="-1">ポインタ演算よりも配列インデックスを常に優先する <a class="header-anchor" href="#ポインタ演算よりも配列インデックスを常に優先する" aria-label="Permalink to &quot;ポインタ演算よりも配列インデックスを常に優先する&quot;">​</a></h4><p>配列を扱う場合は、配列として扱います。ポインタの演算は混乱しやすく、バグも発生しやすいものです。配列のインデックスにこだわることで、重要な変数だけを一定に保ち、インデックス変数だけを非一定にすることができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( ; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ i ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><h4 id="構造体の不変量を文書化し、不変量チェッカーを提供する。" tabindex="-1">構造体の不変量を文書化し、不変量チェッカーを提供する。 <a class="header-anchor" href="#構造体の不変量を文書化し、不変量チェッカーを提供する。" aria-label="Permalink to &quot;構造体の不変量を文書化し、不変量チェッカーを提供する。&quot;">​</a></h4><blockquote><p>不変量**とは、プログラムの実行中に真であることが当てになる条件である。</p></blockquote><p>構造体（または構造体へのポインタ）を受け取る関数では、その構造体のすべての不変量が、関数の実行前と実行後に真になる必要があります。不変量は、呼び出し側には有効なデータを提供する責任があり、関数側には有効なデータを返す責任があることを意味します。不変量によって、これらの関数はこれらの条件のアサーションを繰り返す必要がなくなり、さらに悪いことには、無効なデータをチェックし、処理することさえしなくなります。</p><p>構造体の定義の最後に「invariants」というコメント欄を設け、思いつく限りの不変量を列挙してください。また、ユーザーが自分で作成した構造体の値に対して、これらのアサーションをチェックできるように <code>is_valid</code> と <code>assert_valid</code> 関数を実装してください。これらの関数は、構造体の値に対して不変量が成立していることを信頼できるようにするために重要です。これがなければ、ユーザーはどうやって知ることができるのでしょうか？</p><p>構造体不変量の<a href="https://github.com/mcinglis/trie.c/blob/master/alphabet.h#L10" target="_blank" rel="noreferrer">一例です</a>。</p><p>私の大学の教員は、ソフトウェアの正しさについて<a href="http://www.itee.uq.edu.au/sse/projects" target="_blank" rel="noreferrer">かなり大きな</a>存在です。確かに、その影響は受けています。</p><h4 id="さもなければプログラムが失敗するような場所では、assert-を使用する。" tabindex="-1">さもなければプログラムが失敗するような場所では、<code>assert</code> を使用する。 <a class="header-anchor" href="#さもなければプログラムが失敗するような場所では、assert-を使用する。" aria-label="Permalink to &quot;さもなければプログラムが失敗するような場所では、\`assert\` を使用する。&quot;">​</a></h4><p>データを削除したり、セキュリティの脆弱性を防いだり、セグメンテーションフォールトを防いだりと、プログラムが愚かなことをする前に、意味のあるクラッシュをするためにアサーションを書きましょう。良いソフトウェアは速く失敗する。</p><p>もし関数にポインタが与えられたら、それをデリファレンスして、それがヌルでないことを保証します。配列のインデックスが与えられたら、それが範囲内であることを確認します。引数間の整合性が必要な場合は、それを保証すること。</p><p>とはいえ、決してアサーションに頼ってはいけません。アサーションの行を削除しても、プログラムは正しく動作するはずです。</p><p>アサーションをエラー報告だと勘違いしないようにしましょう。そうでなければわざわざチェックしないようなことをアサーションしましょう。もし (コードではなく) ユーザーの入力がアサーションを無効にしてしまったら、 それはバグです。事前にフィルタリングを行い、ユーザーにとって読みやすい形でエラーを報告すべきです。</p><h4 id="assertを繰り返し、一緒に-してはいけない" tabindex="-1"><code>assert</code>を繰り返し、一緒に<code>&amp;&amp;</code>してはいけない <a class="header-anchor" href="#assertを繰り返し、一緒に-してはいけない" aria-label="Permalink to &quot;\`assert\`を繰り返し、一緒に\`&amp;&amp;\`してはいけない&quot;">​</a></h4><p><code>assert</code> を繰り返し呼び出すと、アサーションエラーのレポートが改善されます。アサーションを <code>&amp;&amp;</code> で連結すると、どの条件が失敗したのかがわからなくなります。</p><h4 id="可変長配列の使用禁止" tabindex="-1">可変長配列の使用禁止 <a class="header-anchor" href="#可変長配列の使用禁止" aria-label="Permalink to &quot;可変長配列の使用禁止&quot;">​</a></h4><p>可変長配列は、動的な長さの配列を自動で保存する方法として C99 で導入されたもので、 <code>malloc</code> は必要ありません。いくつかの理由により、C11 ではオプションとなりました。したがって、C11 で可変長配列を使用したい場合は、いずれにせよ <code>malloc</code> バージョンを書かなければなりません。その代わり、可変長配列を使わないようにすればいいのです。</p><p>C99でも可変長配列を使うのはやめたほうがいいと思います。まず、スタックスマッシュを防ぐために、サイズを制御する<a href="https://www.securecoding.cert.org/confluence/display/seccode/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range" target="_blank" rel="noreferrer">値をチェックする必要があります</a>。次に、初期化できないことです。最後に、これらを避けることで、後で新しい標準にアップグレードすることが容易になります。</p><h4 id="型安全性を損なうので-void-を避ける。" tabindex="-1">型安全性を損なうので <code>void *</code> を避ける。 <a class="header-anchor" href="#型安全性を損なうので-void-を避ける。" aria-label="Permalink to &quot;型安全性を損なうので \`void *\` を避ける。&quot;">​</a></h4><p><code>void *</code> はポリモーフィズムのために有用ですが、ポリモーフィズムが型安全性と同じくらい重要であることはほとんどありません。ボイドポインタは多くの場面で必要不可欠なものですが、まずは他の安全な代替手段を検討すべきです。</p><h4 id="もし-void-があれば、できるだけ早く型付き変数に代入してください。" tabindex="-1">もし <code>void *</code> があれば、できるだけ早く型付き変数に代入してください。 <a class="header-anchor" href="#もし-void-があれば、できるだけ早く型付き変数に代入してください。" aria-label="Permalink to &quot;もし \`void *\` があれば、できるだけ早く型付き変数に代入してください。&quot;">​</a></h4><p>初期化されていない変数を扱うのが危険なように、void ポインタを扱うのも危険です：コンパイラを味方につけたいところです。ですから、できるだけ早く <code>void *</code> を捨ててください。</p><h4 id="相互排他的なフィールドではなく、c11の匿名構造体とユニオンを使用する" tabindex="-1">相互排他的なフィールドではなく、C11の匿名構造体とユニオンを使用する <a class="header-anchor" href="#相互排他的なフィールドではなく、c11の匿名構造体とユニオンを使用する" aria-label="Permalink to &quot;相互排他的なフィールドではなく、C11の匿名構造体とユニオンを使用する&quot;">​</a></h4><p>あるフィールドが特定の値であるときに、あるフィールドだけを設定したい場合は、C11の匿名構造体やユニオンを使用します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTOMATON_TYPE {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    AUTOMATON_TYPE_char,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    AUTOMATON_TYPE_split,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    AUTOMATON_TYPE_match</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NUM_AUTOMATON_TYPES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTOMATON_TYPE type;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // type = char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // type = split</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} Automaton;</span></span></code></pre></div><p>というようなものよりも、ずっと明快でわかりやすい。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTOMATON_TYPE type;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Automaton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} Automaton;</span></span></code></pre></div><h4 id="必要なとき以外はタイプキャストしない-おそらくしないでしょう" tabindex="-1">必要なとき以外はタイプキャストしない（おそらくしないでしょう） <a class="header-anchor" href="#必要なとき以外はタイプキャストしない-おそらくしないでしょう" aria-label="Permalink to &quot;必要なとき以外はタイプキャストしない（おそらくしないでしょう）&quot;">​</a></h4><p>ある型の値を別の型の変数に代入することが有効なら、キャストする必要はない。というように、必要なときだけ型キャストを使えばいいのです。</p><ul><li>int\` 式の真の除算（整数の除算ではない）の実行</li><li>配列のインデックスを整数にすること。</li><li>構造体や配列に複合リテラルを使用する。</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// これで問題なくコンパイルできます。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Apple </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apples </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">apples</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><h4 id="構造体に-titlecase-という名前をつけて-typedef-する。" tabindex="-1">構造体に TitleCase という名前をつけて typedef する。 <a class="header-anchor" href="#構造体に-titlecase-という名前をつけて-typedef-する。" aria-label="Permalink to &quot;構造体に TitleCase という名前をつけて typedef する。&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} Person;</span></span></code></pre></div><p>構造体には大文字と小文字を区別する必要があり、 <code>struct</code> という接頭辞がなくても認識できるようにします。また、構造体の変数に同じ名前を付けても、名前が衝突することがありません (たとえば、 <code>Banana</code> 型の <code>Banana</code> など)。構造体の名前は、後で必要になるかもしれないので、必要ない場合でも常に定義しておくべきです (たとえば、不完全な型として使用する場合など)。また、名前が先頭にあると、コメントが挿入されたときや、構造体の定義が大きくなったときに、読みやすくなります。</p><p>ただし、名前付き引数に使う構造体（後述）は、TitleCase の命名が変になるので、typedef しない。とにかく、名前付き引数にマクロを使うのであれば、typedef は不要で、struct の定義が隠れることになります。</p><p>もし、構造体を型付けすることが嫌いな場合は、代わりに <code>struct</code> ネームスペースを使用することができます（これは公平です。</p><h4 id="typedef構造体のみ。基本型やポインタは不可。" tabindex="-1">typedef構造体のみ。基本型やポインタは不可。 <a class="header-anchor" href="#typedef構造体のみ。基本型やポインタは不可。" aria-label="Permalink to &quot;typedef構造体のみ。基本型やポインタは不可。&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> centermeters;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inches;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Apple </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Apple;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gpointer;</span></span></code></pre></div><p>この間違いは非常に多くのコードベースが犯しています。これは実際に何が起こっているかを隠してしまい、ドキュメントを読むか、 <code>typedef</code> を見つけて、それをどう扱うかを学ばなければなりません。自分のインターフェイスでは決してこのようなことをせず、他のインターフェイスの型定義は無視するようにしましょう。</p><p>これらの批判は、上でアドバイスしたように、構造体の型付けにも同様に当てはまります。私見では、すべての <code>struct</code> 宣言を削除することで得られる視覚的な明瞭さは、ユーザーにこの規約を認識させる（あるいは実現させる）ことに値すると思います。また、構造体の命名規則が一貫しており、タイトルケースの名前であれば、認識しやすくなります。</p><p>ポインタの型定義は、ユーザが <code>const</code> でポインタを修飾することを排除してしまうので、特に悪質です。これは、他のルールで列挙されている理由から、大きな損失です。</p><p>関数ポインタの型定義は，関数ポインタを返す関数を宣言する必要があるときに 正当化されます．型定義なしの構文は耐え難いものです．また、関数ポインタの型が多くの場所で繰り返される場合（3つ以上、とか）にも typedef をします。すべての関数ポインタを型付けするのが好きな人もいますが、これでは何が起きていて何が期待されているのかがしばしば隠されてしまいます。関数ポインタの typedef が、実際にその型が何を表しているかを理解するのに役立つかどうか、注意深く考えてみてください。</p><h4 id="enum-に-uppercase-snake-という名前をつけ、その値を小文字にする。" tabindex="-1">enum に <code>UPPERCASE_SNAKE</code> という名前をつけ、その値を小文字にする。 <a class="header-anchor" href="#enum-に-uppercase-snake-という名前をつけ、その値を小文字にする。" aria-label="Permalink to &quot;enum に \`UPPERCASE_SNAKE\` という名前をつけ、その値を小文字にする。&quot;">​</a></h4><p>enum はほとんど単なる整数定数なので、 <code>#define</code>d 定数と同じような名前を付けるのが自然です。<code>enum</code> 型のプレフィックスは enum の値を期待することを伝え、小文字の値のサフィックスはそれらが単なる整数定数ではないことを伝えることになります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON_TYPE {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    JSON_TYPE_null,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    JSON_TYPE_boolean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    JSON_TYPE_number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h4 id="すべてのenumのサイズに対応する定数を定義する" tabindex="-1">すべてのenumのサイズに対応する定数を定義する <a class="header-anchor" href="#すべてのenumのサイズに対応する定数を定義する" aria-label="Permalink to &quot;すべてのenumのサイズに対応する定数を定義する&quot;">​</a></h4><p>ループ、配列、または <code>enum</code> のビットフィールドを扱うための、汎用的で将来性のある方法は、そうでなければありません。常に列挙のサイズを示す定数を定義して、(あなたやあなたのユーザが) ハードコードされた値を避けるようにします。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUIT {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SUIT_hearts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SUIT_diamonds,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SUIT_clubs,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SUIT_spades</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NUM_SUITS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span></code></pre></div><p>私は、サイズを最後の enum 値にするのではなく、明示的に <code>#define</code> するのが好きです。NUM_SUITS<code>は聞いたことのないカードスーツです!また、前の enum 値のいずれかが明示的に設定されている場合 (たとえば</code>SUIT_hearts = 1\` など)、最後の enum 値が enum のサイズを表さないことになるので、そのような事態も防ぐことができます。</p><h4 id="名前を-で始めたり、-t-で終わらせてはいけない-これらは標準のために予約されている" tabindex="-1">名前を <code>_</code> で始めたり、<code>_t</code> で終わらせてはいけない: これらは標準のために予約されている <a class="header-anchor" href="#名前を-で始めたり、-t-で終わらせてはいけない-これらは標準のために予約されている" aria-label="Permalink to &quot;名前を \`_\` で始めたり、\`_t\` で終わらせてはいけない: これらは標準のために予約されている&quot;">​</a></h4><p><a href="https://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html" target="_blank" rel="noreferrer">将来の ISO C 標準によって予約されている名前のリスト</a>です。<code>types_like_this_t</code> と <code>_anything</code> は将来の C 標準によって予約されている識別子であるため、あなた自身の識別子には使わないでください。</p><p>この種の名前は、どの型が言語標準の一部で、どの型がライブラリによって提供されるかを見分ける良い方法を提供することができた*はずです。残念ながら、<a href="https://github.com/facebook/libphenom" target="_blank" rel="noreferrer">it&#39;s</a> <a href="https://github.com/joyent/libuv" target="_blank" rel="noreferrer">not</a> <a href="https://github.com/liuliu/ccv" target="_blank" rel="noreferrer">hard</a> 人気のあるCライブラリやプロジェクトでこのような間違いをするものを見つけることは難しく、このようなルールの有用性は薄れてしまっているのです。</p><p>この間違いはあまりにも頻繁に起こります。あなたの図書館で同じ間違いを犯さないようにしましょう!</p><h4 id="構造体のポインタは、nullity、動的配列、不完全な型にのみ使用します。" tabindex="-1">構造体のポインタは、nullity、動的配列、不完全な型にのみ使用します。 <a class="header-anchor" href="#構造体のポインタは、nullity、動的配列、不完全な型にのみ使用します。" aria-label="Permalink to &quot;構造体のポインタは、nullity、動的配列、不完全な型にのみ使用します。&quot;">​</a></h4><p>構造体のすべてのポインタは、セグメンテーションフォールトの機会である。</p><p>もし、ポインタがNULLであってはならず、未知のサイズの配列でもなく、構造体自身の型でもない場合は、ポインタにする必要はありません。構造体の中に、その構造体自身の型のメンバを入れればいいのです。構造体のサイズについては、ベンチマークを行うまで気にする必要はありません。</p><h4 id="ポインタの引数は、nullity、配列、修飾の場合のみ使用します。" tabindex="-1">ポインタの引数は、Nullity、配列、修飾の場合のみ使用します。 <a class="header-anchor" href="#ポインタの引数は、nullity、配列、修飾の場合のみ使用します。" aria-label="Permalink to &quot;ポインタの引数は、Nullity、配列、修飾の場合のみ使用します。&quot;">​</a></h4><p>このルールは、値がどこで変更されたかを読者が推論するのに役立ちます。また、 <code>NULL</code> を受け取るべきでない関数が <code>NULL</code> を受け取れないようにすることで、安全性も向上します。これは、参照渡しのセマンティクス (従って、ほとんどすべての場所で <code>NULL</code> を有効な値として扱うこと) を要求する言語と比較して、大きな利点と言えます。</p><p>このルールに従ったコードベースを読んでいて、関数と型が最大限に分解されている場合、そのプロトタイプを読むだけで、関数が何をするのかがわかることがよくあります。これは、あらゆる場所でポインターを渡すプロジェクトとは対照的で、どこにも確信が持てません。</p><p>C言語では、構造体の値を関数に渡すと、<a href="http://c-faq.com/ptrs/passbyref.html" target="_blank" rel="noreferrer">pass-by-value semantics</a> により、受け取った関数のスタックフレームにコピーされます。元の構造体は、その関数では変更できません(変更内容を返すことはできますが)。const\` と同様に、この機能を可能な限り使用することで、読者があなたのプログラムについて推論することが容易になります。</p><p>ポインタメンバを持つ構造体を導入する場合、「修正」の定義が難しくなります。私は、構造体そのものや構造体のポインタに影響を与えるようなものを修正と呼んでいます。</p><p>構造体が関数によって「変更」される場合、その関数が構造体のポインタを受け入れる必要がなくても、受け入れるようにします。これにより、読者は、どの構造体がポインタメンバを持っているかを認識するために、関連する構造体の定義をすべて見つけて記憶する必要がなくなります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> population;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} State;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    State </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> states;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num_states;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} Country;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good: \`states\` メンバが指す配列を \`Country\` 値だけで変更できる ** にもかかわらず、 \`Country *\` を受け取ります。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> country_grow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Country </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> country</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> percent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> country-&gt;num_states; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        country-&gt;states[ i ].population </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> percent;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上の <code>country</code> 引数が const 型であることに注意してください。これは、国そのものを変更するのではなく、ポインタを変更することを意味しています (ポインタは null を表すともとれますが、関数名からはそうではなさそうです)。また、呼び出し元は <code>Country const</code> へのポインタを渡すことができます。</p><p>ポインタの引数を使用する他の状況は、関数が有効な値として <code>NULL</code> を受け入れる必要がある場合です (つまり、貧乏人の [Maybe] (<a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses" target="_blank" rel="noreferrer">http://learnyouahaskell.com/making-our-own-types-and-typeclasses</a>)) 。その場合は、 <code>const</code> を使用して、ポインタが変更されないようにシグナルを送り、 <code>const</code> 引数を受け取ることができるようにします。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Good: \`NULL\` は空のリストを表し，list は const へのポインタである．</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list_length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( List </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( ; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list-&gt;next ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このルールに従うと、不完全な構造体型を捨てることになりますが、私はとにかく構造体型が好きではありません。(Cは[オブジェクト指向ではない](#c-isnt-object-oriented and you-shouldnt-pretend-it-is)&quot; ルールを参照してください)。</p><h4 id="ポインタを変更するよりも値を返すことを優先する" tabindex="-1">ポインタを変更するよりも値を返すことを優先する <a class="header-anchor" href="#ポインタを変更するよりも値を返すことを優先する" aria-label="Permalink to &quot;ポインタを変更するよりも値を返すことを優先する&quot;">​</a></h4><p>これは不変性を促進し、<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noreferrer">純粋関数</a>を育成し、物事をより単純化し理解しやすくするものです。また、引数が <code>NULL</code> である可能性を排除することで、安全性も向上している。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い点：不要な変異（たぶん）、安全でないこと</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> drink_mix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Drink </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> drink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Ingredient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ingr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( drink </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    color_blend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( drink-&gt;color ), ingr.color );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    drink-&gt;alcohol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ingr.alcohol;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い点：不変性の石、どこでも純粋で安全な関数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Drink </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drink_mix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Drink </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> drink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Ingredient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ingr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( Drink ){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> color_blend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( drink.color, ingr.color ),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .alcohol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> drink.alcohol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ingr.alcohol</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これは必ずしもベストな方法とは言えませんが、常に検討すべきことです。</p><h4 id="関数のオプション引数の名前に構造体を使用する" tabindex="-1">関数のオプション引数の名前に構造体を使用する <a class="header-anchor" href="#関数のオプション引数の名前に構造体を使用する" aria-label="Permalink to &quot;関数のオプション引数の名前に構造体を使用する&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> run_server_options {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> port;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> backlog;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run_server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ... ) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    run_server_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> run_server_options ){ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* default values */</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;45680&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .backlog </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        __VA_ARGS__</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run_server_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> run_server_options </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run_server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( .port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;3490&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, .backlog </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>私はこれを<em>21st Century C</em>で学びました。多くのCのインターフェイスは、このテクニックを利用すれば、非常に改善されるはずです。ソフトウェア開発において、（構文的な）名前付き引数の重要性と価値は、あまりにも見落とされがちです。もし納得がいかないなら、Bret Victor の <a href="http://worrydream.com/LearnableProgramming/" target="_blank" rel="noreferrer">Learnable Programming</a> を読んでみてください。</p><p>名前付き引数をどこでも使ってはいけない。ある関数の唯一の引数がたまたま構造体であったとしても、それが必ずしもその関数の名前付き引数になるとは限りません。経験則から言うと、もしその構造体がその関数の外で使われるなら、上記のようなマクロで隠すべきでないということです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// よかった。ここでのタイプ分けは参考になるし、期待できる。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">book_new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ( Author ){ .name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Dennis Ritchie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } );</span></span></code></pre></div><h4 id="構造体リテラルでは常に指定イニシャライザーを使用する。" tabindex="-1">構造体リテラルでは常に指定イニシャライザーを使用する。 <a class="header-anchor" href="#構造体リテラルでは常に指定イニシャライザーを使用する。" aria-label="Permalink to &quot;構造体リテラルでは常に指定イニシャライザーを使用する。&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 悪い点 - 構造体のメンバを並べ替えると壊れるし、値が何を表しているのかが常に明確でない。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Fruit apple </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;medium&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 良い; 将来性、描写力</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Fruit watermelon </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { .color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, .size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;large&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>名前付き引数の場合、このルールを曲げて、特定のフィールドを構造体の先頭に持ってきて、呼び出し側がその引数に名前を付けずに関数を呼び出せるようにすることがあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run_server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3490&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run_server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( .port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;3490&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, .backlog </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span></code></pre></div><p>もし、これを許可したいのであれば、明示的に文書化してください。フィールドの順序を変更した場合、ライブラリのバージョンを正しく変更するのはあなたの責任です。</p><h4 id="構造体のメンバに対してのみアロケーションとフリー関数を提供する場合、構造体全体に対してメモリをアロケーションします。" tabindex="-1">構造体のメンバに対してのみアロケーションとフリー関数を提供する場合、構造体全体に対してメモリをアロケーションします。 <a class="header-anchor" href="#構造体のメンバに対してのみアロケーションとフリー関数を提供する場合、構造体全体に対してメモリをアロケーションします。" aria-label="Permalink to &quot;構造体のメンバに対してのみアロケーションとフリー関数を提供する場合、構造体全体に対してメモリをアロケーションします。&quot;">​</a></h4><p>もし、 <code>foo_alloc</code> と <code>foo_free</code> 関数を提供して、 <code>Foo</code> 構造体のメンバに対してのみメモリを確保するのであれば、自動保存の利点と安全性を失うことになります。foo_alloc<code>と</code>foo_ree<code>の関数は、</code>Foo\` 構造体のメンバにメモリを割り当てるためだけに用意されているのであれば、自動保存の利点と安全性を失ってしまいます。</p><h4 id="ゲッターとセッターを避ける" tabindex="-1">ゲッターとセッターを避ける <a class="header-anchor" href="#ゲッターとセッターを避ける" aria-label="Permalink to &quot;ゲッターとセッターを避ける&quot;">​</a></h4><p>もし、あなたがC言語でカプセル化を求めているなら、おそらく物事を複雑にしすぎているのでしょう。構造体のメンバに直接アクセスしたり設定したりするようにしましょう。メンバの先頭に <code>_</code> を付けてアクセスレベルを示すようなことはしないでください。構造体の不変量を宣言しておけば、ユーザーが何かを壊してしまうことを心配する必要はありません。</p><p>[別のルール](#always-prefer-to-return-a-value-rather than modifying-pointers) でアドバイスしたように、可能な限り変異を避けるようにしましょう。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// というより、むしろ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> city_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( City </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c-&gt;state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c-&gt;country </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> country_of_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( state );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 常に不変と純粋を好む。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">City </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">city_with_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( City </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c.country </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> country_of_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( state );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">City c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { .name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Vancouver&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> city_with_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( c, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;BC&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is in </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, did you know?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c.name, c.country );</span></span></code></pre></div><p>しかし、常に<a href="https://en.wikipedia.org/wiki/Declarative_programming" target="_blank" rel="noreferrer">宣言的プログラミング</a>を可能にするインターフェイスを提供する必要があります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">City </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> city_new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( .name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Boston&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, .state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I think I&#39;m going to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Where no one changes my state</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c.name, c.country );</span></span></code></pre></div><h4 id="cはオブジェクト指向ではないし、オブジェクト指向のふりをするべきではない" tabindex="-1">Cはオブジェクト指向ではないし、オブジェクト指向のふりをするべきではない <a class="header-anchor" href="#cはオブジェクト指向ではないし、オブジェクト指向のふりをするべきではない" aria-label="Permalink to &quot;Cはオブジェクト指向ではないし、オブジェクト指向のふりをするべきではない&quot;">​</a></h4><p>C言語にはクラスもメソッドも継承もオブジェクトのカプセル化も真のポリモーフィズムもないのです。失礼かもしれませんが、でも失礼な言い方ですが、<strong>deal with it</strong> です。C言語では、それらのくだらない、複雑な模倣を実現できるかもしれませんが、その価値はないのです。</p><p>結局のところ、C言語にはすでに完全に対応できる言語モデルがあるのです。C言語では、データ構造を定義し、そのデータ構造を組み合わせて使う機能を定義する。データと機能が複雑な仕掛けで絡み合っていない、これは良いことです。</p><p>言語設計の最先端を行くHaskellも、同じようにデータと機能を切り離す決断をしたのです。Haskellを学ぶことは、プログラマーが自分の技術を向上させるためにできる最善のことのひとつですが、CとHaskellの根本的な共通点から、Cプログラマーには特に有益だと思います。確かにC言語には無名関数がありませんし、C言語ですぐにモナドを書くこともないでしょう。しかし、Haskellを学ぶことで、クラスなし、ミュータビリティなし、モジュール性ありの優れたソフトウェアを書く方法を学ぶことができます。これらの性質は、優れたC言語プログラミングにとって非常に有益なものです。</p><p>他のパラダイムをCに移植しようとするのではなく、Cが提供するものを受け入れ、評価しましょう。</p>`,305)]))}const c=i(l,[["render",t]]);export{g as __pageData,c as default};
