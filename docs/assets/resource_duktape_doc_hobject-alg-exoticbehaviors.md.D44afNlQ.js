import{_ as o,c as t,a2 as c,o as d}from"./chunks/framework.DPuwY6B9.js";const f=JSON.parse('{"title":"Exotic behaviors","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-exoticbehaviors.md","filePath":"resource/duktape/doc/hobject-alg-exoticbehaviors.md","lastUpdated":null}'),a={name:"resource/duktape/doc/hobject-alg-exoticbehaviors.md"};function r(i,e,n,l,s,h){return d(),t("div",null,e[0]||(e[0]=[c('<h1 id="exotic-behaviors" tabindex="-1">Exotic behaviors <a class="header-anchor" href="#exotic-behaviors" aria-label="Permalink to &quot;Exotic behaviors&quot;">​</a></h1><p>This section covers the standard algorithms with exotic behaviors inlined. For each algorithm, a single algorithm with all exotic behaviors inlined is presented. Calls to other internal algorithms are not inlined; the purpose is to clarify how the exotic behaviors can be implemented reasonably.</p><p>Note: the <code>String</code> object has no exotic behaviors as such, but the <code>length</code> and array index properties are implemented as virtual properties, so they are inlined into the algorithms below.</p><h2 id="getownproperty" tabindex="-1">GetOwnProperty <a class="header-anchor" href="#getownproperty" aria-label="Permalink to &quot;GetOwnProperty&quot;">​</a></h2><p>Related E5 sections:</p><ul><li>E5 Section 8.12.1: default algorithm</li><li>E5 Section 15.5.5: <code>String</code></li><li>E5 Section 10.5: arguments object</li></ul><h3 id="default-algorithm" tabindex="-1">Default algorithm <a class="header-anchor" href="#default-algorithm" aria-label="Permalink to &quot;Default algorithm&quot;">​</a></h3><ol><li>If <code>O</code> doesn&#39;t have an own property with name <code>P</code>, return <code>undefined</code>.</li><li>Let <code>D</code> be a newly created Property Descriptor with no fields.</li><li>Let <code>X</code> be <code>O</code>&#39;s own property named P.</li><li>If <code>X</code> is a data property, then a. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. b. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute.</li><li>Else <code>X</code> is an accessor property, so a. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. b. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute.</li><li>Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute.</li><li>Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute.</li><li>Return <code>D</code>.</li></ol><h3 id="adding-string-object-exotic-behavior" tabindex="-1">Adding String object exotic behavior <a class="header-anchor" href="#adding-string-object-exotic-behavior" aria-label="Permalink to &quot;Adding String object exotic behavior&quot;">​</a></h3><p>Now consider the <code>String</code> variant in E5 Section 15.5.5.2. Step 2 states that if the default algorithm returns a descriptor (not undefined), the exotic behavior does not execute at all. That, is the exotic algorithm is skipped if <code>O</code> has an &quot;own property&quot; for key <code>P</code>.</p><p>If the default algorithm fails to find an own property, the variant kicks in checking for a valid array index key which is inside the string length. If so, it returns a single character data property descriptor. The descriptor has <code>[[Writable]]</code> and <code>[[Configurable]]</code> set to <code>false</code> which means that the property cannot be written or deleted -- the property is thus perfect for implementation as a virtual property backed to an immutable internal string value.</p><p>::: note ::: title Note :::</p><p>ECMAScript 5.1 no longer requires the numbered index to be a valid array index, any number-like value will do. This allows strings longer than 4G. The algorithms here don&#39;t reflect this correctly. :::</p><p>The <code>String</code> object <code>length</code> property is an ordinary (non-exotic) property, see E5 Section 15.5.5.1. However, it is non-writable and non-configurable (and even non-enumerable), so it too is nice and easy to implement as a exotic property. We&#39;ll thus incorporate the <code>length</code> property into the algorithm.</p><p>Finally note that from an implementation perspective it might be easier to check for the exotic (virtual) properties before looking at the actual ones (i.e. reverse the order of checking). This seems perfectly OK to do, because <em>if</em> the property name matches a virtual property, the object cannot have a &quot;normal&quot; property of the same name: the initial <code>String</code> object does not have such properties, and since the virtual properties cannot be deleted, they prevent the insertion of normal &quot;own properties&quot; of the same name. Hence, if the virtual properties are checked for first and the check matches, the object is guaranteed not to have a normal property of the same name. (Whether this is useful in an implementation is another issue.)</p><p>The combined algorithm, assuming the the virtual properties are checked after the normal property check is as follows:</p><ol><li>If <code>O</code> doesn&#39;t have an own property with name <code>P</code>: a. If <code>O</code> is not a <code>String</code> instance, return <code>undefined</code>. b. (<code>String</code> object exotic behavior.) Let <code>str</code> be the String value of the <code>[[PrimitiveValue]]</code> internal property of <code>O</code> and <code>len</code> be the number of characters in <code>str</code>. c. If <code>P</code> is <code>&quot;length&quot;</code>, return a Property Descriptor with the values: - <code>[[Value]]: len</code> (a number) - <code>[[Enumerable]]: false</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> d. If <code>P</code> is not an array index (E5 Section 15.4), return <code>undefined</code>. e. Let <code>index</code> be <code>ToUint32(P)</code>. f. If <code>len</code> &lt;= <code>index</code>, return <code>undefined</code>. g. Let <code>resultStr</code> be a string of length 1, containing one character from <code>str</code>, specifically the character at position <code>index</code>, where the first (leftmost) character in <code>str</code> is considered to be at position 0, the next one at position 1, and so on. h. Return a Property Descriptor with the values: - <code>[[Value]]: resultStr</code> - <code>[[Enumerable]]: true</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code></li><li>Let <code>D</code> be a newly created Property Descriptor with no fields.</li><li>Let <code>X</code> be <code>O</code>&#39;s own property named <code>P</code>.</li><li>If <code>X</code> is a data property, then a. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. b. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute.</li><li>Else <code>X</code> is an accessor property, so a. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. b. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute.</li><li>Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute.</li><li>Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute.</li><li>Return <code>D</code>.</li></ol><h3 id="adding-arguments-object-exotic-behavior" tabindex="-1">Adding arguments object exotic behavior <a class="header-anchor" href="#adding-arguments-object-exotic-behavior" aria-label="Permalink to &quot;Adding arguments object exotic behavior&quot;">​</a></h3><p>Next, consider the exotic <code>[[GetOwnProperty]]</code> behavior for a non-strict arguments object described in E5 Section 10.6. The exotic behavior only applies if the object <em>did</em> contain the own property <code>P</code>, and possibly modifies the looked up value if the key <code>P</code> matches a numeric index magically &quot;bound&quot; to a formal.</p><p>Note that the property descriptors for such variables are initially data property descriptors, so the default algorithm will find a data property descriptor (and not an accessor property descriptor). If the property is later converted to an accessor, the magical variable binding is also dropped. So, if the exotic behavior activates, the property is always a data property.</p><p>The exotic behavior can be appended to the above algorithm as follows:</p><ol><li>If <code>O</code> doesn&#39;t have an own property with name <code>P</code>: a. If <code>O</code> is not a <code>String</code> instance, return <code>undefined</code>. b. (<code>String</code> object exotic behavior.) Let <code>str</code> be the String value of the <code>[[PrimitiveValue]]</code> internal property of <code>O</code> and <code>len</code> be the number of characters in <code>str</code>. c. If <code>P</code> is <code>&quot;length&quot;</code>, return a Property Descriptor with the values: - <code>[[Value]]: len</code> (a number) - <code>[[Enumerable]]: false</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> d. If <code>P</code> is not an array index (E5 Section 15.4), return <code>undefined</code>. e. Else let <code>index</code> be <code>ToUint32(P)</code>. f. If <code>len</code> &lt;= <code>index</code>, return <code>undefined</code>. g. Let <code>resultStr</code> be a string of length 1, containing one character from <code>str</code>, specifically the character at position <code>index</code>, where the first (leftmost) character in <code>str</code> is considered to be at position 0, the next one at position 1, and so on. h. Return a Property Descriptor with the values: - <code>[[Value]]: resultStr</code> - <code>[[Enumerable]]: true</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code></li><li>Let <code>D</code> be a newly created Property Descriptor with no fields.</li><li>Let <code>X</code> be <code>O</code>&#39;s own property named <code>P</code>.</li><li>If <code>X</code> is a data property, then a. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. b. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute.</li><li>Else <code>X</code> is an accessor property, so a. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. b. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute.</li><li>Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute.</li><li>Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute.</li><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. Let <code>isMapped</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument. c. If the value of <code>isMapped</code> is not <code>undefined</code>, then: 1. Set <code>D.[[Value]]</code> to the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Return <code>D</code>.</li></ol><p>Notes:</p><ul><li>Step 1.b: if the object is a <code>String</code> object, there is no need for the arguments object exotic behavior check in step 8: an object can never be a <code>String</code> object and an arguments object simultaenously.</li><li>Step 8: arguments objects for strict mode functions don&#39;t have the exotic behavior (or a <code>[[ParameterMap]]</code>). Arguments objects for non-strict functions don&#39;t always have exotic behavior either: they only do, if there is at least one mapped variable. If so, <code>[[ParameterMap]]</code> is added, and exotic behavior is enabled. See the main algorithm in E5 Section 10.6, step 12.</li><li>Step 8.c.1: this step invokes an internal getter function which looks up the magically bound variable. See E5 Section 10.6, 11.c.ii, and the <em>MakeArgGetter</em> concept. A practical implementation may not create such internal functions (we don&#39;t).</li><li>Step 8.c.1: the rules of maintaining the <code>[[ParameterMap]]</code> ensures that at this point the property is always a data property, so setting the <code>[[Value]]</code> is correct. If a magically bound value is converted into an accessor, the property is deleted from the <code>[[ParameterMap]]</code> so it no longer has exotic behavior.</li></ul><h3 id="final-version" tabindex="-1">Final version <a class="header-anchor" href="#final-version" aria-label="Permalink to &quot;Final version&quot;">​</a></h3><p>Final version with some cleanup and simplification:</p><ol><li>Let <code>X</code> be <code>O</code>&#39;s own property named <code>P</code>. If <code>O</code> doesn&#39;t have an own property with name <code>P</code>: a. If <code>O</code> is not a <code>String</code> instance, return <code>undefined</code>. b. (<code>String</code> object exotic behavior.) Let <code>str</code> be the String value of the <code>[[PrimitiveValue]]</code> internal property of <code>O</code> and <code>len</code> be the number of characters in <code>str</code>. c. If <code>P</code> is <code>&quot;length&quot;</code>: 1. Return a Property Descriptor with the values: - <code>[[Value]]: len</code> (a primitive number) - <code>[[Enumerable]]: false</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> d. If <code>P</code> is an array index (E5 Section 15.4): 1. Let <code>index</code> be <code>ToUint32(P)</code>. 2. If <code>index</code> &lt; <code>len</code>, return a Property Descriptor with the values: - <code>[[Value]]:</code> a primitive string of length 1, containing one character from <code>str</code> at position <code>index</code> (zero based index) - <code>[[Enumerable]]: true</code> - <code>[[Writable]]: false</code> - <code>[[Configurable]]: false</code> e. Return <code>undefined</code>.</li><li>Let <code>D</code> be a newly created Property Descriptor filled as follows: a. If <code>X</code> is a data property: 1. Set <code>D.[[Value]]</code> to the value of <code>X</code>&#39;s <code>[[Value]]</code> attribute. 2. Set <code>D.[[Writable]]</code> to the value of <code>X</code>&#39;s <code>[[Writable]]</code> attribute. b. Else <code>X</code> is an accessor property: 1. Set <code>D.[[Get]]</code> to the value of <code>X</code>&#39;s <code>[[Get]]</code> attribute. 2. Set <code>D.[[Set]]</code> to the value of <code>X</code>&#39;s <code>[[Set]]</code> attribute. c. For either type of property: 1. Set <code>D.[[Enumerable]]</code> to the value of <code>X</code>&#39;s <code>[[Enumerable]]</code> attribute. 2. Set <code>D.[[Configurable]]</code> to the value of <code>X</code>&#39;s <code>[[Configurable]]</code> attribute.</li><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Set <code>D.[[Value]]</code> to the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Return <code>D</code>.</li></ol><p>Notes:</p><ul><li>Step 3 can be skipped for accessors.</li></ul><h3 id="get" tabindex="-1">Get <a class="header-anchor" href="#get" aria-label="Permalink to &quot;Get&quot;">​</a></h3><p>Related E5 sections:</p><ul><li>E5 Section 8.12.3: default algorithm</li><li>E5 Section 10.5: arguments object</li><li>E5 Section 15.3.5.4: <code>Function</code></li></ul><h3 id="default-algorithm-1" tabindex="-1">Default algorithm <a class="header-anchor" href="#default-algorithm-1" aria-label="Permalink to &quot;Default algorithm&quot;">​</a></h3><p>(Note that E5 Section 8.12.3 has broken numbering; fixed below.)</p><ol><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>, return <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code> so, let <code>getter</code> be <code>desc.[[Get]]</code>.</li><li>If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>Return the result calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments.</li></ol><h3 id="adding-function-object-exotic-behavior" tabindex="-1">Adding Function object exotic behavior <a class="header-anchor" href="#adding-function-object-exotic-behavior" aria-label="Permalink to &quot;Adding Function object exotic behavior&quot;">​</a></h3><p>Consider the <code>Function</code> variant in E5 Section 15.3.5.4. The behavior only applies if <code>P</code> is <code>caller</code> and the resulting return <em>value</em> of the default function is a strict mode function.</p><p>The exotic behavior does not need to be checked in steps 2 or 5 of the default algorithm, because <code>undefined</code> is never a strict mode function value.</p><p>So, we can reformulate into:</p><ol><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments.</li><li>If <code>O</code> is a <code>Function</code> object, <code>P</code> is <code>&quot;caller&quot;</code>, and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><h3 id="adding-arguments-object-exotic-behavior-1" tabindex="-1">Adding arguments object exotic behavior <a class="header-anchor" href="#adding-arguments-object-exotic-behavior-1" aria-label="Permalink to &quot;Adding arguments object exotic behavior&quot;">​</a></h3><p>Next, consider the exotic <code>[[Get]]</code> behavior for a non-strict arguments object described in E5 Section 10.6. To be exact, the exotic behaviors are only enabled for objects with a non-empty initial <code>[[ParameterMap]]</code> (see E5 Section 10.6, main algorithm, step 12).</p><p>There are two exotic behaviors:</p><ol><li>If the property name <code>P</code> is magically bound to an identifier (through the <code>[[ParameterMap]]</code>) the default <code>[[Get]]</code> is bypassed entirely and the property value is read. (Note that the property <code>P</code><em>must</em> be a data property in this case, so no side effects are lost by this behavior.)</li><li>If the property name <code>P</code> is <em>not bound</em> to an identifier, the <code>&quot;caller&quot;</code> property has exotic behavior essentially identical to that of <code>Function</code>.</li></ol><p>These can be incorporated as follows:</p><ol><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. Let <code>isMapped</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument. c. If the value of <code>isMapped</code> is not <code>undefined</code>, then: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments.</li><li>If <code>O</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>Note:</p><ul><li>Step 1 can match only when <code>P</code> is a &quot;numeric&quot; property name, and the property value is an own data property. Magically bound properties are initially own data properties, and if they&#39;re changed to accessors (or deleted), the binding is removed. Because of this, the arguments exotic behavior could just as well be moved to the end of the algorithm.</li></ul><h3 id="final-version-1" tabindex="-1">Final version <a class="header-anchor" href="#final-version-1" aria-label="Permalink to &quot;Final version&quot;">​</a></h3><p>Final version with some cleanup and simplification:</p><ol><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments.</li><li>If <code>O</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><h2 id="defineownproperty" tabindex="-1">DefineOwnProperty <a class="header-anchor" href="#defineownproperty" aria-label="Permalink to &quot;DefineOwnProperty&quot;">​</a></h2><p>Related E5 sections:</p><ul><li>E5 Section 8.12.9: default algorithm</li><li>E5 Section 15.4.5: <code>Array</code></li><li>E5 Section 10.5: arguments object</li></ul><p>Note that <code>String</code> exotic properties are taken into account by <code>[[DefineOwnProperty]]</code> through <code>[[GetOwnProperty]]</code> which returns a property descriptor prohibiting any property value or attribute changes. However, no explicit checks are needed for these (virtual) properties.</p><p>This is by the far the most complex property algorithm, especially with exotic behaviors incorporated. The algorithm itself is complex, but the <code>Array</code> variant actually makes multiple calls to the default variant which is even trickier for &quot;inlining&quot;.</p><h3 id="default-algorithm-2" tabindex="-1">Default algorithm <a class="header-anchor" href="#default-algorithm-2" aria-label="Permalink to &quot;Default algorithm&quot;">​</a></h3><ol><li>Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code> and <code>extensible</code> is <code>false</code>, then Reject.</li><li>If <code>current</code> is <code>undefined</code> and <code>extensible</code> is <code>true</code>, then a. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. b. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Return <code>true</code>.</li><li>Return <code>true</code> if every field in <code>Desc</code> is absent.</li><li>Return <code>true</code>, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12).</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Reject, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Reject, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then no further validation is required.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Reject, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Reject, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, then a. Reject, if the <code>[[Value]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. else, the <code>[[Configurable]]</code> field of <code>current</code> is <code>true</code>, so any change is acceptable.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Reject, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Reject, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>.</li><li>For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li>Return <code>true</code>.</li></ol><p>Notes:</p><ul><li>The default attributes are <em>not</em> the same as when <code>[[Put]]</code> creates a new property. The defaults here are &quot;false&quot; (and NULL for getter/setter), see E5 Section 8.6.1, Table 7).</li><li>Step 10.a.1 allows a non-configurable property to change from writable to non-writable, but not vice versa.</li><li>Step 10.b is not necessary (it is more of an assertion), and there is no corresponding step 11.b mentioning the same thing. This step can be removed from the description.</li><li>There are multiple exit points for both Reject (throw or return false) and true. For incorporating inline exotic behaviors, these are turned to &quot;gotos&quot; below.</li></ul><h3 id="default-algorithm-reformulated" tabindex="-1">Default algorithm reformulated <a class="header-anchor" href="#default-algorithm-reformulated" aria-label="Permalink to &quot;Default algorithm reformulated&quot;">​</a></h3><p>Let&#39;s first do a little bit of reformulation (see above):</p><ol><li>Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code>: a. If <code>extensible</code> is <code>false</code>, then goto REJECT. b. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. d. Goto SUCCESS.</li><li>Goto SUCCESS, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12). (This also covers the case where every field in <code>Desc</code> is absent.)</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Goto REJECT, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. d. Goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. Goto REJECT, If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, and the <code>[[Value]]</code> field of <code>Desc</code> is present, and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Goto REJECT, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li><strong>VALIDATED:</strong> For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li><strong>SUCCESS:</strong> Return <code>true</code>.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return <code>false</code>.</li></ol><h3 id="analysis-of-array-object-defineownproperty" tabindex="-1">Analysis of Array object [[DefineOwnProperty]] <a class="header-anchor" href="#analysis-of-array-object-defineownproperty" aria-label="Permalink to &quot;Analysis of Array object \\[\\[DefineOwnProperty\\]\\]&quot;">​</a></h3><p>The <code>Array</code> variant for <code>[[DefineOwnProperty]]</code> is described in E5 Section 15.4.5.1. The variant <em>seems</em> to be essentially a pre-check for <code>length</code> and array index properties before the default algorithm runs (see steps 1-4 of the variant).</p><p>However, it&#39;s much more complex than that, because the variant algorithm makes multiple calls to the default algorithm.</p><p>Let&#39;s look at the variant algorithm first (here we assume <code>O</code> is an <code>Array</code> with exotic behavior, so no check is made for exotic behavior):</p><ol><li>Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured.</li><li>Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.)</li><li>If <code>P</code> is <code>&quot;length&quot;</code>, then a. If the <code>[[Value]]</code> field of <code>Desc</code> is absent, then 1. Return the result of calling the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, <code>Desc</code>, and <code>Throw</code> as arguments. b. Let <code>newLenDesc</code> be a copy of <code>Desc</code>. c. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. d. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, throw a <code>RangeError</code> exception. e. Set <code>newLenDesc.[[Value]]</code> to <code>newLen</code>. f. If <code>newLen</code> &gt;= <code>oldLen</code>, then 1. Return the result of calling the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, <code>newLenDesc</code>, and <code>Throw</code> as arguments. g. Reject if <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. h. If <code>newLenDesc.[[Writable]]</code> is absent or has the value <code>true</code>, let <code>newWritable</code> be <code>true</code>. i. Else, 1. Need to defer setting the <code>[[Writable]]</code> attribute to <code>false</code> in case any elements cannot be deleted. 2. Let <code>newWritable</code> be <code>false</code>. 3. Set <code>newLenDesc.[[Writable]]</code> to <code>true</code>. j. Let <code>succeeded</code> be the result of calling the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, <code>newLenDesc</code>, and <code>Throw</code> as arguments. k. If <code>succeeded</code> is <code>false</code>, return <code>false</code>. l. While <code>newLen</code> &lt; <code>oldLen</code> repeat, 1. Set <code>oldLen</code> to <code>oldLen - 1</code>. 2. Let <code>canDelete</code> be the result of calling the <code>[[Delete]]</code> internal method of <code>O</code> passing <code>ToString(oldLen)</code> and <code>false</code> as arguments. 3. If <code>canDelete</code> is <code>false</code>, then: a. Set <code>newLenDesc.[[Value]</code> to <code>oldLen+1</code>. b. If <code>newWritable</code> is <code>false</code>, set <code>newLenDesc.[[Writable]</code> to <code>false</code>. c. Call the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, <code>newLenDesc</code>, and <code>false</code> as arguments. d. Reject. m. If <code>newWritable</code> is <code>false</code>, then 1. Call the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, Property Descriptor <code>{[[Writable]]: false}</code>, and <code>false</code> as arguments. This call will always return <code>true</code>. n. Return <code>true</code>.</li><li>Else if <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>index</code> be <code>ToUint32(P)</code>. b. Reject if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. c. Let <code>succeeded</code> be the result of calling the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>P</code>, <code>Desc</code>, and <code>false</code> as arguments. d. Reject if <code>succeeded</code> is <code>false</code>. e. If <code>index</code> &gt;= <code>oldLen</code>: 1. Set <code>oldLenDesc.[[Value]]</code> to <code>index + 1</code>. 2. Call the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>&quot;length&quot;</code>, <code>oldLenDesc</code>, and <code>false</code> as arguments. This call will always return <code>true</code>. f. Return <code>true</code>.</li><li>Return the result of calling the default <code>[[DefineOwnProperty]]</code> internal method (E5 Section 8.12.9) on <code>O</code> passing <code>P</code>, <code>Desc</code>, and <code>Throw</code> as arguments.</li></ol><p>Notes:</p><ul><li>In E5 Section 15.4.5.1 step 3.l.ii - 3.l.iii the temporary variable <code>cannotDelete</code> seems to be misused; it should probably be <code>canDelete</code> and the check in step iii should read &quot;if <code>canDelete</code> is <code>false</code> ...&quot;.</li><li>Step 5 is the default behavior, assuming nothing &quot;captured&quot; the call before.</li><li>Unfortunately steps 3 and 4 call the default <code>[[DefineOwnProperty]]</code> internally (multiple times). We&#39;d like to avoid this, to get a non-recursive implementation. This requires some major restatements.</li></ul><p>Let&#39;s look at the calls to the default <code>[[DefineOwnProperty]]</code> (other than step 5) to see what could be done about them.</p><p>First, for <code>P</code> == <code>length</code>:</p><ul><li><p>Step 3.a.1: If <code>Desc.[[Value]]</code> is absent, call the default algorithm.</p><p>This is equivalent to:</p><ul><li>Jumping to step 5.</li></ul></li><li><p>Step 3.f.1: If <code>newLen</code> validation succeeds and new length is not shorter than previous, call the default algorithm with a modified property descriptor, <code>newLenDesc</code>. The new property descriptor is a copy of the original, with <code>[[Value]]</code> changed to the normalized and numeric (32-bit unsigned integer) length value.</p><p>This is equivalent to:</p><ul><li>Doing length validation and coercion</li><li>Checking that the new length is not shorter than previous; and if so, forcing <code>Desc.[[Value]]</code> to <code>newLen</code>, and then jumping to step 5.</li><li>Note: the caller&#39;s view of <code>Desc</code> must not change, so <code>Desc</code> cannot be a &quot;pass by reference&quot; value.</li></ul></li><li><p>Step 3.f.j: Here <code>newLen</code> validation has succeeded, and the new length is shorter than previous. Also, <code>Desc.[[Writable]]</code> may have been fudged. The changes so far are &quot;committed&quot; to <code>&quot;length&quot;</code> property using the default call.</p><p>Note that this call also has the important effect of checking that the default algorithm is expected to succeed before we touch any of the array elements.</p><p>This is equivalent to:</p><ul><li>Doing the <code>newWritable</code> fudging to <code>Desc</code>, and keeping <code>newWritable</code> for later.</li><li>Jumping to step 5.</li><li>Adding a post-step to the default algorithm for steps 3.k - 3.m.</li></ul></li><li><p>Step 3.l.3.c: Here we&#39;ve started to &quot;shorten&quot; the array but run into a non-deletable element. The <code>&quot;length&quot;</code> property is updated with the actual final length, and <code>Desc.[[Writable]]</code> is fudged back to its original, requested value.</p><p>This is equivalent to:</p><ul><li>Fudging both <code>[[Value]]</code> and <code>[[Writable]]</code> of <code>Desc</code>.</li><li>Jumping to step 5.</li></ul></li><li><p>Step 3.m: Here a pending write protection is finally implemented by calling the default <code>[[DefineOwnProperty]]</code> with a property descriptor requesting only that the property be changed to non-writable.</p><p>This is equivalent to:</p><ul><li>Adding a &quot;pending write protect&quot; flag and jumping to 5.</li><li>Modifying the standard algorithm to recognize a &quot;pending write protect&quot; after standard property modifications and checks are complete.</li></ul></li></ul><p>Then, for the case when <code>P</code> is a valid array index:</p><ul><li><p>Step 4.c: The index has been coerced and validated; the algorithm rejects if the array index would require that the array <code>length</code> be increased but <code>length</code> is write protected.</p><p>This is equivalent to:</p><ul><li>Doing the pre-checks for index vs. <code>length</code>.</li><li>Jumping to step 5.</li><li>Adding a post-step to the standard algorithm to handle steps 4.d - 4.f.</li></ul></li><li><p>Step 4.e.2: This is a step which happens after the default algorithm has finished without errors. If so, and the array index extended the array <code>length</code>, the array <code>length</code> is updated to reflect this. This is expected to always succeed.</p><p>This is equivalent to:</p><ul><li>Adding a post-step to the standard algorithm.</li></ul></li></ul><p>A draft of modifications to the standard algorithm to avoid recursive calls could be something like:</p><ul><li>Add a pre-step with: <ul><li>Check for <code>P</code> == <code>length</code>, and: <ul><li>If <code>Desc.[[Value]]</code> missing, use default algorithm</li><li><code>newLen</code> validation and updating of <code>Desc.[[Value]]</code></li><li>If new length is not shorter than old length, default algorithm with the modified <code>Desc</code> can be used</li><li>Possible fudging of <code>Desc.[[Writable]]</code> and check for setting <code>pendingWriteProtect</code> (set if <code>newWritable</code> is <code>false</code>)</li><li>If new length is shorter than old length, run the default algorithm successfully first before touching array elements</li></ul></li><li>Check for <code>P</code> being a valid array index, and: <ul><li>Pre-checks for index vs. <code>length</code></li></ul></li></ul></li><li>Modify the standard algorithm: <ul><li>Continuing with the post-step if the standard algorithm succeeds.</li></ul></li><li>Add a post-step with: <ul><li>Check whether we have a pending array &quot;shortening&quot;, i.e. <code>P</code> was <code>&quot;length&quot;</code>, and the new length is shorter than old. <ul><li>A complex algorithm for shortening the array needs to run. This algorithm may either indicate success or failure, and returns the actual final length of the array which may differ from the requested one if a non-configurable element prevents deletion.</li></ul></li><li>Check for <code>pendingWriteProtect</code>; if so, write protect the target property (this is for step 3.m).</li><li>Check whether <code>P</code> was an array index which should increase the length of the array. <ul><li>If so, we&#39;ve already checked in the pre-step that the length can be updated. So, update the pending new length value.</li></ul></li></ul></li></ul><p>The algorithm for shortening the array is not inlined (it is a separate helper in the implementation too) as it&#39;s relatively tricky. It is instead isolated into <code>ShortenArray()</code> internal helper with inputs:</p><ul><li>old length</li><li>new length</li></ul><p>and outputs:</p><ul><li>success flag (<code>false</code> if some element couldn&#39;t be deleted)</li><li>final array length to be updated into <code>&quot;length&quot;</code> property</li></ul><h3 id="adding-array-object-exotic-behavior" tabindex="-1">Adding <code>Array</code> object exotic behavior <a class="header-anchor" href="#adding-array-object-exotic-behavior" aria-label="Permalink to &quot;Adding `Array` object exotic behavior&quot;">​</a></h3><p>Incorporating the approach for adding a pre- and post-processing phase we get something like:</p><ol><li>Set <code>pendingWriteProtect</code> to <code>false</code>.</li><li>If <code>O</code> is not an <code>Array</code> object, goto SKIPARRAY.</li><li>Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured.</li><li>Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.)</li><li>If <code>P</code> is <code>&quot;length&quot;</code>, then a. If the <code>[[Value]]</code> field of <code>Desc</code> is absent, then goto SKIPARRAY. b. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. c. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, goto REJECTRANGE. d. Set <code>Desc.[[Value]]</code> to <code>newLen</code>. e. If <code>newLen</code> &gt;= <code>oldLen</code>, then goto SKIPARRAY. f. Goto REJECT if <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. g. If <code>Desc.[[Writable]]</code> has the value <code>false</code>: 1. Need to defer setting the <code>[[Writable]]</code> attribute to <code>false</code> in case any elements cannot be deleted. 2. Set <code>pendingWriteProtect</code> to <code>true</code>. 3. Set <code>Desc.[[Writable]]</code> to <code>true</code>. h. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li>Else if <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>index</code> be <code>ToUint32(P)</code>. b. Goto REJECT if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. c. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li><strong>SKIPARRAY</strong>: Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code>: a. If <code>extensible</code> is <code>false</code>, then goto REJECT. b. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. d. Goto SUCCESS.</li><li>Goto SUCCESS, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12). (This also covers the case where every field in <code>Desc</code> is absent.)</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Goto REJECT, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. d. Goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. Goto REJECT, If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, and the <code>[[Value]]</code> field of <code>Desc</code> is present, and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Goto REJECT, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li><strong>VALIDATED:</strong> For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li><strong>SUCCESS:</strong> If <code>O</code> is an <code>Array</code> object: a. If <code>P</code> is <code>&quot;length&quot;</code>, and <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. If <code>pendingWriteProtect</code> is <code>true</code>, update the property (<code>&quot;length&quot;</code>) to have <code>[[Writable]] = false</code>. 4. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. b. If <code>P</code> is an array index and <code>index</code> &gt;= <code>oldLen</code>: 1. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds, because we&#39;ve checked in the pre-step that the <code>&quot;length&quot;</code> is writable, and since <code>P</code> is an array index property, the length must still be writable here.</li><li>Return <code>true</code>.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return <code>false</code>.</li><li><strong>REJECTRANGE</strong>: Throw a <code>RangeError</code> exception. Note that this is unconditional (thrown even if <code>Throw</code> is <code>false</code>).</li></ol><h3 id="adding-arguments-object-exotic-behavior-2" tabindex="-1">Adding arguments object exotic behavior <a class="header-anchor" href="#adding-arguments-object-exotic-behavior-2" aria-label="Permalink to &quot;Adding arguments object exotic behavior&quot;">​</a></h3><p>The exotic <code>[[DefineOwnProperty]]</code> behavior for an arguments object containing a <code>[[ParameterMap]]</code> is described in E5 Section 10.6.</p><p>The variant algorithm essentially first runs the default algorithm. If the default algorithm finishes successfully, the variant will then maintain the parameter map and possibly perform a setter call.</p><p>This is easy to incorporate and results in:</p><ol><li>Set <code>pendingWriteProtect</code> to <code>false</code>.</li><li>If <code>O</code> is not an <code>Array</code> object, goto SKIPARRAY.</li><li>Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured.</li><li>Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.)</li><li>If <code>P</code> is <code>&quot;length&quot;</code>, then a. If the <code>[[Value]]</code> field of <code>Desc</code> is absent, then goto SKIPARRAY. b. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. c. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, goto REJECTRANGE. d. Set <code>Desc.[[Value]]</code> to <code>newLen</code>. e. If <code>newLen</code> &gt;= <code>oldLen</code>, then goto SKIPARRAY. f. Goto REJECT if <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. g. If <code>Desc.[[Writable]]</code> has the value <code>false</code>: 1. Need to defer setting the <code>[[Writable]]</code> attribute to <code>false</code> in case any elements cannot be deleted. 2. Set <code>pendingWriteProtect</code> to <code>true</code>. 3. Set <code>Desc.[[Writable]]</code> to <code>true</code>. h. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li>Else if <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>index</code> be <code>ToUint32(P)</code>. b. Goto REJECT if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. c. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li><strong>SKIPARRAY</strong>: Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code>: a. If <code>extensible</code> is <code>false</code>, then goto REJECT. b. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. d. Goto SUCCESS.</li><li>Goto SUCCESS, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12). (This also covers the case where every field in <code>Desc</code> is absent.)</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Goto REJECT, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. d. Goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. Goto REJECT, If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, and the <code>[[Value]]</code> field of <code>Desc</code> is present, and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Goto REJECT, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li><strong>VALIDATED:</strong> For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li><strong>SUCCESS:</strong> If <code>O</code> is an <code>Array</code> object: a. If <code>P</code> is <code>&quot;length&quot;</code>, and <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. If <code>pendingWriteProtect</code> is <code>true</code>, update the property (<code>&quot;length&quot;</code>) to have <code>[[Writable]] = false</code>. 4. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. b. If <code>P</code> is an array index and <code>index</code> &gt;= <code>oldLen</code>: 1. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds, because we&#39;ve checked in the pre-step that the <code>&quot;length&quot;</code> is writable, and since <code>P</code> is an array index property, the length must still be writable here.</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. If <code>IsAccessorDescriptor(Desc)</code> is <code>true</code>, then: a. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code>, and <code>false</code> as the arguments. (This removes the magic binding for <code>P</code>.) 2. Else (<code>Desc</code> may be generic or data descriptor): a. If <code>Desc.[[Value]]</code> is present, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>Desc.[[Value]]</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.) b. If <code>Desc.[[Writable]]</code> is present and its value is <code>false</code>, then: 1. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code> and <code>false</code> as arguments. (This removes the magic binding for <code>P</code>, and must happen after a possible update of the variable value.)</li><li>Return <code>true</code>.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return <code>false</code>.</li><li><strong>REJECTRANGE</strong>: Throw a <code>RangeError</code> exception. Note that this is unconditional (thrown even if <code>Throw</code> is <code>false</code>).</li></ol><h3 id="final-version-2" tabindex="-1">Final version <a class="header-anchor" href="#final-version-2" aria-label="Permalink to &quot;Final version&quot;">​</a></h3><p>(See above, currently no additional cleanup.)</p><h2 id="delete" tabindex="-1">Delete <a class="header-anchor" href="#delete" aria-label="Permalink to &quot;Delete&quot;">​</a></h2><p>Related E5 sections:</p><ul><li>E5 Section 8.12.7: default algorithm</li><li>E5 Section 10.5: arguments object</li></ul><h3 id="default-algorithm-3" tabindex="-1">Default algorithm <a class="header-anchor" href="#default-algorithm-3" aria-label="Permalink to &quot;Default algorithm&quot;">​</a></h3><ol><li>Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, then return <code>true</code>.</li><li>If <code>desc.[[Configurable]]</code> is <code>true</code>, then a. Remove the own property with name <code>P</code> from <code>O</code>. b. Return <code>true</code>.</li><li>Else if <code>Throw</code> is true, then throw a <code>TypeError</code> exception.</li><li>Return <code>false</code>.</li></ol><h3 id="adding-arguments-object-exotic-behavior-3" tabindex="-1">Adding arguments object exotic behavior <a class="header-anchor" href="#adding-arguments-object-exotic-behavior-3" aria-label="Permalink to &quot;Adding arguments object exotic behavior&quot;">​</a></h3><p>The exotic <code>[[Delete]]</code> behavior for an arguments object containing a <code>[[ParameterMap]]</code> is described in E5 Section 10.6.</p><p>The variant algorithm essentially first runs the default algorithm. If the default algorithm finishes successfully, the variant will then possibly delete a magic variable binding.</p><p>This is easy to incorporate and results in:</p><ol><li>Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, then goto SUCCESS.</li><li>If <code>desc.[[Configurable]]</code> is <code>true</code>, then a. Remove the own property with name <code>P</code> from <code>O</code>. b. Goto SUCCESS.</li><li>Else if <code>Throw</code> is true, then throw a <code>TypeError</code> exception.</li><li>Return <code>false</code>.</li><li><strong>SUCCESS:</strong> If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code>, and <code>false</code> as the arguments. (This removes the magic binding for <code>P</code>.)</li><li>Return <code>true</code>.</li></ol><p>Notes:</p><ul><li>In steps 2, if <code>desc</code> is <code>undefined</code>, it seems unnecessary to go to step 6 to check the arguments parameter map. Can a magically bound property exist in the parameter map with the underlying property having been deleted somehow?</li></ul><h3 id="final-version-3" tabindex="-1">Final version <a class="header-anchor" href="#final-version-3" aria-label="Permalink to &quot;Final version&quot;">​</a></h3><p>(See above, currently no additional cleanup.)</p><h2 id="hasinstance" tabindex="-1">HasInstance <a class="header-anchor" href="#hasinstance" aria-label="Permalink to &quot;HasInstance&quot;">​</a></h2><h3 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h3><p>The <code>[[HasInstance]]</code> internal method is referred to in the following parts of the E5 specification:</p><ul><li>Section 8.6.2: <code>[[HasInstance]]</code> is introduced as a <code>SpecOp(any)</code> -&gt; <code>Boolean</code> internal method. Only <code>Function</code> objects have a <code>[[HasInstance]]</code> method.</li><li>Section 11.8.6: the <code>instanceof</code> operator, which is the only &quot;caller&quot; for <code>[[HasInstance]]</code> in the E5 specification.</li><li>Section 13.2: when <code>Function</code> objects are created, <code>[[HasInstance]]</code> is set to the algorithm in Section 15.3.5.3.</li><li>Section 15.3.4.5: when bound functions are created using <code>Function.prototype.bind()</code>, <code>[[HasInstance]]</code> is set to the algorithm in Section 15.3.4.5.3.</li><li>Section 15.3.4.5.3: <code>[[HasInstance]]</code> for bound functions.</li><li>Section 15.3.5.3: <code>[[HasInstance]]</code> for ordinary (non-bound) functions.</li></ul><p>The <code>[[HasInstance]]</code> for ordinary functions is (<code>F</code> is the function object and <code>V</code> is the argument value, &quot;V instanceof F&quot;):</p><ol><li>If <code>Type(V)</code> is not an <code>Object</code>, return <code>false</code>.</li><li>Let <code>O</code> be the result of calling the <code>[[Get]]</code> internal method of <code>F</code> with property name <code>&quot;prototype&quot;</code>. (Note: this is the external prototype, not the internal one.)</li><li>If <code>Type(O)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>Repeat a. Let <code>V</code> be the value of the <code>[[Prototype]]</code> internal property of <code>V</code>. b. If <code>V</code> is <code>null</code>, return <code>false</code>. c. If <code>O</code> and <code>V</code> refer to the same object, return <code>true</code>.</li></ol><p>Notes:</p><ul><li>In step 2, we&#39;re fetching the <em>external prototype</em>, which may have any values. It might also have been changed after the instance was created.</li><li>Step 4.a steps the internal prototype chain once before the first check.</li></ul><p>The <code>[[HasInstance]]</code> for bound functions is:</p><ol><li>Let <code>target</code> be the value of <code>F</code>&#39;s <code>[[TargetFunction]]</code> internal property.</li><li>If <code>target</code> has no <code>[[HasInstance]]</code> internal method, a <code>TypeError</code> exception is thrown.</li><li>Return the result of calling the <code>[[HasInstance]]</code> internal method of <code>target</code> providing <code>V</code> as the argument.</li></ol><p>Notes:</p><ul><li>In step 3, the <code>target</code> may be another bound function, so we may need to follow an arbitrary number of bound functions before ending up with an actual function object.</li></ul><h3 id="combined-algorithm" tabindex="-1">Combined algorithm <a class="header-anchor" href="#combined-algorithm" aria-label="Permalink to &quot;Combined algorithm&quot;">​</a></h3><p>The two <code>[[HasInstance]]</code> methods (for bound and non-bound functions) can be combined to yield:</p><ol><li>While <code>F</code> is a bound function: a. Set <code>F</code> to the value of <code>F</code>&#39;s <code>[[TargetFunction]]</code> internal property. b. If <code>F</code> has no <code>[[HasInstance]]</code> internal method, throw a <code>TypeError</code> exception. (Note: <code>F</code> can be another bound function, so we loop until we find the non-bound actual function.)</li><li>If <code>Type(V)</code> is not an <code>Object</code>, return <code>false</code>.</li><li>Let <code>O</code> be the result of calling the <code>[[Get]]</code> internal method of <code>F</code> with property name <code>&quot;prototype&quot;</code>. (Note: this is the external prototype, not the internal one.)</li><li>If <code>Type(O)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>Repeat a. Let <code>V</code> be the value of the <code>[[Prototype]]</code> internal property of <code>V</code>. b. If <code>V</code> is <code>null</code>, return <code>false</code>. c. If <code>O</code> and <code>V</code> refer to the same object, return <code>true</code>.</li></ol><h3 id="final-version-4" tabindex="-1">Final version <a class="header-anchor" href="#final-version-4" aria-label="Permalink to &quot;Final version&quot;">​</a></h3><p>(See above, currently no additional cleanup.)</p>',122)]))}const p=o(a,[["render",r]]);export{f as __pageData,p as default};
