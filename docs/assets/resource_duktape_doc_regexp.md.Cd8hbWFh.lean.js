import{_ as t,c as o,a2 as a,o as i}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"Regular expressions","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/regexp.md","filePath":"resource/duktape/doc/regexp.md","lastUpdated":1732350347000}'),n={name:"resource/duktape/doc/regexp.md"};function r(c,e,s,d,l,p){return i(),o("div",null,e[0]||(e[0]=[a(`<h1 id="regular-expressions" tabindex="-1">Regular expressions <a class="header-anchor" href="#regular-expressions" aria-label="Permalink to &quot;Regular expressions&quot;">​</a></h1><p>This document describes the Duktape <code>RegExp</code> built-in implementation.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Implementing a regular expression engine into very small space is challenging. See the following three excellent articles by Russ Cox for background:</p><ul><li><a href="http://swtch.com/~rsc/regexp/regexp1.html" target="_blank" rel="noreferrer">http://swtch.com/~rsc/regexp/regexp1.html</a></li><li><a href="http://swtch.com/~rsc/regexp/regexp2.html" target="_blank" rel="noreferrer">http://swtch.com/~rsc/regexp/regexp2.html</a></li><li><a href="http://swtch.com/~rsc/regexp/regexp3.html" target="_blank" rel="noreferrer">http://swtch.com/~rsc/regexp/regexp3.html</a></li></ul><p>ECMAScript regular expression set is described in E5 Section 15.10, and includes:</p><ul><li>Disjunction</li><li>Quantifiers, counted repetition and both greedy and minimal variants</li><li>Assertions, negative and positive lookaheads</li><li>Character classes, normal and inverted</li><li>Captures and backreferences</li><li>Unicode character support</li><li>Unanchored matching (only) (e.g. <code>/x/.exec(&#39;fooxfoo&#39;)</code> matches <code>&#39;x&#39;</code>)</li></ul><p>Counted repetition quantifiers, assertions, captures, and backreferences all complicate a non-backtracking implementation considerably. For this reason, the built-in regular expression implementation, described below, uses a backtracking approach.</p><p>The two basic goals of the built-in implementation are ECMAScript compliance and compactness. More generally, the following prioritized requirements should be fulfilled:</p><ol><li>ECMAScript compatibility</li><li>Compactness</li><li>Avoiding deep or unbounded C recursion, and providing recursion and execution time sanity limits</li><li>Regexp execution performance</li><li>Regexp compilation performance</li></ol><p>Further, it should be possible to leave out regexp support during compilation, or to plug in a more powerful existing regexp engine should it be needed by the user.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h2><p>The basic implementation approach consists of three parts:</p><ol><li>A regexp tokenizer, which reuses the lexer model of the ECMAScript tokenizer and generates a token stream</li><li>A regexp compiler, which takes the token stream and produces compiled regexps (represented as interned strings) and <em>normalized</em> regexp patterns (see E5 Section 15.10.6)</li><li>A regexp executor, which takes a compiled regexp and an input stream and produces match results</li></ol><p>Case insensitive matching provides some surprising challenges in handling character ranges, see discussion of canonicalization below.</p><h3 id="tokenizer" tabindex="-1">Tokenizer <a class="header-anchor" href="#tokenizer" aria-label="Permalink to &quot;Tokenizer&quot;">​</a></h3><p>The tokenizer is implemented in <code>duk_lexer.c</code> and is quite simple and straightforward. It shares the character decoding and character window model of the ECMAScript tokenizer.</p><p>The two main functions are:</p><ul><li><code>duk_lexer.c:duk_lexer_parse_re_token()</code> which parses a regexp token, such as character, quantifier, etc.</li><li><code>duk_lexer.c:duk_lexer_parse_re_ranges()</code> which parses character class ranges (a bit tricky due to canonicalization)</li></ul><p>Quantifiers are fully parsed during tokenization, resulting in only two types of quantifier tokens, greedy and minimal, with each having a minimum count and a maximum count. An unspecified maximum count (infinite) is encoded as the maximum unsigned 32-bit value 0xffffffff, which is quite reasonable considering that ECMAScript strings cannot be longer than that. The quantifier maximum value 0xffffffff is treated specially by the compiler too.</p><p>Character classes could be parsed and encoded into token values. However, this would mean that the token value would need to contain an arbitrary number of character ranges. Also, character range normalization for case insensitive matching requires some special treatment. For these reasons, the lexer simply produces a start token for normal or inverted character class (<code>[</code> or <code>[^</code>) and the lexer and the compiler co-operate to process the character ranges. See, for instance:</p><ul><li><code>duk_regexp_compiler.c:parse_disjunction()</code>, and</li><li><code>duk_lexer.c:duk_lexer_parse_re_ranges()</code>.</li></ul><p>See the detailed discussion on canonicalization and case-insensitive matching below.</p><h3 id="compiler" tabindex="-1">Compiler <a class="header-anchor" href="#compiler" aria-label="Permalink to &quot;Compiler&quot;">​</a></h3><p>The compiler is implemented in <code>duk_regexp_compiler.c</code>. The main functions are:</p><ul><li><code>duk_regexp_compiler.c:duk_regexp_compile()</code> which provides the compilation wrapper (e.g. initializes the compilation context, including lexer state, etc) and also produces the <em>normalized</em> regexp source required by E5 Section 15.10.6.</li><li><code>duk_regexp_compiler.c:parse_disjunction()</code> which parses a disjunction (including atoms, quantifiers, and assertions) and calls itself recursively to implement lookaheads and capture/non-capture groups.</li></ul><p>The code generation model is shaped by the fact that linear bytecode generation is not possible if a regexp is parsed linearly without lookahead. In other words, one needs to choose between non-linear bytecode generation and non-linear parsing. For instance, to compile <code>a|b</code> one would first generate the bytecode for <code>a</code>, and only then notice that the bytecode for <code>a</code> must be preceded by bytecode to handle the disjunction. Further, the disjunction would need to be updated for each new alternative. Similar problems apply to other constructs; consider, for instance, the quantifier in <code>(a|b)+</code>.</p><p>One common approach to deal with this problem is to first produce an intermediate representation (e.g. a parse tree), and then perform compilation using the more convenient intermediate representation. However, an intermediate representation increases code size considerably, so we try to make do without one.</p><p>Instead, the code generation model attempts to work around these limitations as follows:</p><ul><li>The regexp bytecode generation is based on a byte buffer which holds currently generated code. New bytecode instructions are either appended to the buffer, or inserted into some earlier position e.g. to complete jump offsets.</li><li>Bytecode is &quot;PC-relative&quot;. In particular, bytecode jump/branch offsets are PC-relative (relative to the first byte of the subsequent instruction, to be exact) which allows code blocks to be moved and copied freely without breaking them. This works as long as there are no PC-relative jumps over the &quot;spliced&quot; sections. There are a few restrictions, though, discussed below.</li><li>Code generation is bottom-up: a bytecode snippet is emitted for each token, and these snippets are combined (concatenated, copied, etc) to form more complex matchers. More complex expressions can backpatch jump offsets, insert new bytecode into a previous position (bumping any following code forwards), and clone existing bytecode snippets (e.g. for counted quantifiers).</li></ul><p>The current model has a few drawbacks:</p><ul><li>Insertion into the middle of the regexp buffer requires trailing code to be moved (with <code>memmove()</code>). This can lead to quite a lot of copying in pathological cases. However, regular expressions are typically so short that this does not really matter in practice, and keeps the implementation simple.</li><li>Because the compiler works without an intermediate representation for the regexp, some of the back-patching required for code generation is a bit tricky. This is the case especially for creating disjunction code (see the example below).</li><li>Because bytecode is variable size (especially, encoded PC-relative jump offsets are variable size too!), back-patching jump offsets must be done carefully. See comments in code, and discussion on jump offsets below.</li></ul><p>Regular expressions are compiled into interned strings, containing both the regexp flags and the actual regexp body bytecode. This allows compiled regexps to be conveniently stored and handled as an internal property of a <code>RegExp</code> instance. The property is internal because the key for the property uses a non-BMP character, which cannot be generated by standard ECMAScript code, and cannot therefore be accessed by ECMAScript code. See the bytecode format details below.</p><p>Another output of regexp compilation is the <em>normalized</em> regular expression pattern, described in E5 Section 15.10.6, which goes into the <code>source</code> property of a <code>RegExp</code> instance. The normalized pattern is currently formed simply as follows:</p><ul><li>If the input pattern is empty, output <code>(?:)</code>.</li><li>Else, look for any forward slash which is <em>not</em> preceded by a backslash. Replace all such occurrences with <code>\\/</code>.</li></ul><p>A run-time instance of a <code>RegExp</code> is created with only the compiled bytecode (string) and the normalized pattern as inputs.</p><h3 id="executor" tabindex="-1">Executor <a class="header-anchor" href="#executor" aria-label="Permalink to &quot;Executor&quot;">​</a></h3><p>The executor is implemented in <code>duk_regexp_executor.c</code>, see:</p><ul><li><code>duk_regexp_executor.c:duk_regexp_match()</code> which initializes the regexp matcher context and contains most of the logic of E5 Section 15.10.6.2, except for the innermost match attempt (step 9.b).</li><li><code>duk_regexp_executor.c:match_regexp()</code> which does regexp bytecode execution starting from a certain input offset, calling itself recursively when necessary (see &quot;current limitations&quot; below).</li></ul><p>The basic implementation approach is a recursive back-tracking matcher which uses the C stack whenever recursion is needed, but explicitly avoids doing so for <em>simple quantifiers</em>: see separate discussion on quantifiers and backtracking. Without the support for simple quantifiers, <em>every character</em> matching the pattern <code>/.*/</code> would require one C recursion level for back-tracking.</p><p>A regexp matcher context is maintained for matching to minimize C call parameter count. The current state includes <code>PC</code>, the program counter for bytecode, and <code>SP</code>, the string pointer referring to the (immutable) input string. Among other book-keeping members, the context also contains the current <em>saved pointers</em>, which are byte pointers to the (extended UTF-8 encoded) input string.</p><p>Saved pointers are used to implement capture groups. The start and end points of the capture are identified with saved pointers (two pointers are needed per capture group). A capture group is valid if <em>both</em> saved pointers are valid; when in the middle of the capture group, the start pointer is set but the end pointer is not. Since the input string is not modified during matching, even for case-insensitive matching, saved pointers allow capturing without making explicit copies of the captured values during matching.</p><p>Saving a pointer currently involves C recursion: when a pointer is saved, the previous value is stored and the matcher is called recursively. If backtracking needs to happen, the previous value can be restored. Saved pointers are also wiped when a quantifier rematches a quantified containing captures. The previous pointers also need to be saved and restored in this case. (One could also try to erase saved pointers during backtracking based on the saved pointer value: if we backtrack <code>SP</code> beyond the saved pointer, the pointer is erased.)</p><p>The mapping between saved pointers are capture groups is described in the following table:</p><hr><p>Saved index Description</p><hr><p>0 Start of entire matching substring</p><p>1 End of entire matching substring</p><p>2 Start of capture group 1</p><p>3 End of capture group 1</p><p>...</p><p>2n+1 Start of capture group n</p><h2 id="_2n-2-end-of-capture-group-n" tabindex="-1">2n+2 End of capture group n <a class="header-anchor" href="#_2n-2-end-of-capture-group-n" aria-label="Permalink to &quot;2n+2          End of capture group n&quot;">​</a></h2><p>Memory allocation is generally avoided during regexp execution. When it is necessary to allocate temporary buffers, all temporaries are placed in the value stack for correct memory management in case of errors. Currently, memory allocation is needed during regexp execution only to handle lookahead assertions, which need to make a copy of saved pointers.</p><p>About safety: the ECMAScript executor should prevent user from reading and replacing regexp bytecode. Even so, the executor must validate all memory accesses etc. When an invalid access is detected (e.g. a &#39;save&#39; opcode to invalid, unallocated index) it must fail with an internal error but not cause a segmentation fault.</p><h3 id="current-limitations" tabindex="-1">Current limitations <a class="header-anchor" href="#current-limitations" aria-label="Permalink to &quot;Current limitations&quot;">​</a></h3><h4 id="regexp-compiler" tabindex="-1">Regexp compiler <a class="header-anchor" href="#regexp-compiler" aria-label="Permalink to &quot;Regexp compiler&quot;">​</a></h4><p>C recursion depth limit</p><p>: The compiler imposes an artificial limit on C recursion depth (<code>DUK_USE_REGEXP_COMPILER_RECLIMIT</code>). If the recursion limit is reached, regexp compilation fails with an (internal) error.</p><pre><code>The following constructs increase C recursion depth:

-   Negative or positive lookahead
-   Capture or non-capture group
</code></pre><p>Regexp atom copy limit</p><p>: Complex quantifiers with a non-zero minimum or a non-infinite maximum cause the quantified atom to be duplicated in regexp bytecode. There is an artificial limit (<code>DUK_RE_MAX_ATOM_COPIES</code> by default) on the number of copies the compiler is willing to create. Some examples:</p><pre><code>-   For \`/(?:a|b){10,20}/\`, the atom code (\`/(?:a|b)/\`) is first
    copied 10 times to cover the quantifier minimum, and another 10
    times to cover the maximum.
-   For \`/(?:a|b){10,}/\`, the atom code is first copied 10 times to
    cover the quantifier minimum, and the remaining (greedy)
    infinite match reuses the last emitted atom.

Note that there is no such restriction for *simple quantifiers*,
which can keep track of quantifier counts explicitly.
</code></pre><h4 id="regexp-executor" tabindex="-1">Regexp executor <a class="header-anchor" href="#regexp-executor" aria-label="Permalink to &quot;Regexp executor&quot;">​</a></h4><p>C recursion depth limit</p><p>: The executor imposes an artificial limit on C recursion depth (<code>DUK_USE_REGEXP_EXECUTOR_RECLIMIT</code>). If the recursion limit is reached, regexp matching fails with an (internal) error. The following constructs increase C recursion depth:</p><pre><code>-   Simple quantifier increases recursion depth by one when matching
    the sequel (but not for each atom).
-   Complex quantifier increases recursion depth for each atom
    matched and the sequel (e.g. \`/(?:x|x)+/\` causes C recursion for
    each \`x\` character matched).
-   \`DUK_REOP_SAVE\` increases recursion depth by one (to provide
    capture backtracking), so each capture group increases C
    recursion depth by two.
-   Positive and negative lookahead increase recursion depth by one
    for matching the lookahead, and for matching the sequel (to
    provide capture backtracking).
-   Each alternative of a disjunction increases recursion depth by
    one, because disjunctions currently generate a sequence of n-1
    \`DUK_REOP_SPLIT1\` opcodes for an n-alternative disjunction, and
    the preferred execution path runs through each of these
    \`DUK_REOP_SPLIT1\` opcodes on the first attempt.
</code></pre><p>Regexp opcode steps limit</p><p>: The execution imposes an artificial limit on the total number of regexp opcodes executed (<code>DUK_RE_EXECUTE_STEPS_LIMIT</code> by default) to provide a safeguard against insane execution times. The steps limit applies to total steps executed during e.g. <code>exec()</code>. The steps count is <em>not</em> zeroed for each attempt of an unanchored match.</p><pre><code>The steps limit provides a safety net for avoiding excessive or even
infinite execution time. Infinite execution time may currently
happen for some empty quantifiers, so only the steps limit prevents
them from executing indefinitely.
</code></pre><p>Empty quantifier bodies in complex quantifiers</p><p>: Empty quantifier bodies in complex quantifiers may cause unbounded matcher execution time (eventually terminated by the steps limit). There is no &quot;progress&quot; instruction or one-character lookahead to prevent multiple matches of the same empty atom.</p><pre><code>-   Complex quantifier example: \`/(?:|)*x/.exec(&#39;x&#39;)\` is terminated
    by the steps limit. The problem is that the empty group will
    match an infinite number of times, so the greedy quantifier
    never terminates.
-   Simple quantifiers have a workaround if the atom character
    length is zero: \`qmin\` and \`qmax\` are capped to 1. This allows
    the atom to match once and possibly cause whatever side effects
    it may have (for instance, if we allowed captures in simple
    atoms, the capture could happen, once). For instance, \`/(?:)*x/\`
    is, in effect, converted to \`/(?:){0,1}x/\` and \`/(?:){3,4}x/\` to
    \`/(?:){1,1}x/\`.

This problem could also be fixed for complex quantifiers, but the
fix is not as trivial as for simple quantifiers.
</code></pre><h4 id="non-standard-regexp-syntax-in-existing-code" tabindex="-1">Non-standard RegExp syntax in existing code <a class="header-anchor" href="#non-standard-regexp-syntax-in-existing-code" aria-label="Permalink to &quot;Non-standard RegExp syntax in existing code&quot;">​</a></h4><p>Some ECMAScript code bases depend on non-standard RegExp syntax, such as using literal braces without escaping:</p><pre><code>/{(\\d+)}/    non-standard
/\\{(\\d+)\\}/  standard
</code></pre><p>Duktape&#39;s regexp engine supports a few non-standard expressions to reduce issues with existing code. A longer term, more flexible solution is to allow the built-in minimal engine to be replaced with an external engine with wider regexp syntax, better performance, etc.</p><h4 id="miscellaneous" tabindex="-1">Miscellaneous <a class="header-anchor" href="#miscellaneous" aria-label="Permalink to &quot;Miscellaneous&quot;">​</a></h4><p>Incomplete support for characters outside the BMP</p><p>: ECMAScript only mandates support for 16-bit code points, so this is not a compliance issue.</p><pre><code>The current implementation quite naturally processes code points
above the BMP as such. However, there is no way to express such
characters in patterns (there is for instance no Unicode escape for
code points higher than U+FFFF). Also, the built-in ranges \`\\d\`,
\`\\s\`, and \`\\w\` and their inversions only cover 16-bit code points,
so they will not currently work properly.

This limitation has very little practical impact, because a standard
ECMAScript program cannot construct an input string containing any
non-BMP characters.
</code></pre><h2 id="compiled-regexp-and-bytecode-format" tabindex="-1">Compiled regexp and bytecode format <a class="header-anchor" href="#compiled-regexp-and-bytecode-format" aria-label="Permalink to &quot;Compiled regexp and bytecode format&quot;">​</a></h2><p>A regular expression is compiled into an &quot;extended&quot; UTF-8 string which is interned into an <code>duk_hstring</code>. The extended UTF-8 string contains flags, parameters, and code for the regexp body. This simplifies handling of compiled regexps and minimizes memory overhead. The &quot;extended&quot; UTF-8 encoding also keeps the bytecode quite compact while allowing existing helpers to deal with encoding and decoding.</p><p>Logically, a compiled regexp is a sequence of signed and unsigned integers. Unsigned integers are encoded directly with &quot;extended&quot; UTF-8 which allows codepoints of up to 36 bits, although integer values beyond 32 bits are not used for compiled regexps. Signed integers need special treatment because UTF-8 does not allow encoding of negative values. Thus, signed integers are first converted to unsigned by doubling their absolute value and setting the lowest bit if the number is negative; for example, <code>6</code> is converted to <code>2*6=12</code> and <code>-4</code> to <code>2*4+1=9</code>. The unsigned result (again at most 32 bits) is then encoded with &quot;extended&quot; UTF-8. This special treatment allows signed integers to be encoded with UTF-8 in the first place, and further provides short encodings for small signed integers which is useful for encoding bytecode jump distances.</p><p>The compiled regexp begins with a header, containing:</p><ul><li>unsigned integer: flags, any combination of <code>DUK_RE_FLAG_*</code></li><li>unsigned integer: <code>nsaved</code> (number of save slots), which should be <code>2n+2</code> where <code>n</code> equals <code>NCapturingParens</code> (number of capture groups)</li></ul><p>Regexp body bytecode then follows. Each instruction consists of an opcode value (<code>DUK_REOP_*</code>) (encoded as an unsigned integer) followed by a variable number of instruction parameters. Each opcode and parameter is encoded (as described above) as a &quot;code point&quot;. When executing the bytecode, program counter is maintained as a byte offset, not as an instruction index, so all jump offsets are byte offsets (not instruction offsets).</p><p>Jump targets are encoded as &quot;skip offsets&quot; relative to the first byte of the instruction following the jump/branch. Because the skip offset itself has variable length, this needs to be handled carefully during compilation; see discussion below.</p><h3 id="regexp-opcodes" tabindex="-1">Regexp opcodes <a class="header-anchor" href="#regexp-opcodes" aria-label="Permalink to &quot;Regexp opcodes&quot;">​</a></h3><p>The following table summarizes the regexp opcodes and their parameters. The opcode name prefix <code>DUK_REOP_</code> is omitted for brevity; for instance, <code>DUK_REOP_MATCH</code> is listed as <code>MATCH</code>.</p><p>+------------------------+---------------------------------------------+ | Opcode | Description / parameters | +========================+=============================================+ | MATCH | Successful match. | +------------------------+---------------------------------------------+ | CHAR | Match one character. | | | | | | - <code>uint</code>: character codepoint | +------------------------+---------------------------------------------+ | PERIOD | <code>.</code> (period) atom, match next character | | | against anything except a LineTerminator. | +------------------------+---------------------------------------------+ | RANGES | Match the next character against a set of | | | ranges; accept if in some range. | | | | | | - <code>uint</code>: <code>n</code>, number of ranges | | | - <code>2n * uint</code>: ranges, <code>[r1,r2]</code> encoded | | | as two unsigned integers <code>r1</code>, <code>r2</code> | +------------------------+---------------------------------------------+ | INVRANGES | Match the next character against a set of | | | ranges; accept if not in any range. | | | | | | - <code>uint</code>: <code>n</code>, number of ranges | | | - <code>2n * uint</code>: ranges, <code>[r1,r2]</code> encoded | | | as two unsigned integers <code>r1</code>, <code>r2</code> | +------------------------+---------------------------------------------+ | JUMP | Jump to target unconditionally. | | | | | | - <code>int</code>: <code>skip</code>, signed byte offset for | | | jump target, relative to the start of | | | the next instruction | +------------------------+---------------------------------------------+ | SPLIT1 | Split execution. Try direct execution | | | first. If fails, backtrack to jump target. | | | | | | - <code>int</code>: <code>skip</code>, signed byte offset for | | | jump alternative | +------------------------+---------------------------------------------+ | SPLIT2 | Split execution. Try jump target first. If | | | fails, backtrack to direct execution. | | | | | | - <code>int</code>: <code>skip</code>, signed byte offset for | | | jump alternative | +------------------------+---------------------------------------------+ | SQMINIMAL | Simple, minimal quantifier. | | | | | | - <code>uint</code>: <code>qmin</code>, minimum atom match | | | count | | | - <code>uint</code>: <code>qmax</code>, maximum atom match | | | count | | | - <code>skip</code>: signed byte offset for sequel | | | (atom begins directly after instruction | | | and ends in a DUK_REOP_MATCH | | | instruction). | +------------------------+---------------------------------------------+ | SQGREEDY | Simple, greedy (maximal) quantifier. | | | | | | - <code>uint</code>: <code>qmin</code>, minimum atom match | | | count | | | - <code>uint</code>: <code>qmax</code>, maximum atom match | | | count | | | - <code>uint</code>: <code>atomlen</code>, atom length in | | | characters (must be known and fixed for | | | all atom matches; needed for stateless | | | atom backtracking) | | | - <code>skip</code>: signed byte offset for sequel | | | (atom begins directly after instruction | | | and ends in a DUK_REOP_MATCH | | | instruction). | +------------------------+---------------------------------------------+ | SAVE | Save <code>SP</code> (string pointer) to <code>saved[i]</code>. | | | | | | - <code>uint</code>: <code>i</code>, saved array index | +------------------------+---------------------------------------------+ | WIPERANGE | Set saved indices at | | | [start,start+count-1] to NULL, restoring | | | previous values if backtracking. | | | | | | - <code>uint</code>: <code>start</code>, saved array start | | | index | | | - <code>uint</code>: <code>count</code> (&gt; 0) | +------------------------+---------------------------------------------+ | LOOKPOS | Positive lookahead. | | | | | | - <code>int</code>: <code>skip</code>, signed byte offset for | | | sequel (lookahead begins directly after | | | instruction and ends in a | | | DUK_REOP_MATCH) | +------------------------+---------------------------------------------+ | LOOKNEG | Negative lookahead. | | | | | | - <code>int</code>: <code>skip</code>, signed byte offset for | | | sequel (lookahead begins directly after | | | instruction and ends in a | | | DUK_REOP_MATCH) | +------------------------+---------------------------------------------+ | BACKREFERENCE | Match next character(s) against a capture. | | | If the capture is undefined, <em>always | | | matches</em>. | | | | | | - <code>uint</code>: <code>i</code>, backreference number in | | | [1,<code>NCapturingParens</code>], refers to | | | input string between saved indices | | | <code>i*2</code> and <code>i*2+1</code>. | +------------------------+---------------------------------------------+ | ASSERT_START | <code>^</code> assertion. | +------------------------+---------------------------------------------+ | ASSERT_END | <code>$</code> assertion. | +------------------------+---------------------------------------------+ | ASSERT_WORD_BOUNDARY | <code>\\b</code> assertion. | +------------------------+---------------------------------------------+ | AS | <code>\\B</code> assertion. | | SERT_NOT_WORD_BOUNDARY | | +------------------------+---------------------------------------------+</p><h3 id="jumps-offsets-skips-for-jumps-branches" tabindex="-1">Jumps offsets (skips) for jumps/branches <a class="header-anchor" href="#jumps-offsets-skips-for-jumps-branches" aria-label="Permalink to &quot;Jumps offsets (skips) for jumps/branches&quot;">​</a></h3><p>The jump offset of a jump/branch instruction is always encoded as the last parameter of the instruction. The offset is relative to the first byte of the next instruction. This presents some challenges with variable length encoding for negative skip offsets.</p><p>Assume that the compiler is emitting a JUMP over a 10-byte code block:</p><pre><code>JUMP L2
L1:
(10 byte code block)
L2:
</code></pre><p>The compiler emits a <code>DUK_REOP_JUMP</code> opcode. It then needs to emit a skip offset of 10. The offset, 10, does not need to be adjusted because the length of the encoded skip offset does not affect the offset (<code>L2 - L1</code>).</p><p>However, assume that the compiler is emitting a JUMP backwards over a 10-byte code block:</p><pre><code>L1:
  (10 byte code block)
  JUMP L1
L2:
</code></pre><p>The compiler emits a <code>DUK_REOP_JUMP</code> opcode. It then needs to emit the negative offset <code>L1 - L2</code>. To do this, it needs to know the encoded byte length for representing that <em>offset value in bytecode</em>. The offset thus depends on itself, and we need to find the shortest UTF-8 encoding that can encode the skip offset successfully. In this case the correct final skip offset is -12 which contains 1 extra byte for <code>DUK_REOP_JUMP</code> and another extra byte for encoding the -12 skip offset with a one-byte encoding.</p><p>In practice it suffices to first compute the negative offset <code>L1 - L2 - 1</code> (where the -1 is to account for the <code>DUK_REOP_JUMP</code>, which always encodes to one byte) without taking the skip parameter into account, and figure out the length of the UTF-8 encoding of that offset, <code>len1</code>. Then do the same computation for the negative offset <code>L1 - L2 - 1 - len1</code> to get the encoded length <code>len2</code>. The final skip offset is <code>L1 - L2 - 1 - len2</code>. In some cases <code>len1</code> will be one byte shorter than <code>len2</code>, but <code>len2</code> will be correct.</p><p>For instance, if the code block in the second example had been 1022 bytes long:</p><ul><li>The first offset <code>L1 - L2 - 1</code> would be -1023 which is converted to the unsigned value <code>2*1023+1 = 2047 = 0x7ff</code>. This encodes to two UTF-8 bytes, i.e. <code>len1 = 2</code>.</li><li>The second offset <code>L1 - L2 - 1 - 2</code> would be -1025 which is converted to the unsigned value <code>2*1025+1 = 2051 = 0x803</code>. This encodes to <em>three</em> UTF-8 bytes, i.e. <code>len2 = 3</code>.</li><li>The final skip offset <code>L1 - L2 - 1 - 3</code> is -1026, which converts to the unsigned value <code>2*1026+1 = 2053 = 0x805</code>. This again encodes to three UTF-8 bytes, and is thus &quot;self consistent&quot;.</li></ul><p>This could also be solved into closed form directly.</p><h3 id="character-class-escape-handling" tabindex="-1">Character class escape handling <a class="header-anchor" href="#character-class-escape-handling" aria-label="Permalink to &quot;Character class escape handling&quot;">​</a></h3><p>There are no opcodes or special constructions for character class escapes (<code>\\d</code>, <code>\\D</code>, <code>\\s</code>, <code>\\S</code>, <code>\\w</code>, <code>\\W</code>) described in E5 Section 15.10.2.12, regardless of whether they appear inside or outside a character class.</p><p>The semantics are essentially ASCII-based except for the white space character class which contains all characters in the E5 <code>WhiteSpace</code> and <code>LineTerminator</code> productions, resulting in a total of 11 ranges (or individual characters).</p><p>Regardless of where they appear, character class escapes are turned into explicit character range matches during compilation, which also allows them to be embedded in character classes without complications (such as, for instance, splitting the character class into a disjunction). The downside of this is that regular expressions making heavy use of <code>\\s</code> or <code>\\S</code> will result in relatively large regexp bytecode. Another approach would be to reuse some Unicode code points to act as special &#39;marker characters&#39; for the execution engine. Such markers would need to be above U+FFFF because all 16-bit code points must be matchable.</p><p>The (inclusive) ranges for positive character class escapes are:</p><hr><p>Escape Start End</p><hr><p><code>\\d</code> U+0030 U+0039</p><p><code>\\s</code> U+0009 U+000D</p><pre><code>       U+0020   U+0020

       U+00A0   U+00A0

       U+1680   U+1680

       U+180E   U+180E

       U+2000   U+200A

       U+2028   U+2029

       U+202F   U+202F

       U+205F   U+205F

       U+3000   U+3000

       U+FEFF   U+FEFF
</code></pre><p><code>\\w</code> U+0030 U+0039</p><pre><code>       U+0041   U+005A

       U+005F   U+005F

       U+0061   U+007A
</code></pre><hr><p>The ranges for negative character class escapes are:</p><hr><p>Escape Start End</p><hr><p><code>\\D</code> U+0000 U+002F</p><pre><code>       U+003A   U+FFFF
</code></pre><p><code>\\S</code> U+0000 U+0008</p><pre><code>       U+000E   U+001F

       U+0021   U+009F

       U+00A1   U+167F

       U+1681   U+180D

       U+180F   U+1FFF

       U+200B   U+2027

       U+202A   U+202E

       U+2030   U+205E

       U+2060   U+2FFF

       U+3001   U+FEFE

       U+FF00   U+FFFF
</code></pre><p><code>\\W</code> U+0000 U+002F</p><pre><code>       U+003A   U+0040

       U+005B   U+005E

       U+0060   U+0060

       U+007B   U+FFFF
</code></pre><hr><p>The <code>.</code> atom (period) matches everything except a <code>LineTerminator</code> and behaves like a character class. It is interpreted literally inside a character class. There is a separate opcode to match the <code>.</code> atom, <code>DUK_REOP_PERIOD</code> so there is currently no need to emit ranges for the period atom. If it were compiled into a character range, its ranges would be (the negative of <code>.</code> would not be needed):</p><hr><p>Escape Start End</p><hr><p><code>.</code> U+0000 U+0009</p><pre><code>       U+000B   U+000C

       U+000E   U+2027

       U+202A   U+FFFF
</code></pre><hr><p>Each of the above range sets (including for <code>.</code>) are affected by the ignoreCase (<code>/i</code>) option. However, the ranges can be emitted verbatim without canonicalization also when case-insensitive matching is used. This is not a trivial issue, see discussion on canonicalization below.</p><h3 id="misc-notes" tabindex="-1">Misc notes <a class="header-anchor" href="#misc-notes" aria-label="Permalink to &quot;Misc notes&quot;">​</a></h3><p>There is no opcode for a non-capturing group because there is no need for it during execution.</p><p>During regexp execution, regexp flags are kept in the regexp matching context, and affect opcode execution as follows:</p><ul><li>global (<code>/g</code>): does not affect regexp execution, only the behavior of <code>RegExp.prototype.exec()</code> and <code>RegExp.prototype.toString()</code>.</li><li>ignoreCase (<code>/i</code>): affects all opcodes which match characters or character ranges, through the <code>Canonicalize</code> operation defined in E5 Section 15.10.2.8. It also affects <code>RegExp.prototype.toString()</code>.</li><li>multiline (<code>/m</code>): affects the start and end assertion opcodes (<code>^</code> and <code>$</code>). It also affects <code>RegExp.prototype.toString()</code>.</li></ul><p>A bytecode opcode for matching a string instead of an individual character seems useful at first glance. The compiler could join successive characters into a string match (by back-patching the preceding string match instruction, for instance). However, this turns out to be difficult to implement without lookahead. Consider matching <code>/xyz+/</code> for instance. The <code>z</code> is quantified, so the compiler would need to emit a string match for <code>xy</code>, followed by a quantifier with <code>z</code> as its quantified atom. However, when working on the <code>z</code> token, the compiler does not know whether a quantifier will follow but still needs to decide whether or not to merge it into the previous <code>xy</code> matcher. Perhaps the quantifier could pull out the <code>z</code> later on, but this complicates the compiler. Thus there is only a character matching opcode, <code>DUK_REOP_CHAR</code>.</p><h2 id="canonicalization-case-conversion-for-ignorecase-flag" tabindex="-1">Canonicalization (case conversion for ignoreCase flag) <a class="header-anchor" href="#canonicalization-case-conversion-for-ignorecase-flag" aria-label="Permalink to &quot;Canonicalization (case conversion for ignoreCase flag)&quot;">​</a></h2><p>The <code>Canonicalize</code> abstract operator is described in E5 Section 15.10.2.8. It has a pretty straightforward definition matching the behavior of <code>String.prototype.toUpperCase()</code>, except that:</p><ul><li>If case conversion would turn a single codepoint character into a multiple codepoint character, case conversion is skipped</li><li>If case conversion would turn a non-ASCII character (&gt;= U+0080) into an ASCII character (&lt;= U+007F), case conversion is skipped</li></ul><p><code>Canocalize</code> is used for the semantics of:</p><ul><li>The abstract <code>CharacterSetMatcher</code> construct, E5 Section 15.10.2.8</li><li>Atom <code>PatternCharacter</code> handling, E5 Section 15.10.2.8 (through <code>CharacterSetMatcher</code>)</li><li>Atom <code>.</code> (period) handling, E5 Section 15.10.2.8 (through <code>CharacterSetMatcher</code>)</li><li>Atom <code>CharacterClass</code> handling, E5 Section 15.10.2.8 (through <code>CharacterSetMatcher</code>)</li><li>Atom escape <code>DecimalEscape</code> handling, E5 Section 15.10.2.9 (through <code>CharacterSetMatcher</code>)</li><li>Atom escape <code>CharacterEscape</code> handling, E5 Section 15.10.2.9 (through <code>CharacterSetMatcher</code>)</li><li>Atom escape <code>CharacterClassEscape</code> handling, E5 Section 15.10.2.9 (through <code>CharacterSetMatcher</code>)</li><li>Atom escape (backreference) handling, E5 Section 15.10.2.9</li></ul><p>The <code>CharacterSetMatcher</code> basically compares a character against all characters in the set, and produces a match if the input character and the target character match after canonicalization. Matching character ranges naively by canonicalizing the character range start and end point and then comparing the canonicalized input character against the range <strong>is incorrect</strong>, because a continuous range may turn into multiple ranges after canonicalization.</p><p>Example: the class <code>[x-{]</code> is a continuous range U+0078-U+007B (<code>x</code>, <code>y</code>, <code>z</code>, <code>{</code>), but converts into two ranges after canonicalization: U+0058-005A, U+007B (<code>X</code>, <code>Y</code>, <code>Z</code>, <code>{</code>). See test case <code>test-regexp-canonicalization-js</code>.</p><p>The current solution has a small footprint but is expensive during compilation: if ignoreCase (<code>/i</code>) option is given, the compiler preprocesses all character ranges by running through all characters in the character range, normalizing the character, and emitting output ranges based on the normalization results. Continuous ranges are kept continuous, and multiple ranges are emitted if necessary.</p><p>This process is relatively simple but has a high compile time impact (but only if ignoreCase option is specified). Also note that the process may result in overlapping character ranges (for instance, <code>[a-zA-Z]</code> results in <code>[A-ZA-Z]</code>). However, overlapping ranges are not eliminated during compilation of case sensitive regular expressions either, which wastes some bytecode space and execution time, but cause no other complications.</p><p>Note that the resulting ranges (after canonicalization) may include or omit all such characters whose canonicalized (uppercased) counterparts are included in some character range of the class. For instance, the normalization of <code>[a-z]</code> is <code>[A-Z]</code> but <code>[A-Zj]</code> would also work, although it would be sub-optimal. The reason is that a <code>j</code> will never be compared during execution, because the input character is normalized before range comparison (into <code>J</code>) and will thus match the canonicalized counterpart (here contained in the range <code>[A-Z]</code>). The canonicalization process could thus, for instance, simply add additional ranges but keep the original ones too, although this particular approach would serve little purpose.</p><p>However, this fact becomes relevant when built-in character ranges provided by <code>.</code>, <code>\\s</code>, <code>\\S</code>, <code>\\d</code>, <code>\\D</code>, <code>\\w</code>, and <code>\\W</code> are considered. In principle, the ranges they represent should be canonicalized when ignoreCase has been specified. However, these ranges have the following property: if a lowercase character <code>x</code> is contained in the range, its uppercase (canonicalized) counterpart is also contained in the range (see test case <code>test-misc-regexp-character-range-property.js</code> for a verification). This property is apparent for all the ranges except for <code>\\w</code> and <code>\\W</code>: for these ranges to have the property, the refusal of <code>Canonicalize</code> to canonicalize a non-ASCII character to an ASCII character is crucial (for instance, U+0131 would map to U+0049 which would cause problems for <code>\\W</code>). Because of this property, the regexp compiler can use the built-in character ranges without any normalization processing, even when ignoreCase option has been specified: the normalized characters are already present.</p><p>Alternative solutions to the canonicalization problem include:</p><ul><li>Perform a more intelligent range conversion at compile time or at regexp execution time. Difficult to implement compactly.</li><li>Preprocess all 65536 possible <em>input characters</em> during compile time, and match them against the character class ranges, generating optimal result ranges (with overlaps eliminated). The downside include that this cannot be done before all the ranges are known, and that the comparison of one character against an (input) range is still complicated, and possibly requires another character loop which would result in up to 2^32 comparisons (too high).</li></ul><h2 id="compilation-strategies" tabindex="-1">Compilation strategies <a class="header-anchor" href="#compilation-strategies" aria-label="Permalink to &quot;Compilation strategies&quot;">​</a></h2><p>The examples below use opcode names without the <code>DUK_REOP_</code> prefix, and use symbolic labels for clarity.</p><h3 id="pc-relative-code-blocks-jump-patching" tabindex="-1">PC-relative code blocks, jump patching <a class="header-anchor" href="#pc-relative-code-blocks-jump-patching" aria-label="Permalink to &quot;PC-relative code blocks, jump patching&quot;">​</a></h3><p>Because addressing of jumps and branches is PC-relative, already compiled code blocks can be copied and removed without an effect on their validity. Inserting code before and after code blocks is not a problem as such.</p><p>However, there are two things to watch out for:</p><ol><li>Inserting or removing bytecode into an offset which is between a jump / branch and its target. This breaks the jump offset. The compiler has no support for &#39;fixing&#39; already generated jumps (except pending jumps and branches which are treated specially), so this must be avoided in general.</li><li>Inserting or removing bytecode at an offset which affects a previously stored book-keeping offset (e.g. for a pending jump). This is not necessarily a problem as long as the offset is fixed, or the order of patching is chosen so that offsets do not break. See the current compilation strategy for an example of this.</li></ol><h3 id="disjunction-compilation-alternatives" tabindex="-1">Disjunction compilation alternatives <a class="header-anchor" href="#disjunction-compilation-alternatives" aria-label="Permalink to &quot;Disjunction compilation alternatives&quot;">​</a></h3><p>Basic two alternative disjunction:</p><pre><code>/a|b/

      split L1
      (a)
      jump L2
  L1: (b)
  L2:
</code></pre><p>Assume this code is directly embedded in a three alternative disjunction (original two alternative code marked with # characters):</p><pre><code>/a|b|c/  ==  /(?:a|b)|c/

      split L3
#     split L1
#     (a)
#     jump L2
# L1: (b)
# L2:
      jump L4
  L3: (c)
  L4: 
</code></pre><p>The &quot;jump L2&quot; instruction will jump directly to the &quot;jump L4&quot; instruction. So, &quot;jump L2&quot; could be updated to &quot;jump L4&quot; which would not reduce bytecode size, but would eliminate one extra jump during regexp execution:</p><pre><code>/a|b|c/

      split L3
#     split L1
#     (a)
#     jump L4     &lt;-- jump updated from L2 to L4
# L1: (b)
      jump L4     &lt;-- L2 label eliminated above this instruction
  L3: (c)
  L4: 
</code></pre><p>Because the compile-time overhead of manipulating code generated for sub-expressions is quite high, currently the compiler will generate unoptimal jumps to disjunctions.</p><h3 id="current-disjunction-compilation-model" tabindex="-1">Current disjunction compilation model <a class="header-anchor" href="#current-disjunction-compilation-model" aria-label="Permalink to &quot;Current disjunction compilation model&quot;">​</a></h3><p>The current disjunction compilation model avoids modifying already generated code (which is tricky with variable length bytecode) when possible. However, this is not entirely possible for disjunctions compiled into a sequence of SPLIT1 opcodes as illustrated above. The compiler needs to track and back-patch one pending JUMP (for a previous match) and a SPLIT1 (for a previous alternative). This is illustrated with an example below, for <code>/a|b|c/</code>.</p><p>The bytecode form we create, at the end, for <code>a|b|c</code> is:</p><pre><code>split1    L2
split1    L1
(a)
jump      M1
L1:  (b)
M1:  jump      M2
L2:  (c)
M2:
</code></pre><p>This is built as follows. After parsing <code>a</code>, a <code>|</code> is encountered and the situation is, simply:</p><pre><code>(a)
</code></pre><p>There is no pending jump/split1 to patch in this case. What we do in that case is:</p><pre><code>split1    (empty)    &lt;-- leave unpatched_disjunction_split
(a)
jump      (empty)    &lt;-- leave unpatched_disjunction_jump
(new atom begins here)
</code></pre><p>When <code>a|b</code> has been parsed, a <code>|</code> is encountered and the situation is:</p><pre><code>split1    (empty)    &lt;-- unpatched_disjunction_split for &#39;a&#39;
(a)
jump      (empty)    &lt;-- unpatched_disjunction_jump for &#39;a&#39;
(b)
</code></pre><p>We first patch the pending jump to get:</p><pre><code>split1    (empty)    &lt;-- unpatched_disjunction_split for &#39;a&#39;
(a)
jump      M1
(b)
M1:
</code></pre><p>The pending split1 can also now be patched because the jump has its final length now:</p><pre><code>split1    L1
(a)
jump      M1
L1:  (b)
M1:
</code></pre><p>We then insert a new pending jump:</p><pre><code>split1    L1
(a)
jump      M1
L1:  (b)
M1:  jump      (empty)    &lt;-- unpatched_disjunction_jump for &#39;b&#39;
</code></pre><p>... and a new pending split1:</p><pre><code>split1    (empty)    &lt;-- unpatched_disjunction_split for &#39;b&#39;
split1    L1
(a)
jump      M1
L1:  (b)
M1:  jump      (empty)    &lt;-- unpatched_disjunction_jump for &#39;b&#39;
</code></pre><p>After finishing the parsing of <code>c</code>, the disjunction is over and the end of the <code>parse_disjunction()</code> function patches the final pending jump/split1 similarly to what is done after <code>b</code>. We get:</p><pre><code>split1    L2
split1    L1
(a)
jump      M1
L1:  (b)
M1:  jump      M2
L2:  (c)
M2:
</code></pre><p>... which is the target bytecode.</p><h2 id="regexp-feature-implications" tabindex="-1">Regexp feature implications <a class="header-anchor" href="#regexp-feature-implications" aria-label="Permalink to &quot;Regexp feature implications&quot;">​</a></h2><h3 id="quantifiers-with-a-range" tabindex="-1">Quantifiers with a range <a class="header-anchor" href="#quantifiers-with-a-range" aria-label="Permalink to &quot;Quantifiers with a range&quot;">​</a></h3><p>Quantifiers with a minimum-maximum range (other than the simple <code>*</code> and <code>+</code> quantifiers) cannot be implemented conveniently with a basic NFA-based design because the NFA does not have state for keeping a count of how many times each instance of a certain quantifier has been repeated. This is not trivial to fix, because a certain quantifier may be simultaneously active multiple times with each quantifier instance having a separate, backtracked counter.</p><p>Ranged quantifiers are not easy for backtracking matchers either. Consider, for instance, the regexp <code>/(?:x{3,4}){5}/</code>. The matcher needs to track five separate <code>/x{3,4}/</code> quantifiers, each of which backtracks. Even a recursive backtracking implementation cannot easily handle such quantifiers without resorting to some form of long jumps or continuation passing style. This is not apparent for simple non-hierarchical quantifier expressions.</p><p>There are multiple ways to implement ranged quantifiers. One can implement the recursive backtracking engine to incorporate them into the backtracking logic. This seems to require a control structure that cannot consist of simple recursion; rather, some form of long jumps or continuation passing style seems to be required. Another approach is to expand such quantifiers during compile time into an explicit sequence. For instance, <code>/x{3,5}/</code> would become, in effect, <code>/xxx(?:x?x)?/</code>. Capture groups in the expansions need to map to the same capture group number (this cannot be expressed in a normal regular expression, but is easy with regexp bytecode which has a <code>save i</code> instruction). This approach becomes a bit wieldy for large numbers, e.g. for <code>/x{500,10000}/</code>, though.</p><p>The current implementation uses the &quot;bytecode expansion&quot; approach to keep the regular expression matching engine as simple as possible. Because bytecode uses relative offsets, and <code>DUK_REOP_SAVE</code> has a fixed index, the bytecode for an &quot;atom&quot; may be copied without complications.</p><h3 id="quantifiers-and-backtracking-simple-quantifiers" tabindex="-1">Quantifiers and backtracking, simple quantifiers <a class="header-anchor" href="#quantifiers-and-backtracking-simple-quantifiers" aria-label="Permalink to &quot;Quantifiers and backtracking, simple quantifiers&quot;">​</a></h3><p>Quantifiers (especially greedy) are problematic for a backtracking implementation. A simple implementation of a backtracking greedy quantifier (or a minimal one, for that matter) will require one level of C recursion for each atom match. This is especially problematic for expressions like:</p><pre><code>.+
</code></pre><p>The recursion is essentially unavoidable for the general case in a backtracking implementation. Consider, for instance:</p><pre><code>(?:x{4,5}){7,8}
</code></pre><p>Here, each &#39;instance&#39; of the inner quantifier will individually attempt to match either 4 or 5 <code>x</code> characters. This cannot be easily implemented without unbounded recursion in a backtracking matcher.</p><p>However, for many simple cases unbounded recursion <em>can</em> be avoided. In this document, the term <strong>simple quantifier</strong> is used to refer to any quantifier (greedy or minimal), whose atom fulfills the following property:</p><ol><li>The quantifier atom has no alternatives in need of backtracking: it either matches once or not at all</li><li>The input portion matching the atom always has the same character length (though not necessarily the same <em>byte</em> length)</li><li>The quantifier atom has no captures or lookaheads</li></ol><p>The first property eliminates the need to backtrack any matched atoms. For instance, a minimal <code>+</code> quantifier can match the atom once, attempt to match the sequel. If the sequel match fails, it does not need to consider an alternative match for the first atom match (there can be none). Instead, it can simply proceed to match the atom once more, try the sequel again, and so on. Note that although there are no alternatives for each atom matched, the input portion matching the atom may be different for each atom match. For instance, in <code>.+</code> the <code>.</code> can match a different character each time. The important thing is that there are no alternative matches for a &#39;&#39;particular&#39;&#39; match, like there are in <code>(?:a|b)+</code>.</p><p>The second property is needed for greedy matching, where the quantifier can first match the atom as many times as possible, and then try the sequel. To &#39;undo&#39; one atom match, we can simply rewind the input string by the number of characters matched by the atom (which we know to be a constant), and then try the sequel again. For instance, the atom length for <code>.+</code> is 1, and for <code>(?:.x[a-f])+</code> it is 3. Because the particular characters matching a certain atom instance may vary, we don&#39;t know the byte length of the match in advance. To avoid remembering backtrack positions (input offsets after each atom match) we rewind the input by &quot;atom length&quot; UTF-8-encoded code points. This keeps a simple, greedy quantifier stateless and avoids recursion.</p><p>The third property is needed because backtracking the <code>saved</code> array needs C recursion right now. The condition might be avoidable quite easily for a minimal quantifier, and with some effort also for a greedy quantifier (by rematching the atom to refresh any captures). However, these haven&#39;t been considered now. The requirement to have no lookaheads has a similar motivation: lookaheads currently require recursion for <code>saved</code> array management.</p><p>Simple quantifiers are expressed with <code>DUK_REOP_SQMINIMAL</code> and <code>DUK_REOP_SQGREEDY</code>. The atom being matched <em>must</em> fulfill the conditions described above; the compiler needs to track the simple-ness of an atom for various nested atom expressions such as <code>(?:a(?:.))[a-fA-F]</code>. In theory, the following can also be expressed as a simple quantifier: <code>(?:x{3})+</code>, which expands to <code>(?:xxx)+</code>, a simple quantifier with an atom length of 3. The compiler is not this clever, though, at least not at the time of writing.</p><p>Any quantifiers not matching the simple quantifier properties are complex quantifiers, and are encoded as explicit bytecode sequences using e.g. <code>DUK_REOP_SPLIT1</code>, <code>DUK_REOP_SPLIT2</code>, and <code>DUK_REOP_JUMP</code>. Counted quantifiers are expanded by the compiler into straight bytecode. For instance, <code>(?:a|b){3,5}</code> is expanded into (something like) <code>(?:a|b)(?:a|b)(?:a|b)(?:(?:a|b)(?:a|b)?)?</code>. Capture groups inside the atom being matched are encoded into two <code>DUK_REOP_SAVE</code> instructions. The <em>same</em> save indices are used in the atom being expanded, so later atom matches overwrite saved indices of earlier matches (which is correct behavior). Such expressions cannot be expressed as ordinary regexps because the same capture group index cannot be used twice.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="compiler-and-lexer" tabindex="-1">Compiler and lexer <a class="header-anchor" href="#compiler-and-lexer" aria-label="Permalink to &quot;Compiler and lexer&quot;">​</a></h3><ul><li>E5 Section 15.10.2.5, step 4 of RepeatMatcher: is it possible that <code>cap[k]</code> is defined for some <code>k</code>, where <code>k &gt; parenCount + parenIndex</code>? If so, add an example. This means that we can&#39;t just clear all captures for <code>k &gt; parenIndex</code>.</li><li>Handling empty infinite quantifiers, as in: <code>/(x*)*/</code>.</li><li>The regexp lexer is quite simple and could perhaps be integrated into the regexp compiler - at some loss of clarity but at some gain in code compactness.</li><li>Add an opcode for disjunction specifically? Could this avoid the amount of recursion (linear to the number of alternatives) currently required by disjunctions?</li></ul><h3 id="executor-1" tabindex="-1">Executor <a class="header-anchor" href="#executor-1" aria-label="Permalink to &quot;Executor&quot;">​</a></h3><ul><li>Optimized primitive for testing a regexp (match without captures) would be easy by just skipping &#39;save&#39; instructions but would waste space.</li></ul>`,214)]))}const m=t(n,[["render",r]]);export{u as __pageData,m as default};
