import{_ as t,c as a,a2 as o,o as n}from"./chunks/framework.DPuwY6B9.js";const p=JSON.parse('{"title":"実行","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/execution.md","filePath":"resource/duktape/doc/execution.md","lastUpdated":null}'),i={name:"resource/duktape/doc/execution.md"};function r(c,e,s,l,d,u){return n(),a("div",null,e[0]||(e[0]=[o(`<h1 id="実行" tabindex="-1">実行 <a class="header-anchor" href="#実行" aria-label="Permalink to &quot;実行&quot;">​</a></h1><h2 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h2><p>このドキュメントでは、Duktapeがどのように実行状態を管理するかを説明します。いくつかの詳細は省略されていますが、その目的は、実行がどのように進められ、どのような状態が関与し、どのような重要な内部機能が関与しているのか、全体像を示すことです。</p><p>各Duktapeヒープは他のDuktapeヒープから独立しているため、議論は1つのDuktapeヒープに限定されます。いつでも、特定のDuktapeヒープに積極的に呼び出すことができるのは、1つのネイティブ・スレッドだけです。</p><h2 id="execution-states-and-state-overview" tabindex="-1">Execution states and state overview <a class="header-anchor" href="#execution-states-and-state-overview" aria-label="Permalink to &quot;Execution states and state overview&quot;">​</a></h2><p>There are three conceptual execution states for a Duktape heap:</p><ul><li>Idle</li><li>Executing a Duktape/C function</li><li>Executing an ECMAScript function</li></ul><p>This conceptual model ignores details like heap initialization and transitions from one state to another by &quot;call handling&quot;.</p><p>Execution state is contained mostly in two stacks:</p><ul><li>Call stack: used to track function calls; call stack consists of <code>duk_activation</code> entries, with each activation tracking its own catchers (<code>duk_catcher</code>).</li><li>Value stack: contains the tagged values manipulated through the Duktape API and in the bytecode executor.</li></ul><p>In addition to these there are execution control variables in <code>duk_hthread</code> and <code>duk_heap</code>.</p><h2 id="typical-control-flow" tabindex="-1">Typical control flow <a class="header-anchor" href="#typical-control-flow" aria-label="Permalink to &quot;Typical control flow&quot;">​</a></h2><p>Execution always begins from an idle state where no calls into Duktape are active and user application has control. User code may manipulate the value stacks of Duktape contexts in this state without making any calls. User code may also call <code>duk_debugger_cooperate()</code> for integrating debugger into the application event loop (or equivalent).</p><p>Eventually user code makes a call into either a Duktape/C function or an ECMAScript function. Such a call may be caused by an obvious API call like <code>duk_pcall()</code>. It may also be caused by a less obvious API call such as <code>duk_get_prop()</code>, which may invoke a getter, or <code>duk_to_string()</code> which may invoke a <code>toString()</code> coercion method.</p><p>The initial call into Duktape is ultimately handled either by <code>duk_handle_safe_call()</code>, which provides a setjmp/longjmp catchpoint, or <code>duk_handle_call_unprotected()</code> which handles an actual function call. Best practice is to use a protected call as the initial call into Duktape, but sometimes fatal errors caused by uncaught errors can be acceptable and an unprotected call may be done directly.</p><p>Safe calls involve a setjmp catch point which is jumped to using <code>longjmp()</code> if an error occurs inside the safe call. The longjmp() will be caught by the current (innermost) setjmp catchpoint. The catch point is responsible for unwinding call stack state so that when the safe call returns, the call stack and value stack are in their expected configuration.</p><p>Setting up a call involves a lot of small state changes:</p><ul><li>An activation record, <code>duk_activation</code>, is allocated and set up for the new call.</li><li>The value stack is resized if necessary, and a fresh value stack frame is established for the call. The calling value stack frame and the target frame overlap for the call arguments, so that arguments on top of the calling stack are directly visible on the bottom of the target stack.</li><li>An arguments object and an explicit environment record is created if necessary.</li><li>Other small book-keeping (such as recursion depth tracking) is done.</li></ul><p>When a call returns, the state changes are reversed before returning to the caller.</p><p>If the target function is a Duktape/C function, the corresponding C function is looked up and called. The C function now has access to a fresh value stack frame it can operate on using the Duktape API. It can make further calls which get handled by <code>duk_handle_call_unprotected()</code>.</p><p>If the target function is an ECMAScript function, the value stack is resized for the function register count (nregs) established by the compiler during function compilation; unlike Duktape/C functions the value stack is mostly static for the duration of bytecode execution. Opcode handling may push temporaries on the value stack but they must always be popped off before proceeding to dispatch the next opcode.</p><p>The bytecode executor has its own setjmp catchpoint. If bytecode makes a call into a Duktape/C function it is handled normally using <code>duk_handle_call_unprotected()</code>; such calls may happen also when the bytecode executor uses the value stack API for various coercions etc.</p><p>If bytecode makes a function call into an ECMAScript function it is flagged and handled specially by <code>duk_handle_call_unprotected()</code>. Instead of doing a recursive call into the bytecode executor it returns to the bytecode executor which restarts execution and starts executing the call target without increasing C stack depth. The call handler also supports tail calls where an activation record is reused.</p><p>Both Duktape and user code may use <code>duk_safe_call()</code> to make protected calls inside the current activation (or outside of any activations in the idle state). A safe call creates a new setjmp catchpoint but not a new activation, so safe calls are not actual function calls.</p><h2 id="threading-limitations" tabindex="-1">Threading limitations <a class="header-anchor" href="#threading-limitations" aria-label="Permalink to &quot;Threading limitations&quot;">​</a></h2><p>Only one native thread may call into a Duktape heap at any given time. See <code>threading.rst</code> for more details.</p><h2 id="bytecode-executor" tabindex="-1">Bytecode executor <a class="header-anchor" href="#bytecode-executor" aria-label="Permalink to &quot;Bytecode executor&quot;">​</a></h2><h3 id="basic-functionality" tabindex="-1">Basic functionality <a class="header-anchor" href="#basic-functionality" aria-label="Permalink to &quot;Basic functionality&quot;">​</a></h3><ul><li>Setjmp catchpoint which supports yield, resume, slow returns, try-catch, etc</li><li>Opcode dispatch loop, central for performance</li><li>Executor interrupt which facilitates script timeout and debugger integration</li><li>Debugger support; breakpoint handling, checked and normal execution modes</li></ul><h3 id="setjmp-catchpoint" tabindex="-1">Setjmp catchpoint <a class="header-anchor" href="#setjmp-catchpoint" aria-label="Permalink to &quot;Setjmp catchpoint&quot;">​</a></h3><p>The <code>duk_safe_call()</code> catchpoints are only used to handle ordinary error throws which propagate out of the calling function. The bytecode executor setjmp catchpoint handles a wider variety of longjmp call types, and in many cases the longjmp may be handled without exiting the current function:</p><ul><li>A slow break/continue uses a longjmp() so that if the break/continue crosses any finally clauses, they get executed as expected. Similarly &#39;with&#39; statement lexical environments are torn down, etc.</li><li>A slow return uses a longjmp() so that any finally clauses, &#39;with&#39; statement lexical environments, etc are handled appropriately.</li><li>A coroutine resume is handled using longjmp(): the Duktape.Thread.resume() call adjusts the thread states (including their activations) and then uses this longjmp() type to restart execution in the target coroutine.</li><li>A coroutine yield is handled using longjmp(): the Duktape.Thread.yield() call adjusts the states and uses this longjmp() type to restart execution in the target coroutine.</li><li>An ordinary throw is handled as in <code>duk_safe_call()</code> with the difference that there are both &#39;try&#39; and &#39;finally&#39; sites.</li></ul><p>Returns, coroutine yields, and throws may propagate out of the initial bytecode executor entry and outwards to whatever code called into the executor.</p><h3 id="opcode-dispatch-loop-and-executor-interrupt" tabindex="-1">Opcode dispatch loop and executor interrupt <a class="header-anchor" href="#opcode-dispatch-loop-and-executor-interrupt" aria-label="Permalink to &quot;Opcode dispatch loop and executor interrupt&quot;">​</a></h3><p>The opcode dispatch loop is a central performance critical part of the executor. The dispatch loop:</p><ul><li>Checks for an executor interrupt. An interrupt can be taken for every opcode or for every N instructions; the interrupt handler provides e.g. script timeout and debugger integration. This is performance critical because the check occurs for every opcode dispatch. See separate section below on interrupt counter handling.</li><li>Fetches an instruction from the topmost activation&#39;s &quot;current PC&quot;, and increments the PC. Managing the &quot;current PC&quot; is performance critical. See separate section below on current PC handling.</li><li>Decodes and executes the opcode using a large switch-case. The most important opcodes are in the main opcode space (64 opcodes); more rarely used opcodes are &quot;extra&quot; opcodes and need a double dispatch.</li><li>Usually loops back to execute further opcodes. May also (1) call another Duktape/C or ECMAScript function, (2) cause a longjmp, or (3) use <code>goto restart_execution</code> to restart the executor e.g. after call stack has been changed.</li></ul><h3 id="debugger-support" tabindex="-1">Debugger support <a class="header-anchor" href="#debugger-support" aria-label="Permalink to &quot;Debugger support&quot;">​</a></h3><p>Debugger support relies on:</p><ul><li>Executor interrupt mechanism is needed to support debugging.</li><li>A precheck in <code>restart_execution</code> where debugging status and breakpoints are checked. Executor then either proceeds in &quot;normal&quot; or &quot;checked&quot; execution. Checked execution means running one opcode at a time, and calling into the interrupt handler before each to see e.g. if a breakpoint has been triggered.</li><li>There&#39;s some additional support outside the executor, e.g. call stack unwinding code handles the &quot;step out&quot; logic.</li></ul><p>See <code>debugger.rst</code> for details.</p><h2 id="call-processing-duk-handle-call-unprotected" tabindex="-1">Call processing: duk_handle_call_unprotected() <a class="header-anchor" href="#call-processing-duk-handle-call-unprotected" aria-label="Permalink to &quot;Call processing: duk_handle_call_unprotected()&quot;">​</a></h2><h3 id="call-setup" tabindex="-1">Call setup <a class="header-anchor" href="#call-setup" aria-label="Permalink to &quot;Call setup&quot;">​</a></h3><p>When handling a call, <code>duk_handle_call_unprotected()</code> is given <code>idx_func</code> which contains the target function, followed by the &quot;this&quot; binding and the call arguments. The stack frame of the calling activation looks as follows:</p><pre><code>idx_func
     |
     |          idx_func + 2
     |               |
     v               v
+-----+------+--------+------+-----+------+
| ... | func | &#39;this&#39; | arg1 | ... | argN | &lt;- top
+-----+------+--------+------+-----+------+
</code></pre><p>To prepare the stack frame for the called function, <code>duk_handle_call_unprotected()</code> does the following:</p><ul><li>The final target function, &quot;this&quot; binding, and arguments are resolved by repeatedly checking the following: <ul><li>If <code>func</code> is a bound function, update the &quot;this&quot; binding and prepend arguments at the <code>arg1</code> point.</li><li>If <code>func</code> is a <code>Function.prototype.{call.apply}</code> or <code>Reflect.apply</code>, the call/apply processing is handled inline, replacing &#39;func&#39;, the &quot;this&quot; binding, and arguments.</li><li>If <code>func</code> is <code>Reflect.construct</code> the constructor call processing is handled inline. A function call that began as a non-constructor call is converted into a constructor call on the fly.</li></ul></li><li>Coerces the <code>this</code> binding as specified in E5. The <code>this</code> in the calling stack frame is the caller requested <code>this</code> binding. For instance, for a property-based call (e.g. <code>obj.method()</code>) this is the base object. The effective <code>this</code> binding may be coerced (for non-strict target functions) or replaced during bound function handling.</li><li>Resolves the difference between arguments requested (target function <code>nargs</code>) and provided by filling in missing arguments with <code>undefined</code> or discarding extra arguments so that exactly <code>nargs</code> arguments are present. (Special handling is needed for vararg functions where <code>nargs</code> indicates <code>num_stack_args</code> arguments are used as is.)</li><li>Finalizes the value stack &quot;top&quot;: <ul><li>For Duktape/C target functions the top is set to <code>nargs</code> (or <code>num_stack_args</code> for vararg functions).</li><li>For ECMAScript target functions the top is first set to <code>nargs</code>, wiping any values above that, and then extended to <code>nregs</code>. Values above <code>nargs</code> are filled with <code>undefined</code>. At the end the value stack frame has <code>nregs</code> allocated and initialized entries, with <code>[0, nargs-1]</code> mapping to call arguments.</li></ul></li><li>Creates a new lexical scope object if necessary; this step is postponed when possible and done lazily only when actually necessary. Also an <code>arguments</code> object is created only if necessary.</li><li>Creates a new activation, and switches the valstack bottom to the first argument.</li></ul><p>The value stack looks as follows after call setup is complete and the new function is ready to execute (the example is for an ECMAScript target function):</p><pre><code>(-1)     0      1          nargs-1                   nregs - 1
+--------+------+------+-----+------+-----------+-----+-----------+
| &#39;this&#39; | arg1 | arg2 | ... | argM | undefined | ... | undefined | &lt;- top
+--------+------+------+-----+------+-----------+-----+-----------+
</code></pre><p>The effective <code>this</code> binding for the function is always stashed right below the active value stack frame. This interacts well with the calling convention where the requested <code>this</code> binding can be coerced in-place nicely, and the <code>this</code> binding can also be accessed quickly.</p><p>When doing tail calls, no stacks (value stack, call stack, catch stack) may grow in size; otherwise the point of cail talls would be defeated. This is ensured as follows:</p><ul><li>The value stack is manipulated so that the callee&#39;s first argument (<code>arg1</code>) will be placed in the current activation&#39;s index 0 (value stack bottom). The effective <code>this</code> binding is overwritten just below the current activation&#39;s value stack bottom.</li><li>The call stack does not grow by virtue of reusing the current activation.</li><li>The compiler never emits a tailcall if there are any catch stack entries that might capture a <code>return</code> or an error throw. <code>duk_handle_call_unprotected()</code> simply asserts for this condition.</li></ul><h3 id="call-cleanup-after-a-successful-call" tabindex="-1">Call cleanup after a successful call <a class="header-anchor" href="#call-cleanup-after-a-successful-call" aria-label="Permalink to &quot;Call cleanup after a successful call&quot;">​</a></h3><p>The C return value of the called Duktape/C function indicates how many return values are on the value stack, with negative values indicating an error which is thrown by call handling (this is a shorthand for throwing errors).</p><p>To clean up after a call:</p><ul><li>The call stack and catch stack are unwound, and a best effort shrink check is done. If shrinking is attempted and it fails, the error is ignored.</li><li>The value stack is restored to the caller&#39;s configuration. The return value is moved into its expected position (same as <code>func</code> on the input stack). Value stack top is configured so that the return value is at the stack top (for Duktape/C callers) or so that the stack top is at <code>nregs</code> (for ECMAScript callers). A value stack shrink (or grow) check is done; shrink errors should be ignored silently.</li><li>For constructor calls the return value needs special post-processing: if the return value is an object, it is returned as is; otherwise the default instance (&quot;this&quot; binding) replaces the return value.</li><li>Other book-keeping variables are restored to their entry values, e.g.: call recursion depth, bytecode executor instruction pointer, thread state, current thread, etc.</li></ul><h3 id="call-cleanup-after-a-failed-call" tabindex="-1">Call cleanup after a failed call <a class="header-anchor" href="#call-cleanup-after-a-failed-call" aria-label="Permalink to &quot;Call cleanup after a failed call&quot;">​</a></h3><p>When an error is thrown it is caught by the nearest <code>setjmp</code> catch point. The error processing is quite similar to success handling except that multiple call stack and catch stack frames are potentially unwound:</p><ul><li>Restore the previous <code>setjmp</code> catchpoint so that any errors thrown during call cleanup are propagated outwards to avoid recursion into the same handler. Note, however, that the error handling code path should never actually throw further errors -- doing so would break protected call semantics.</li><li>The call stack and catch stack are unwound, and a best effort shrink check is done.</li><li>The value stack is configured as for successful calls, except that the error thrown is left on the value stack instead of a return value.</li><li>Other book-keeping variables are restored to their entry values.</li></ul><p>If there&#39;s no catcher for the error the uncaught error causes the fatal error handler to be called. None of the stacks are unwound, and since the entry values for various book-keeping variables are lost, there&#39;s no way to properly unwind the call state afterwards. This is OK because fatal errors are not recoverable and there&#39;s no way to resume execution if a fatal error occurs. It should be possible to free the Duktape heap normally but this is of little use because it&#39;s not safe to continue execution after a fatal error in general.</p><h3 id="managing-heap-curr-thread" tabindex="-1">Managing heap-&gt;curr_thread <a class="header-anchor" href="#managing-heap-curr-thread" aria-label="Permalink to &quot;Managing heap-\\&gt;curr_thread&quot;">​</a></h3><p>The current thread is managed in several places:</p><ul><li>Call handling saves and restores <code>heap-&gt;curr_thread</code> whose previous value may be different from the call thread when an initial call is made, i.e. previous value is <code>NULL</code>.</li><li>Bytecode executor longjmp handler ultimately handles each coroutine resume and yield operation. The longjmp handler will update <code>heap-&gt;curr_thread</code> as a resume enters a thread and when a yield exits a thread.</li><li>As a result, the setjmp catch point of ordinary call handling doesn&#39;t need to unwind multiple levels of resumers: it just needs to restore the previous value in case it was <code>NULL</code>.</li></ul><h3 id="current-limitations-in-call-cleanup" tabindex="-1">Current limitations in call cleanup <a class="header-anchor" href="#current-limitations-in-call-cleanup" aria-label="Permalink to &quot;Current limitations in call cleanup&quot;">​</a></h3><p>As of Duktape 1.4.0 the error handling path is not completely free of errors in out-of-memory situations:</p><ul><li>Unwinding activations causes lexical scope objects to be allocated which may fail and propagate an error from error handling. This needs to be fixed e.g. so that the scope object is preallocated, see: <a href="https://github.com/svaarala/duktape/issues/476" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/476</a>.</li></ul><h3 id="misc-notes" tabindex="-1">Misc notes <a class="header-anchor" href="#misc-notes" aria-label="Permalink to &quot;Misc notes&quot;">​</a></h3><ul><li>The value stack doesn&#39;t hold all the internal state relevant for an activation. Some state, such as active environment records (<code>lex_env</code> and <code>var_env</code>) are held in the <code>duk_activation</code> activation structure.</li></ul><h2 id="value-stack-management" tabindex="-1">Value stack management <a class="header-anchor" href="#value-stack-management" aria-label="Permalink to &quot;Value stack management&quot;">​</a></h2><h3 id="one-value-stack-per-thread" tabindex="-1">One value stack per thread <a class="header-anchor" href="#one-value-stack-per-thread" aria-label="Permalink to &quot;One value stack per thread&quot;">​</a></h3><p>A thread has a single value stack, essentially an array of tagged values, which is shared by the activations in the call stack. Each activation has a set of registers indexed relative to &quot;frame bottom&quot;, starting from zero, mapped to the range [regbase, regtop[ in the value stack. The register ranges of activations may and often do overlap (see call handling discussion). For instance, function call arguments prepared by the caller are used directly by the callee.</p><p>The value stack can be thought of as follows:</p><pre><code>size -&gt;    _
          : :    [0,size[    allocated range
          : :    [top,size[  allocated, initialized to undefined, ignored by GC
          : :    [0,top[     active range, must be initialized for GC
top -&gt;    :_:
          ! ! -.
          ! !  !-- current activation
          ! !  !
bottom -&gt; !_! -&#39;
          ! !
          ! !
          ! !
          ! !
0 -&gt;      !_!
</code></pre><p>There are several possible policies for values above &quot;top&quot;. The current policy is based on concrete performance measurements, and is as follows:</p><ul><li>Values above &quot;top&quot; are not considered reachable to GC.</li><li>Values above &quot;top&quot; are initialized to &quot;undefined&quot; (DUK_TAG_UNDEFINED). Whenever the &quot;top&quot; is decreased, previous values are set to undefined.</li></ul><h3 id="overlap-between-activations" tabindex="-1">Overlap between activations <a class="header-anchor" href="#overlap-between-activations" aria-label="Permalink to &quot;Overlap between activations&quot;">​</a></h3><p>Example of value stack overlap for two ECMAScript activations during a function call:</p><pre><code>size -&gt;    _
          : :    [0,size[    allocated range
          : :    [top,size[  allocated, initialized to undefined, ignored by GC
          : :    [0,top[     active range, must be initialized for GC
top -&gt;    :_:
          !=! -.
          !=!  !
          !=!  !-- activation 2
          !#!  !  -.
bottom -&gt; !#! -&#39;   !-- activation 1
          !:!      !
          !:!     -&#39;
          ! !
0 -&gt;      !_!
</code></pre><p>The callee&#39;s activation (activation 2 in the figure) may also be smaller than the caller&#39;s activation:</p><pre><code>size -&gt;    _
          : :    [0,size[    allocated range
          : :    [top,size[  allocated, initialized to undefined, ignored by GC
          : :    [0,top[     active range, must be initialized for GC
          : :
          : :
          ::: -.
          :::  !-- activation 1
top -&gt;    :::  !
          !#!  !  -.
          !#!  !   !-- activation 2
bottom -&gt; !#!  !  -&#39;
          !:!  !
          !:! -&#39;
          ! !
0 -&gt;      !_!
</code></pre><p>When the callee returns, call handling will restore the value stack frame to the size expected by the caller. Values above the entries used for call handling will be reinitialized to <code>undefined</code>.</p><p>Call handling will also ensure that the reserved size for the value stack never decreases as a result of the call, even if the caller has a much smaller value stack frame. This is important for the value stack size guarantees provided by e.g. <code>duk_require_stack()</code>.</p><p>Note that there is nothing in the value stack model or the execution model in general which requires activations to share registers for parameter passing. It is just a convenient thing to do especially for ECMAScript-to-ECMAScript calls: it minimizes value stack growth, minimizes unnecessary copying of arguments (which is pointless because the caller will never rely on the argument values after a call anyway).</p><p>When an ECMAScript function with a very large value stack frame calls a function with a very small value stack frame, a lot of value stack resize / wipe mechanics will happen. It might be useful to avoid the register overlap in such cases to improve performance.</p><h3 id="growing-and-shrinking" tabindex="-1">Growing and shrinking <a class="header-anchor" href="#growing-and-shrinking" aria-label="Permalink to &quot;Growing and shrinking&quot;">​</a></h3><p>See <code>doc/value-stack-resizing.rst</code> for more details.</p><p>The value stack allocation size grows and shrinks as required by the active range, which changes e.g. during function calls. Some hysteresis is applied to minimize memory allocation activity when the value stack changes active size. Note that when the value stack grows or shrinks, it is reallocated and its base pointer may change, which invalidates any outstanding pointers to values in the stack. For this reason, all persistent execution state refers to registers and value stack entries by index, not by memory pointer.</p><p>Whenever there is a risk of a garbage collector run (either directly or indirectly through an error, a finalizer run, etc) all the entries in the [0,top[ range of the value stack must be initialized and correctly reference counted: all active ranges of reachable threads are considered GC roots. The compiler and the executor should wipe any unused value stack entries as soon as the values are no longer needed: otherwise the values will be reachable for the GC and will prevent garbage collection. This is easy to do e.g. when a function call returns (just wipe the entire range of registers used by the function) but is more difficult for a function which runs forever.</p><p>When ECMAScript functions are compiled, the compiler keeps track of how many registers are needed by the opcodes comprising the compiled bytecode, and this value is stored in the <code>nregs</code> entry of a compiled function. While the ECMAScript function is executing, we know that <em>all</em> register accesses will be to valid and initialized parts of the value stack, so no grow/shrink or other sanity checks are necessary while the function is executing. This does not mean that all the <code>nregs</code> will always be used, and any unused registers at the top of the activation record&#39;s register range can be reused during e.g. function calls.</p><p>The value stack is handled quite differently for C functions, which use a traditional stack model (this is similar to how Lua manages its value stack). Value stack grow/shrink checks are needed whenever pushing and popping values, and the number of value stack entries needed is not known beforehand. Arguments to C functions are placed on top of the initial C activation record (starting from register 0). A possible return value is left by the C code at the top of the stack, not necessarily at position 0. The return value of the C function indicates whether a return value is intended or not; if not, the return value defaults to <code>undefined</code>.</p><h2 id="managing-executor-interrupt" tabindex="-1">Managing executor interrupt <a class="header-anchor" href="#managing-executor-interrupt" aria-label="Permalink to &quot;Managing executor interrupt&quot;">​</a></h2><p>The executor interrupt counter is currently tracked in <code>thr-&gt;interrupt_counter</code>. This seems to work well because <code>thr</code> is a &quot;hot&quot; variable.</p><p>Another alternative would be to track the counter in an executor local variable. Error handling and other code paths jumping out of the executor need to work similarly to how stack local <code>curr_pc</code> is handled.</p><h2 id="managing-current-pc" tabindex="-1">Managing current PC <a class="header-anchor" href="#managing-current-pc" aria-label="Permalink to &quot;Managing current PC&quot;">​</a></h2><h3 id="current-approach" tabindex="-1">Current approach <a class="header-anchor" href="#current-approach" aria-label="Permalink to &quot;Current approach&quot;">​</a></h3><p>The current solution in Duktape 1.3 is to maintain a direct bytecode pointer in each activation, and to keep a &quot;cached copy&quot; of the topmost activation&#39;s bytecode pointer in a bytecode executor local variable <code>curr_pc</code>. A pointer to the <code>curr_pc</code> in the stack frame (whose type is <code>duk_instr_t **</code>) is stored in <code>thr-&gt;ptr_curr_pc</code> so that when control exits the opcode dispatch loop (e.g. when an error is thrown) the value in the stack frame can be read and synced back into the topmost activation&#39;s <code>act-&gt;curr_pc</code>.</p><p>Consistency depends on the compiler doing correct aliasing analysis, and writing back the <code>curr_pc</code> value to the stack frame before any operation that may potentially read it through <code>thr-&gt;ptr_curr_pc</code>. Using <code>volatile</code> would be safer but in practical testing it eliminates the performance benefit entirely.</p><p>For the most part the bytecode executor can keep on dispatching opcodes using <code>curr_pc</code> without copying the pointer back to the topmost activation. Careful management of <code>curr_pc</code> and <code>thr-&gt;ptr_curr_pc</code> are needed in the following situations:</p><ul><li><p>Call handling must (1) store/restore the current <code>thr-&gt;ptr_curr_pc</code> value,</p><p>(2) sync the <code>curr_pc</code> if <code>thr-&gt;ptr_curr_pc</code> is non-NULL, (3) set the <code>thr-&gt;ptr_curr_pc</code> to NULL to avoid any code using it with an incorrect activation (not matching what <code>curr_pc</code> was initialized from). This ensures that any side effects in the executor, such as DECREF causing a finalizer call or a property read causing a getter call, are handled correctly without the executor syncing the <code>curr_pc</code> at every turn. This is quite important because there are a lot of potential side effects in the executor opcode loop.</p></li><li><p>If any code depends on <code>duk_activation</code> structs (<code>act-&gt;curr_pc</code> in particular) being correct, <code>curr_pc</code> must be synced back. For example: executor interrupt, debugger handling, and error augmentation need to see synced state.</p></li><li><p>The <code>curr_pc</code> must be synced back <strong>and</strong> <code>thr-&gt;ptr_curr_pc</code> must be NULLed before a longjmp that (potentially) causes a call stack unwind. The NULLing is important because <strong>any</strong> call stack unwind may have side effects due to e.g. finalizers for values in the unwound call stack being called. If <code>thr-&gt;ptr_curr_pc</code> was still set at that time, call handling would sync <code>curr_pc</code> to the topmost activation, which wouldn&#39;t be the same activation as intended.</p></li><li><p>NULLing of <code>thr-&gt;ptr_curr_pc</code> is also required for longjmps which are purely internal to the bytecode executor. This is important because the seemingly internal longjmps may propagate outwards, may cause side effects, etc, all of which demand that <code>thr-&gt;ptr_curr_pc</code> be NULL at the time. Once the longjmp has been handled, the executor should reinitialize <code>thr-&gt;ptr_curr_pc</code> if bytecode execution resumes.</p></li><li><p>Whenever the bytecode executor does a <code>goto restart_execution;</code> the <code>curr_pc</code> must be synced back even if the activation hasn&#39;t changed: the restart code will look up the topmost activation&#39;s <code>act-&gt;curr_pc</code> which must be up to date.</p></li></ul><p>Syncing the pointer back unnecessarily or multiple times is safe in general, so there&#39;s no need to ensure there&#39;s exactly one sync for a certain code path.</p><p>Function bytecode is behind a stable pointer, so there are no realloc or other side effect concerns with using direct bytecode pointers. Because the function being executed is always reachable, a borrowed pointer can be used.</p><p>This approach is error prone, but it is worth the performance difference of the alternatives. This method of dispatch improves dispatch performance by about 20-25% over Duktape 1.2.</p><h3 id="some-alternatives" tabindex="-1">Some alternatives <a class="header-anchor" href="#some-alternatives" aria-label="Permalink to &quot;Some alternatives&quot;">​</a></h3><ul><li>Duktape 1.3: maintain a direct bytecode pointer in each activation, and a &quot;cached&quot; copy of the topmost activation&#39;s bytecode pointer in a local variable of the executor. Whenever something that might throw an error is executed, write the pointer back to the current activation using <code>thr-&gt;ptr_curr_pc</code> which points to the stack frame location containing <code>curr_pc</code>.</li><li>Duktape 1.2: maintain all PC values as numeric indices (not pointers and not pre-multiplied by bytecode opcode size). The current PC is always looked up from the current activation.</li><li>Same as Duktape 1.3 behavior but maintain a cached copy of the topmost activation&#39;s bytecode pointer in <code>thr-&gt;curr_pc</code>. The copy back operation is needed but doesn&#39;t need to peek into the bytecode executor stack frame. This works quite well because <code>thr</code> is a &quot;hot&quot; variable. However, the stack local <code>curr_pc</code> used in Duktape 1.3 is faster.</li><li>Use direct bytecode pointers in activations, keep a pointer to the current activation in the executor, and use <code>act-&gt;curr_pc</code> for dispatch. There&#39;s no need for a copy back operation because activation states are always in sync. This is faster than the Duktape 1.2 approach, but significantly slower than the <code>thr-&gt;curr_pc</code> or the Duktape 1.3 approach (part of that is probably because there&#39;s more register pressure).</li></ul><h3 id="comparison-between-curr-pc-alternatives" tabindex="-1">Comparison between curr_pc alternatives <a class="header-anchor" href="#comparison-between-curr-pc-alternatives" aria-label="Permalink to &quot;Comparison between curr_pc alternatives&quot;">​</a></h3><p>The current Duktape 1.3 approach is a bit error prone because of the need to sync the executor local <code>curr_pc</code> back to <code>act-&gt;curr_pc</code> in multiple code paths. Another alternative would be to dispatch using <code>act-&gt;curr_pc</code> directly. While that is faster than Duktape 1.2, it is significantly slower than dispatching using executor local <code>curr_pc</code> (or <code>thr-&gt;curr_pc</code>).</p><p>The measurements below are using <code>gcc -O2</code> on x64:</p><pre><code># Duktape 1.3, dispatch using executor local variable curr_pc
$ sudo nice -20 python util/time_multi.py --count 10 --mode all --verbose ./duk.O2.local_pc tests/perf/test-empty-loop.js
Running: 2.180000 2.170000 2.180000 2.290000 2.180000 2.200000 2.190000 2.190000 2.220000 2.200000
min=2.17, max=2.29, avg=2.20, count=10: [2.18, 2.17, 2.18, 2.29, 2.18, 2.2, 2.19, 2.19, 2.22, 2.2]

# Duktape 1.2, dispatch using a numeric PC index
$ sudo nice -20 python util/time_multi.py --count 10 --mode all --verbose ./duk.O2.123 tests/perf/test-empty-loop.js
Running: 3.100000 3.100000 3.120000 3.120000 3.160000 3.300000 3.370000 3.410000 3.370000 3.390000
min=3.10, max=3.41, avg=3.24, count=10: [3.1, 3.1, 3.12, 3.12, 3.16, 3.3, 3.37, 3.41, 3.37, 3.39]

# Alternative; dispatch using thr-&gt;curr_pc
$ sudo nice -20 python util/time_multi.py --count 10 --mode all --verbose ./duk.O2.thr_pc tests/perf/test-empty-loop.js
Running: 2.310000 2.330000 2.310000 2.300000 2.400000 2.290000 2.310000 2.290000 2.300000 2.300000
min=2.29, max=2.40, avg=2.31, count=10: [2.31, 2.33, 2.31, 2.3, 2.4, 2.29, 2.31, 2.29, 2.3, 2.3]

# Alternative; dispatch using act-&gt;curr_pc
$ sudo nice -20 python util/time_multi.py --count 10 --mode all --verbose ./duk.O2.act_pc tests/perf/test-empty-loop.js
Running: 2.590000 2.580000 2.600000 2.600000 2.600000 2.660000 2.600000 2.640000 2.860000 2.860000
min=2.58, max=2.86, avg=2.66, count=10: [2.59, 2.58, 2.6, 2.6, 2.6, 2.66, 2.6, 2.64, 2.86, 2.86]
</code></pre><h2 id="accessing-constants" tabindex="-1">Accessing constants <a class="header-anchor" href="#accessing-constants" aria-label="Permalink to &quot;Accessing constants&quot;">​</a></h2><p>The executor stores a copy of the <code>duk_hcompfunc</code> constant table base address into a local variable <code>consts</code>. This reduces code footprint and performs better compared to reading the consts base address on-the-fly through the function reference. Because the constants table has a stable base address, this is easy and safe.</p><h2 id="accessing-registers" tabindex="-1">Accessing registers <a class="header-anchor" href="#accessing-registers" aria-label="Permalink to &quot;Accessing registers&quot;">​</a></h2><p>The executor currently accesses the stack frame base address (needed to read registers) through <code>thr</code> as <code>thr-&gt;valstack_bottom</code>. This is reasonably OK because <code>thr</code> is a &quot;hot&quot; variable.</p><p>The register base address could also be copied to a local variable as is done for constants. However, <code>thr-&gt;valstack_bottom</code> is not a stable address and may be changed by any side effect (because any side effect can cause a value stack resize, e.g. if a finalizer is invoked).</p><p>If a local variable were to be used, it would need to be updated when the value stack is resized. It&#39;s not certain if overall performance would be improved. This was postponed to Duktape 1.4:</p><ul><li><a href="https://github.com/svaarala/duktape/issues/298" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/298</a></li></ul>`,114)]))}const g=t(i,[["render",r]]);export{p as __pageData,g as default};
