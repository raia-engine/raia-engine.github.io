import{_ as t,c as a,a2 as s,o as l}from"./chunks/framework.DPuwY6B9.js";const p=JSON.parse('{"title":"Value stack resizing","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/value-stack-resizing.md","filePath":"resource/duktape/doc/value-stack-resizing.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/value-stack-resizing.md"};function o(r,e,n,c,u,h){return l(),a("div",null,e[0]||(e[0]=[s(`<h1 id="value-stack-resizing" tabindex="-1">Value stack resizing <a class="header-anchor" href="#value-stack-resizing" aria-label="Permalink to &quot;Value stack resizing&quot;">​</a></h1><p>Growing and shrinking the value stack is important for both performance and memory usage. This document describes the mechanism in Duktape 2.2.</p><h2 id="value-stack-concepts" tabindex="-1">Value stack concepts <a class="header-anchor" href="#value-stack-concepts" aria-label="Permalink to &quot;Value stack concepts&quot;">​</a></h2><p>The value stack is a single <code>duk_tval</code> array which is used by all calls in the call stack of a certain Duktape thread. The value stack has:</p><ul><li>An allocated size. This is the actual memory allocation.</li><li>A reserved size. This is the value stack size that application or Duktape code has reserved. The value stack cannot be shrunk below this size even in an emergency GC because calling code is expecting the reserved size to be guaranteed in all situations. <ul><li>The current thread-level reserved size is the maximum reserved size for all activations in the call stack. Call handling deals with updating the thread level reserve as calls are wound and unwound.</li><li>The reserve can only grow when calling functions because it would otherwise be unsafe to unwind protected calls as the unwind might run out memory. That&#39;s a problem because either the unwind path would throw, or fail to respect the value stack guarantees for the reserve. Both are sandboxing issues. This strict policy technically only needs to be applied to protected calls, but it is applied to all calls at present.</li><li>The current reserve is also valid and tracked when the call stack is empty. The reserve is then valid for the C code operating on the empty call stack.</li></ul></li><li>Current &quot;top&quot; of the value stack. Value stack entries above top are not currently in use, and are always set to ECMAScript <code>undefined</code> as part of the value stack initialization policy. <ul><li>Calling code is allowed to push values at the &quot;top&quot; index up to the current reserve.</li><li>It&#39;s not allowed to push values beyond the reserve, even if there is space between the reserve and the current allocation. By default such pushes will throw; with <code>DUK_USE_VALSTACK_UNSAFE</code> (Lua-like behavior) such pushes will cause undefined behavior.</li></ul></li><li>Current &quot;bottom&quot; of the value stack. This provides the basis for API call index resolution: index 0 is at the bottom. <ul><li>When a call is in progress, &quot;bottom&quot; matches the functions&#39; conceptual value stack frame.</li><li>When no call is in progress, &quot;bottom&quot; is zero.</li></ul></li></ul><p>Whenever side effects or value stack operations are possible, these values must fulfill:</p><pre><code>0 &lt;= bottom &lt;= top &lt;= reserve &lt;= allocated
</code></pre>`,7)]))}const v=t(i,[["render",o]]);export{p as __pageData,v as default};
