import{_ as o,c as t,a2 as n,o as i}from"./chunks/framework.DPuwY6B9.js";const p=JSON.parse('{"title":"Identifier algorithms","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/identifier-handling.md","filePath":"resource/duktape/doc/identifier-handling.md","lastUpdated":null}'),a={name:"resource/duktape/doc/identifier-handling.md"};function r(c,e,d,l,s,u){return i(),t("div",null,e[0]||(e[0]=[n(`<h1 id="identifier-algorithms" tabindex="-1">Identifier algorithms <a class="header-anchor" href="#identifier-algorithms" aria-label="Permalink to &quot;Identifier algorithms&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>This document discusses the internal representation of lexical environments and the exposed algorithms for identifier handling, taking into account the internal representation.</p><p>The goal of the compiler is to convert almost all identifier related accesses to register accesses and to avoid the explicit creation of environment record objects whenever possible. For full compliance, a &quot;slow path&quot; is needed, and is provided by the environment record objects and the identifier algorithms described here. The slow path is optimized for a compact code footprint, not speed.</p><p>Identifier handling encompasses a large part of the E5 specification and the implementation:</p><ul><li>Variable and function declarations in global code, eval code, and function code (compile time)</li><li>Function argument list declarations (compile time)</li><li>Establishing execution contexts (calls to global code, eval code, and function code; run time)</li><li>Establishing other lexical environments (<code>catch</code> blocks, <code>with</code> blocks; run time)</li><li>Reading identifier values and <code>typeof</code> (run time)</li><li>Assigning values to identifiers (run time)</li><li>Deleting identifier bindings using <code>delete</code> (run time)</li><li>Special argument name bindings for the <code>arguments</code> object (run time)</li></ul><p>These have many complications from an implementation point of view:</p><ul><li>Many things are processed during compile time (and are, in fact, required to be processed compile time)</li><li>Identifiers may be bound to compiled function registers (preferred) or to explicit environment record objects (fallback)</li><li>Register-bound identifiers need to be moved to an explicit environment record object if they may be referred to later (closure)</li><li>Establishing execution contexts is rather tricky and varies between call types</li></ul><h2 id="specification-notes" tabindex="-1">Specification notes <a class="header-anchor" href="#specification-notes" aria-label="Permalink to &quot;Specification notes&quot;">​</a></h2><h3 id="key-parts" tabindex="-1">Key parts <a class="header-anchor" href="#key-parts" aria-label="Permalink to &quot;Key parts&quot;">​</a></h3><p>Key parts of ECMAScript E5 discussion identifier handling include Section 10 (Executable Code and Execution Contexts):</p><ul><li>Sections 10.2.2.1 and 10.3.1 cover identifier lookup (<code>GetIdentifierReference</code>)</li><li>Sections 10.4 and 10.5 cover execution context initialization for global code, eval code, and function calls</li><li>Section 10.6 covers the <code>arguments</code> object initialization (for function calls)</li></ul><p>Other relevant sections include:</p><ul><li>Section 11.4.1: the <code>delete</code> operator, which is used for variable deletion (and property deletion)</li><li>Section 11.4.3: the <code>typeof</code> operator</li><li>Section 12.10: the <code>with</code> statement</li><li>Section 12.14: the <code>try</code> statement, special handling of <code>catch</code></li><li>Section 13: function declarations and function expressions</li><li>Section 15.1.2.1: <code>eval (x)</code>, defines the concept of a <em>direct call to eval</em></li></ul><h3 id="key-concepts" tabindex="-1">Key concepts <a class="header-anchor" href="#key-concepts" aria-label="Permalink to &quot;Key concepts&quot;">​</a></h3><p>Lexical environment</p><p>: Consists of an <em>environment record</em> and a reference to an <em>outer lexical environment</em>.</p><pre><code>The current implementation makes no distinction between a lexical
environment and the environment record contained in it: they are
represented by the same object. Hence, the term \\&quot;environment
record\\&quot; is used loosely below to refer to the lexical environment
and/or its environment record.

The *outer lexical environment* is also referred to as the
environment record\\&#39;s *parent* below.
</code></pre><p>Environment record</p><p>: An environment record is either a <em>declarative environment record</em> or an <em>object environment record</em>.</p><pre><code>Declarative environment records hold variable bindings in an
internal map not accessible from user code.

Object environment records hold variable bindings in an ECMAScript
object. They are used for handling global program execution for
\`with\` statements.
</code></pre><p>Execution context</p><p>: Consists of (note the confusing names and terminology here):</p><pre><code>1.  \`LexicalEnvironment\`, a lexical environment (an environment
    record) for processing variable lookups,
2.  \`VariableEnvironment\`, a lexical environment (an environment
    record) for processing variable and function declarations, and
3.  a \`this\` binding

The two lexical environments are usually the same, except for:

-   \`with\`, which establishes an object environment record for
    variable lookups, but keeps the previous one for declarations
-   \`catch\`, which establishes a single-variable declarative
    environment record for the variable containing the error

Note the confusing terminology, especially the use of \\&quot;lexical
environment\\&quot; as a general term and \`LexicalEnvironment\` as a
component of an execution context. Below, we refer to these loosely
as \\&quot;lexical environment\\&quot; (for \`LexicalEnvironment\`) and \\&quot;variable
environment\\&quot; (for \`VariableEnvironment\`).
</code></pre><p>Immutable binding</p><p>: A binding whose value cannot be changed after initialization. An immutable binding cannot be deleted.</p><p>Mutable binding</p><p>: A binding whose value can be changed. A mutable binding may be deletable or non-deletable.</p><p>Implicit <code>this</code> value</p><p>: A binding may be associated with an implicit <code>this</code> value. If the value is not provided, <code>undefined</code> is used in its place.</p><pre><code>Declarative environment records never provide an implicit
\`this value\`. Object environment records for which the \`provideThis\`
internal flag is set provide an implicit \`this\` value.
</code></pre><h3 id="unsorted-notes" tabindex="-1">Unsorted notes <a class="header-anchor" href="#unsorted-notes" aria-label="Permalink to &quot;Unsorted notes&quot;">​</a></h3><p>Almost all bindings in the E5 specification are non-deletable mutable bindings, except:[^1]</p><ul><li><em>declaration in eval</em>: function and variable declarations in eval code are deletable mutable bindings</li><li><em>&quot;arguments&quot; binding</em>: the <code>arguments</code> binding for strict mode function is an immutable binding</li><li><em>function name in a function expression</em>: in a function expression <code>function f(args) { body }</code>, the identifier <code>f</code> is an immutable binding for the function body; this is not true of function declarations</li></ul><p>There are no practical cases where an immutable binding would be accessed in an uninitialized state:[^2]</p><ul><li>Immutable bindings are created with <code>CreateImmutableBinding</code> and initialized with <code>InitializeImmutableBinding</code></li><li>For <code>arguments</code>, creation and initialization are consecutive, there is little chance of failure (except &quot;out of memory&quot; like conditions); even in failure cases, the intermediate uninitialized binding is not accessible to program code</li><li>For function name in a function expression, creation and initialization are not consecutive but the same applies as for <code>arguments</code>: an uninitialized binding is never exposed to program code (the function expression is not &quot;returned&quot; until its initialization is complete)</li><li>As a result, the implementation does not need to handle lookups for uninitialized immutable bindings, implied for declarative environment records in E5 Section 10.2.1.1.4, step 3</li></ul><p>Implicit <code>this</code> value is relevant only for:[^3]</p><ul><li>Object environment records initialized in a <code>with</code> statement.</li><li>Function call using an identifier reference: a possible implicit <code>this</code> value is used for the <code>this</code> binding (similarly to how a function call using a property reference binds <code>this</code> to the property base object).</li></ul><p>New declarative environment records are created for:[^4]</p><ul><li>Entering strict eval code (with a direct eval call)</li><li>Entering function code</li><li>Entering <code>catch</code> clause</li><li>Evaluating a named function expression</li></ul><p>New object environment records are created for:[^5]</p><ul><li>Entering <code>with</code> statement body</li><li>Implicitly for the global object environment record</li></ul><h3 id="establishing-an-execution-context-calling" tabindex="-1">Establishing an execution context (= calling) <a class="header-anchor" href="#establishing-an-execution-context-calling" aria-label="Permalink to &quot;Establishing an execution context (= calling)&quot;">​</a></h3><p>Different cases for calling:</p><p>+-------------+-----------+-----------+------------+---------------+ | Call type | Lexical | Variable | This | Notes | | | en | en | binding | | | | vironment | vironment | | | +=============+===========+===========+============+===============+ | Executing | Global | Global | Global | | | strict | en | en | object | | | global code | vironment | vironment | | | | | (object | (object | | | | | env | env | | | | | ironment) | ironment) | | | +-------------+-----------+-----------+------------+---------------+ | Executing | Global | Global | Global | | | non-strict | en | en | object | | | global code | vironment | vironment | | | | | (object | (object | | | | | env | env | | | | | ironment) | ironment) | | | +-------------+-----------+-----------+------------+---------------+ | Executing | Global | Global | Global | Non-direct | | strict | en | en | object | eval code, or | | non-direct | vironment | vironment | | eval code | | eval code | (object | (object | | without a | | | env | env | | calling | | | ironment) | ironment) | | context (when | | | | | | in practice?) | +-------------+-----------+-----------+------------+---------------+ | Executing | Global | Global | Global | Non-direct | | non-strict | en | en | object | eval code, or | | non-direct | vironment | vironment | | eval code | | eval code | (object | (object | | without a | | | env | env | | calling | | | ironment) | ironment) | | context (when | | | | | | in practice?) | +-------------+-----------+-----------+------------+---------------+ | Executing | New | Same as | Use | The parent of | | strict | de | lexical | calling | the new | | direct eval | clarative | en | context&#39;s | declarative | | code | en | vironment | <code>this</code> | environment | | | vironment | | binding | record is the | | | | | | calling | | | | | | context&#39;s | | | | | | lexical | | | | | | environment. | +-------------+-----------+-----------+------------+---------------+ | Executing | Use | Use | Use | | | non-strict | calling | calling | calling | | | direct eval | c | c | context&#39;s | | | code | ontext&#39;s | ontext&#39;s | <code>this</code> | | | | lexical | variable | binding | | | | en | en | | | | | vironment | vironment | | | +-------------+-----------+-----------+------------+---------------+ | Executing | New | Same as | Coerced | The parent of | | non-strict | de | lexical | <code>thisArg</code>: | the new | | function | clarative | en | | declarative | | code | en | vironment | If <code>null</code> | environment | | | vironment | | or | record is the | | | | | <code>u | called | | | | | ndefined</code>, | function&#39;s | | | | | use global | <code>[[Scope]]</code> | | | | | object. | internal | | | | | | property (see | | | | | If | below). | | | | | n | | | | | | on-Object, | <code>thisArg</code> is | | | | | use | supplied by | | | | | <code>ToObject</code> | caller in the | | | | | <code>( | function call | | | | | thisArg)</code>. | algorithm. | | | | | | | | | | | If Object, | | | | | | use | | | | | | <code>thisArg</code> | | | | | | directly. | | +-------------+-----------+-----------+------------+---------------+ | Executing | New | Same as | <code>thisArg</code> | The parent of | | strict | de | lexical | without | the new | | function | clarative | en | any | declarative | | code | en | vironment | coercion | environment | | | vironment | | | record is the | | | | | | called | | | | | | function&#39;s | | | | | | <code>[[Scope]]</code> | | | | | | internal | | | | | | property (see | | | | | | below). | | | | | | | | | | | | <code>thisArg</code> is | | | | | | supplied by | | | | | | caller in the | | | | | | function call | | | | | | algorithm. | +-------------+-----------+-----------+------------+---------------+</p><p>Function <code>[[Scope]]</code> initialization is described in E5 Section 13:</p><ul><li>For function declarations, the <code>[[Scope]]</code> internal property is initialized to the variable environment of the execution context containing the declaration. This is the same as initializing <code>[[Scope]]</code> to the lexical environment of the containing context, because function declarations are only allowed at the top level. If function declarations are allowed in other places (than the top level), it makes more sense to initialize <code>[[Scope]]</code> to the current lexical environment.</li><li>For anonymous function expressions, the <code>[[Scope]]</code> internal property is initialized to the lexical environment of the execution context containing the expression.</li><li>For named function expressions, a new declarative environment is created whose parent is the lexical environment of the execution context containing the expression. The new environment will be initialized with an immutable binding for the name of the function, and will then be used as the <code>[[Scope]]</code> of the function object.</li></ul><h2 id="environment-record-implementation" tabindex="-1">Environment record implementation <a class="header-anchor" href="#environment-record-implementation" aria-label="Permalink to &quot;Environment record implementation&quot;">​</a></h2><h3 id="specification" tabindex="-1">Specification <a class="header-anchor" href="#specification" aria-label="Permalink to &quot;Specification&quot;">​</a></h3><p>Environment records are described in E5 Section 10.2.1. They define how identifiers are bound to values in an ECMAScript execution context. Bindings can be established in several ways:</p><ol><li>variable and function declarations in the global scope</li><li>variable and function declarations in eval code</li><li>variable and function declarations in functions</li><li><code>catch</code> clauses</li><li><code>with</code> statements</li></ol><p>An environment record maintains bindings to a certain set of identifiers, and may have (at most one) parent record (called <em>outer environment reference</em>) with further bindings.</p><p>There are two types of environment records:</p><ol><li><em>declarative environment record</em>: binds identifiers to values directly</li><li><em>object environment record</em>: refers to an external ECMAScript object which contains the variable bindings</li></ol><p>Declarative environment records are the ordinary way of binding identifiers. The underlying map of identifiers to values is only visible to the program through variable accesses. For object environment records, the identifiers are bound through an ordinary ECMAScript object (referred to by the object environment record); object environment records are used e.g. in the global propgram scope and in the <code>with</code> statement.</p><p>An ECMAScript E5 execution environment maintains two environment record references (E5 Section 10.3):</p><ul><li>A <em>variable environment</em> refers to an environment record which is used for function and variable declarations</li><li>A <em>lexical environment</em> refers to an environment record which is used for variable lookups (including deletes)</li></ul><p>Very often these two refer to the same environment record. A new, nested lexical environment can be created e.g. through a <code>with</code>, a <code>catch</code>, a nested function, etc.</p><h3 id="internal-representation" tabindex="-1">Internal representation <a class="header-anchor" href="#internal-representation" aria-label="Permalink to &quot;Internal representation&quot;">​</a></h3><p>The current implementation makes no distinction between a lexical environment and the environment record it refers to. Instead, a combination of a lexical environment, its environment record, and a possible outer lexical environment reference is implemented as a single internal object which is not directly visible to program code.</p><p>An outer lexical environment reference (the &quot;parent record&quot;) is identified using the internal prototype field of the object. This does <em>not</em> mean that ordinary property lookups (with automatic prototype walking) are used for variable lookups: the internal prototype is simply a convenient place to maintain the parent relationship, having an easily accessible slot, being already visible to garbage collection etc.</p><h3 id="declarative-environment-record" tabindex="-1">Declarative environment record <a class="header-anchor" href="#declarative-environment-record" aria-label="Permalink to &quot;Declarative environment record&quot;">​</a></h3><p>A <em>declarative environment record</em> object maintains identifier mappings in two ways:</p><ol><li>directly as properties of the environment record</li><li>by identifying an active activation record (&quot;open scope&quot;) and a set of identifiers bound to the registers of that activation record</li></ol><p>In the latter case, the environment record identifies the thread, the function, and the &quot;register base&quot; of the activation record in the thread&#39;s value stack. These allow an identifier to be mapped to a value stack entry as follows:</p><ol><li>The function&#39;s variable map (if it exists) is consulted to find the identifiers register number, relative to the bottom of the activation. (Of course, the identifier might not be mapped.)</li><li>The &quot;register base&quot; of the environment record identifies the absolute value stack index of the activation record&#39;s frame bottom, and is added to the relative register number to get an absolute value stack index.</li></ol><p>Note that the actual activation record does not need to be identified, we just need the register base to resolve absolute value stack index of a variable. However, this approach does not allow validation of the resulting value stack index (e.g. to verify that it is indeed inside the activation record&#39;s frame).</p><p>When a declarative environment is &quot;closed&quot;, identifiers bound to activation registers are copied to the internal environment record object as plain properties (with the help of the callee&#39;s <code>_Varmap</code>). The internal control fields are updated to indicate that the environment is closed, so that later lookups can skip open scope lookups which would now reference stale value stack indices.</p><p>The variables mapped as properties have their attributes set as follows:</p><ul><li><code>[[Enumerable]]</code>: does not matter as the properties are not visible to the program (currently set to <code>true</code>)</li><li><code>[[Writable]]</code>: set to <code>true</code> for mutable bindings, <code>false</code> for immutable bindings</li><li><code>[[Configurable]]</code>: set to <code>true</code> for mutable bindings which are also deletable, <code>false</code> for non-deletable mutable bindings and immutable bindings</li></ul><p>Register-bound identifiers are assumed to be non-deletable mutable bindings: register bindings cannot be easily deleted (the bytecode may refer to them directly), and protecting register bound identifiers from being modified would require some control information we don&#39;t have. As a result, other types of bindings cannot be mapped to registers (i.e. declarations inside eval, <code>arguments</code> binding, and the name binding of a named function expression) and require an explicit environment record object.</p><h3 id="object-environment-record" tabindex="-1">Object environment record <a class="header-anchor" href="#object-environment-record" aria-label="Permalink to &quot;Object environment record&quot;">​</a></h3><p>An <em>object environment record</em> refers to an external ECMAScript object (visible to the program) &quot;backing&quot; the identifier bindings. The target object is identified with an internal control property.</p><p>The internal object is initialized with:</p><ul><li>Object class set to <code>DUK_HOBJECT_CLASS_OBJENV</code></li><li>Internal prototype referring to outer environment record</li><li>Internal control property: <code>_Target</code></li></ul><p>Identifier lookups proceed to the <code>_Target</code> object while the parent environment record is identified by the prototype of the environment record (not of <code>_Target</code>).</p><h2 id="example-internal-environment-record-objects" tabindex="-1">Example internal environment record objects <a class="header-anchor" href="#example-internal-environment-record-objects" aria-label="Permalink to &quot;Example internal environment record objects&quot;">​</a></h2><p>Let&#39;s consider an environment with:</p><ol><li>the global object (outermost)</li><li>a declarative environment (of a function, scope is open)</li><li>an object environment (e.g. of a <code>with</code> clause)</li></ol><p>This could happen in this example:</p><pre><code>// global scope: a variable lookup here would use &#39;record1&#39;

var with_object = { &quot;xyz&quot;: &quot;zy&quot; };

function func() {
  var foo = &#39;my foo&#39;;
  var bar = &#39;my bar&#39;;

  // in the example below, we assume this variable was not mapped
  // to a register for some reason (wouldn&#39;t ordinarily happen)
  var quux = &quot;a non-register binding&quot;;

  // variable lookup here would use &#39;record2&#39;

  with (with_object) {
    // variable lookup here would use &#39;record3&#39;
  }
}
</code></pre><p>The objects could be roughly as follows; leading underscore indicates an internal value not visible to the program, double leading underscore indicates internal properties stored directly in internal structures outside the property table, e.g. <code>__prototype</code> denotes internal prototype:</p><pre><code>global_object = {
  &quot;NaN&quot;: NaN,
  &quot;Infinity&quot;: Infinity,
  &quot;undefined&quot;: undefined,
  &quot;eval&quot;: [function],
  &quot;parseInt&quot;: [function],
  ...
}

func = {
  // &quot;foo&quot; maps to reg 0, &quot;bar&quot; to reg 1, &quot;quux&quot; not register mapped
  &quot;_Varmap&quot;: { &quot;foo&quot;: 0, &quot;bar&quot;: 1 },
  ...
}

with_object = {
  &quot;xyz&quot;: &quot;zy&quot;
}

record1 = {
  // Flag DUK_HOBJECT_CLASS_OBJENV set
  &quot;__prototype&quot;: null,
  &quot;__target&quot;: global_object,    // identifies binding target
  &quot;__has_this&quot;: false
}

record2 = {
  // Flag DUK_HOBJECT_CLASS_DECENV set
  &quot;__prototype&quot;: record1,
  &quot;__varmap&quot;: varmap,  // _Varmap of target function (name-to-reg)
  &quot;__thread&quot;: thread,  // identifies valstack
  &quot;__regbase&quot;: 100,   // identifies valstack base for regs
  &quot;quux&quot;: &quot;a non-register binding&quot;

  // var &quot;foo&quot; resides in value stack absolute index 100 + 0 = 100,
  // var &quot;bar&quot; in absolute index 100 + 1 = 101
}

record3 = {
  // Flag DUK_HOBJECT_CLASS_OBJENV set
  &quot;__prototype&quot;: record2,
  &quot;__target&quot;: with_object,
  &quot;__has_this&quot;: true
}
</code></pre><p>Once again, the compiler strives to avoid creating explicit environment records whenever possible. In the example above the compiler won&#39;t be successful: the object environment required by <code>with</code> also causes the declarative environment (record2) to be created.</p><h3 id="functions-and-environment-records" tabindex="-1">Functions and environment records <a class="header-anchor" href="#functions-and-environment-records" aria-label="Permalink to &quot;Functions and environment records&quot;">​</a></h3><p>A function object (<code>duk_hcompfunc</code>) records the following conceptual variable access related information:</p><ul><li>A variable map, which maps an identifier to a register number. Ideally all function variables / functions are register mapped, but this is not always possible.</li><li>Control data for initializing the lexical and variable environments of new invocations.</li></ul><p>There are separate function template objects (which are essentially functions without an outer environment) and concrete function instance objects. The detailed properties vary a bit between the two.</p><p>More concretely:</p><ul><li>The <code>DUK_HOBJECT_FLAG_NEWENV</code> object level flag, and the <code>lex_env</code> and <code>var_env</code> fields of <code>duk_hcompfunc</code> control activation record lexical and variable environment initialization as described below.</li><li>The internal property <code>_Varmap</code> contains a mapping from an identifier name to a register number relative to the activation record frame bottom.</li><li>The internal property <code>_Formals</code> contains a list of formal argument names.</li><li>Template function objects, used for creating concrete function instances, use <code>DUK_HOBJECT_FLAG_NAMEBINDING</code> flag to indicate that the template represents a named function expression. For such functions, the function name (stored in <code>name</code>) needs to be bound in an environment record just outside a function activation&#39;s environment record.</li><li>The compiler attempts to drop any fields not required from compiled objects. In many common cases (even when dynamic variables accesses cannot be ruled out) no control fields are required.</li></ul><p>The detailed handling of these is documented as part of the source for:</p><ul><li>Creating function templates in the compiler</li><li>Instantiating function instances from templates (closures)</li></ul><p>Notes:</p><ul><li>Environment record initialization is done only when (if) it is actually needed (e.g. for a function declaration). It is not created unnecessarily when a function is called.</li><li>The <code>DUK_HOBJECT_FLAG_NEWENV</code> is set for ordinary functions, which always get a new environment record for variable declaration and lookup. The flag is cleared for global code and eval code; or rather functions compiled from global code and eval code.</li><li>Unlike Duktape, ECMAScript does not separate the compilation and execution of global code and eval code. Hence the handling is seemingly a bit different although the outcome should be the same.</li></ul><h2 id="preliminary-work" tabindex="-1">Preliminary work <a class="header-anchor" href="#preliminary-work" aria-label="Permalink to &quot;Preliminary work&quot;">​</a></h2><h3 id="getidref" tabindex="-1">GETIDREF <a class="header-anchor" href="#getidref" aria-label="Permalink to &quot;GETIDREF&quot;">​</a></h3><p>The <code>GetIdentifierReference</code> specification algorithm walks the chain of environment records looking for a matching identifier binding. It returns a &quot;reference&quot; value which can act as both a left-hand-side and a right-hand-side value. The reference identifies (1) an environment record, (2) an identifier name, and (3) a strictness flag.</p><p>When using the reference as a left-hand-side value, the environment record is written to. For declarative records, this is a write to internal object (an internal <code>duk_hobject</code> in Duktape) or a value stack entry (a <code>duk_tval</code> for register bound identifiers). For object environment records, this is a property write (a <code>[[Put]]</code> call) to a user visible object, possibly invoking a setter call.</p><p>When using the reference as a right-hand-side value, the environment record is read from. For declarative records, this is a read from an internal object or a value stack entry (for register bound identifiers). For object environment records, this is a property read (a <code>[[Get]]</code> call), possibly invoking a getter call.</p><p>Note that the storage location of any identifier value is conceptually an external or an internal object. However, the concrete implementation is a bit more complicated: an identifier value may be either stored in an object or in an activation&#39;s register file, i.e., a particular entry in the value stack of some thread. This needs to be taken into account when representing a &quot;reference&quot; type internally.</p><p>A close analog of <code>GetIdentifierReference</code> is currently implemented as a helper function (referred to as GETIDREF in this document). GETIDREF returns multiple values which the caller can use to implement the actual operation (<code>GETVAR</code>, <code>PUTVAR</code>, <code>DELVAR</code>, <code>HASVAR</code>). The values returned include:</p><ul><li><code>result</code>: <code>true</code> if binding found, <code>false</code> otherwise. If <code>false</code>, other values are undefined.</li><li><code>holder</code>: a pointer to the &quot;holder&quot; object, the internal or external object storing the binding value. For register-bound identifiers, this is NULL.</li><li><code>value</code>: an <code>duk_tval</code> pointer to the current value for register bindings, points to a value stored in a value stack. For declarative environment records, <code>value</code> points to the <code>duk_tval</code> property entry of the internal object. For object environment records, this is NULL.</li><li><code>attrs</code>: property attributes of <code>value</code> (if <code>value</code> is NULL, this field is not needed). Attributes are needed in PUTVAR: before updating a value in-place using a direct <code>duk_tval</code> write, we need to know that the value is writable. Register bound variables are always writable (mutable), denoted &quot;W&quot; in the table below.</li><li><code>this_binding</code>: an <code>duk_tval</code> pointer to the <code>this</code> binding related to the reference, points to a value stored in an object.</li><li><code>env</code>: a pointer to the lexical environment record (an <code>duk_hobject</code>) where the binding was found. For register-bound identifiers, this is NULL.</li></ul><p>The following table clarifies the return values in different cases:</p><hr><p>Case result holder value attrs this_binding env</p><hr><p>Delayed declarative true NULL points to W NULL NULL environment, bound valstack<br> in register of<br> current activation</p><p>Declarative true NULL points to W NULL env environment, bound valstack<br> in register of open<br> environment record</p><p>Declarative true env points to from NULL env environment, bound prop prop<br> in (open or closed) storage<br> environment record<br> object</p><p>Object environment, true target NULL n/a NULL env bound in target<br> object, no &quot;this<br> binding&quot;</p><p>Object environment, true target NULL n/a target env bound in target<br> object, has &quot;this<br> binding&quot;</p><h2 id="not-found-false-n-a-n-a-n-a-n-a-n-a" tabindex="-1">Not found false n/a n/a n/a n/a n/a <a class="header-anchor" href="#not-found-false-n-a-n-a-n-a-n-a-n-a" aria-label="Permalink to &quot;Not found            false    n/a      n/a        n/a     n/a            n/a&quot;">​</a></h2><p>The object environment records created by the <code>with</code> statement provide a &quot;this binding&quot; (<code>provideThis</code> is true, see E5 Section 12.10); other object environment records do not. The &quot;this binding&quot; only affects function calls made through bound identifiers, e.g. as in:</p><pre><code>var foo = {
  bar: function() { print(&quot;&quot; + this); },
  toString: function() { print(&quot;i&#39;m foo&quot;); }
}

with (foo) {
  // prints &quot;i&#39;m foo&quot;, similar to being called
  // like: foo.bar()
  bar();
}
</code></pre><h4 id="original-algorithm" tabindex="-1">Original algorithm <a class="header-anchor" href="#original-algorithm" aria-label="Permalink to &quot;Original algorithm&quot;">​</a></h4><p>The original <code>GetIdentifierReference</code> is described in E5 Section 10.2.2.1. The inputs are: lexical environment <code>lex</code>, identifier string <code>name</code>, and a <code>strict</code> flag:</p><ol><li>If <code>lex</code> is the value <code>null</code>, then a. Return a value of type Reference whose base value is <code>undefined</code>, whose referenced name is <code>name</code>, and whose strict mode flag is <code>strict</code>.</li><li>Let <code>envRec</code> be <code>lex</code>&#39;s environment record.</li><li>Let <code>exists</code> be the result of calling the <code>HasBinding(N)</code> concrete method of <code>envRec</code> passing <code>name</code> as the argument <code>N</code>.</li><li>If <code>exists</code> is <code>true</code>, then a. Return a value of type Reference whose base value is <code>envRec</code>, whose referenced name is <code>name</code>, and whose strict mode flag is <code>strict</code>.</li><li>Else a. Let <code>outer</code> be the value of <code>lex</code>&#39;s outer environment reference. b. Return the result of calling <code>GetIdentifierReference</code> passing <code>outer</code>, <code>name</code>, and <code>strict</code> as arguments.</li></ol><p>Notes:</p><ul><li>The algorithm supports the case where the starting lexical environment is <code>null</code>, although step 1 is more likely intended to just be the recursion terminator.</li><li>The recursion walks the <code>outer</code> reference chain, which our implementation handles through internal prototypes of the environment records.</li></ul><h4 id="eliminating-recursion" tabindex="-1">Eliminating recursion <a class="header-anchor" href="#eliminating-recursion" aria-label="Permalink to &quot;Eliminating recursion&quot;">​</a></h4><ol><li><strong>NEXT:</strong> If <code>lex</code> is the value <code>null</code>, then: a. Return a value of type Reference whose base value is <code>undefined</code>, whose referenced name is <code>name</code>, and whose strict mode flag is <code>strict</code>.</li><li>Let <code>envRec</code> be <code>lex</code>&#39;s environment record.</li><li>Let <code>exists</code> be the result of calling the <code>HasBinding(N)</code> concrete method of <code>envRec</code> passing <code>name</code> as the argument <code>N</code>.</li><li>If <code>exists</code> is <code>true</code>, then a. Return a value of type Reference whose base value is <code>envRec</code>, whose referenced name is <code>name</code>, and whose strict mode flag is <code>strict</code>.</li><li>Let <code>lex</code> be the value of <code>lex</code>&#39;s outer environment reference.</li><li>Goto NEXT.</li></ol><h4 id="concrete-implementation" tabindex="-1">Concrete implementation <a class="header-anchor" href="#concrete-implementation" aria-label="Permalink to &quot;Concrete implementation&quot;">​</a></h4><p>A few notes first:</p><ul><li>The implementation delays the creation of an explicit declarative environment record when possible. In this case the initial <code>lex</code> value is <code>NULL</code> and should be treated like an empty declarative environment record with a certain outer reference, and possibly a set of identifiers bound to registers. To do this, we need a reference to the current activation (<code>act</code> below).</li><li>Some callers require a variant which does not follow the outer environment reference chain. The algorithm incorporates a flag <code>parents</code> controlling this (if true, parent chain is followed).</li></ul><p>First draft:</p><ol><li>If <code>lex</code> is <code>null</code> and <code>act</code> is defined then (delayed declarative environment record): a. Check whether <code>name</code> is bound to a register of <code>act</code>. To do this, the function object needs to be looked up based on <code>act</code>, and the function metadata be consulted; in particular, the <code>_Varmap</code> internal property (which maps names to register numbers) is used. b. If <code>name</code> is mapped, return the following: - Result: <code>true</code> - Value pointer: point to register storage - Attributes: writable - This pointer: NULL - Environment pointer: NULL - Holder pointer: NULL c. If <code>parents</code> is <code>false</code>, goto NOTFOUND. d. Else, let <code>lex</code> be the outer environment record that a declarative environment record created for <code>act</code> would have. This is concretetely looked up from the <code>_Lexenv</code> internal property of the function related to <code>act</code>.</li><li><strong>NEXT:</strong> If <code>lex</code> is the value <code>null</code>, then goto NOTFOUND.</li><li>If <code>lex</code> is a declarative environment record, then: a. If <code>lex</code> is <em>open</em> (activation registers are still in use): 1. Check whether <code>name</code> is mapped to a register of the activation related to the environment record. These are concretely looked up using internal properties of <code>lex</code>. (Note that the related activation may be any function, and even that of another thread.) 2. If so, return the following values (value pointer can always be given, and the caller is always allowed to modify the value in-place, because all register bindings are mutable): - Result: <code>true</code> - Value pointer: point to register storage - This pointer: NULL - Environment pointer: <code>lex</code> - Holder pointer: NULL b. If <code>lex</code> has a property named <code>name</code>, return the following values: - Result: <code>true</code> - Value pointer: point to storage location of property in <code>lex</code> - Attributes: from <code>lex</code> property (non-writable for immutable bindings, writable for others) - This pointer: NULL - Environment pointer: <code>lex</code> - Holder pointer: <code>lex</code></li><li>Else <code>lex</code> is an object environment record: a. Let <code>target</code> be the binding object for <code>lex</code>. (Note: this is always defined, and an object.) b. If the result of calling <code>[[HasProperty]]</code> for <code>target</code> with the property name <code>name</code> is <code>true</code>: 1. If <code>lex</code> has the internal property <code>_This</code>, set <code>thisBinding</code> to its value. Else set <code>thisBinding</code> to <code>NULL</code>. 2. Return the following values: - Result: <code>true</code> - Value pointer: NULL - Attributes: arbitrary (use zero) - This pointer: <code>thisBinding</code> - Environment pointer: <code>lex</code> - Holder pointer: <code>target</code></li><li>If <code>parents</code> is <code>false</code>, goto NOTFOUND.</li><li>Let <code>lex</code> be the internal prototype of <code>lex</code>.</li><li>Goto NEXT.</li><li><strong>NOTFOUND:</strong> Return the following: <ul><li>Result: <code>false</code></li><li>Value pointer: NULL</li><li>Attributes: arbitrary (use zero)</li><li>This pointer: NULL</li><li>Environment pointer: NULL</li><li>Holder pointer: NULL</li></ul></li></ol><h2 id="hasvar-check-existence-of-identifier" tabindex="-1">HASVAR: check existence of identifier <a class="header-anchor" href="#hasvar-check-existence-of-identifier" aria-label="Permalink to &quot;HASVAR: check existence of identifier&quot;">​</a></h2><p>Unlike e.g. GETVAR, HASVAR does not traverse the environment record outer reference chain. HASVAR is also not really an exposed primitive; ECMAScript code cannot access it directly. It is used internally for function call handling, and can also be used from the C API.</p><p>Using GETIDREF:</p><ol><li>Let <code>res</code> be the result of calling <code>GETIDREF</code> with the arguments <code>env</code>, <code>name</code>, and <code>parents</code> set to <code>false</code>.</li><li>Return the &quot;result&quot; component of <code>res</code>.</li></ol><h2 id="getvar-read-identifier-value" tabindex="-1">GETVAR: read identifier value <a class="header-anchor" href="#getvar-read-identifier-value" aria-label="Permalink to &quot;GETVAR: read identifier value&quot;">​</a></h2><p>Conceptual steps:</p><ul><li>Identifier resolution (E5 Section 10.3.1) is used to resolve identifier references.</li><li>Identifier resolution calls <code>GetIdentifierReference</code> (E5 Section 10.2.2.1), which returns a Reference type.</li><li>A right-hand-side expression &quot;coerces&quot; the Reference to a value using <code>GetValue</code> (E5 Section 8.7.1).</li></ul><p>In the optimal case, all of these can be resolved at compile time, converting the identifier read into a register lookup. No explicit run-time processing happens in this case.</p><p>In other cases the compiler emits a <code>GETVAR</code> instruction which performs the necessary (slow) steps at run time. The identifier name (a string) is always known at compile time as there is no indirect variable lookup; an <code>eval</code> call might look like one, but any identifier reference has a string name when compiling the <code>eval</code> argument string, e.g. as in:</p><pre><code>function f() {
  return eval(&quot;return foo;);
}
</code></pre><p>The run time part begins with, essentially, <code>GetIdentifierReference</code> which is given a lexical environment <code>env</code>, an identifier name <code>name</code>, and a <code>strict</code> flag which depends on the function containing the expression.</p><p>The GETVAR primitive differs from a plain identifier lookup in that it also returns the &quot;this binding&quot; related to the identifier, if defined.</p><p>Let&#39;s look at <code>GetValue</code> first.</p><h3 id="getvalue" tabindex="-1">GetValue <a class="header-anchor" href="#getvalue" aria-label="Permalink to &quot;GetValue&quot;">​</a></h3><p>GetValue simplifies to (here, <code>V</code> is the Reference):</p><ol><li>Let <code>base</code> be the result of calling <code>GetBase(V)</code> (which must be an environment record).</li><li>If <code>IsUnresolvableReference(V)</code>, throw a <code>ReferenceError</code> exception.</li><li>Return the result of calling the <code>GetBindingValue</code> (see 10.2.1) concrete method of <code>base</code> passing <code>GetReferencedName(V)</code> and <code>IsStrictReference(V)</code> as arguments.</li></ol><p>Inlining the <code>GetBindingValue</code> calls (E5 Sections 10.2.1.1.4 and 10.2.1.2.4):</p><ol><li>Let <code>base</code> be the result of calling <code>GetBase(V)</code> (which must be an environment record).</li><li>If <code>IsUnresolvableReference(V)</code>, throw a <code>ReferenceError</code> exception. (Note: this is unconditional.)</li><li>If <code>base</code> is a declarative environment record, then: a. If the binding for <code>name</code> is an uninitialized immutable binding, then: 1. If <code>strict</code> is <code>true</code>, then throw a <code>ReferenceError</code> exception. 2. Else, return <code>undefined</code>. b. Return the value currently bound to <code>name</code> in <code>base</code>. (Note: the value must exist, because <code>IsUnresolvableReference()</code> checks that it does.)</li><li>Else <code>base</code> must be an object environment record and: a. Let <code>bindings</code> be the bindings object for <code>base</code>. b. Let <code>value</code> be the result of calling the <code>[[HasProperty]]</code> internal method of <code>bindings</code>, passing <code>name</code> as the property name. c. If <code>value</code> is <code>false</code>, then: 1. If <code>strict</code> is <code>true</code>, then throw a <code>ReferenceError</code> exception. 2. Else, return <code>undefined</code>. d. Return the result of calling the <code>[[Get]]</code> internal method of <code>bindings</code>, passing <code>name</code> for the argument. (Note: this may invoke an accessor.)</li></ol><p>Reworking a bit to eliminate duplication of <code>ReferenceError</code> throwing, and cleaning up:</p><ol><li>Let <code>base</code> be the result of calling <code>GetBase(V)</code> (which must be an environment record).</li><li>If <code>IsUnresolvableReference(V)</code>, throw a <code>ReferenceError</code> exception. (Note: this is unconditional.)</li><li>If <code>base</code> is a declarative environment record, then: a. If the binding for <code>name</code> is an uninitialized immutable binding, then goto NOTFOUND. b. Return the value currently bound to <code>name</code> in <code>base</code>. (Note: the value must exist, because <code>IsUnresolvableReference()</code> checks that it does.)</li><li>Else <code>base</code> must be an object environment record and: a. Let <code>bindings</code> be the bindings object for <code>base</code>. b. If the result of calling the <code>[[HasProperty]]</code> internal method of <code>bindings</code>, passing <code>name</code> as the property name, is <code>false</code>, then goto NOTFOUND. c. Return the result of calling the <code>[[Get]]</code> internal method of <code>bindings</code>, passing <code>name</code> for the argument. (Note: this may invoke an accessor.)</li><li><strong>NOTFOUND:</strong> a. If <code>strict</code> is <code>true</code>, then throw a <code>ReferenceError</code> exception. b. Else, return <code>undefined</code>.</li></ol><p>Notes:</p><ul><li>Step 3.a: uninitialized immutable bindings don&#39;t occur when running user code, they only exist temporarily in the specification algorithms.</li><li>Step 4.c: it is important to note that getting a value from an object environment record accesses a user visible property, and may lead to an accessor call. The accessor can have arbitrary side effects, such as: <ul><li>Modifying arbitrary objects, even the binding object itself.</li><li>Causing a garbage collection, and resizing and reallocation of any object&#39;s property allocation or any valstack. This may invalidate <em>any</em> existing <code>duk_tval</code> pointers to such structures (but not any &quot;plain&quot; heap object pointers, such as pointers to strings and objects).</li></ul></li></ul><h3 id="using-getidref" tabindex="-1">Using GETIDREF <a class="header-anchor" href="#using-getidref" aria-label="Permalink to &quot;Using GETIDREF&quot;">​</a></h3><p>Arguments are environment record <code>env</code>, and identifier name <code>name</code>. The return value is a pair (value, this_binding).</p><ol><li>Let <code>res</code> be the result of calling <code>GETIDREF</code> with the arguments <code>env</code>, <code>name</code>, and <code>parents</code> set to <code>true</code>.</li><li>If <code>res.result</code> is <code>false</code>, throw a <code>ReferenceError</code>. (Note: this is unconditional.)</li><li>If <code>res.value</code> is not NULL (identifier bound to a register in a declarative environment record) then: a. Return <code>res.value</code> and <code>undefined</code>.</li><li>Else <code>res.holder</code> must not be NULL (identifier bound to a declarative environment record or an object environment record target object): a. Let <code>this</code> be <code>ref.this_binding</code>. b. Let <code>val</code> be the result of calling <code>[[Get]]</code> on <code>res.holder</code> with the property name <code>name</code>. c. Return <code>val</code> and <code>this</code>.</li></ol><p>Notes:</p><ul><li>In step 4, note that the <code>[[Get]]</code> call may invoke a getter and may thus have an arbitrary number of side effects, including resizing of the property allocation of any object and any valstack. Any existing <code>duk_tval</code> pointers may be invalidated. This is why step 4.a should conceptually happen first.</li></ul><h3 id="handling-of-typeof-for-an-unresolvable-identifier" tabindex="-1">Handling of <code>typeof</code> for an unresolvable identifier <a class="header-anchor" href="#handling-of-typeof-for-an-unresolvable-identifier" aria-label="Permalink to &quot;Handling of \`typeof\` for an unresolvable identifier&quot;">​</a></h3><p>The <code>typeof</code> operator needs slightly different behavior to the above algorithm for unresolvable references. Instead of throwing a <code>ReferenceError</code> <code>typeof</code> returns <code>undefined</code> for an unresolvable reference.</p><p>Another alternative would be to use HASVAR first and then (depending on the result) use GETVAR.</p><h2 id="putvar-write-identifier-value" tabindex="-1">PUTVAR: write identifier value <a class="header-anchor" href="#putvar-write-identifier-value" aria-label="Permalink to &quot;PUTVAR: write identifier value&quot;">​</a></h2><ul><li><code>GetIdentifierReference</code></li><li><code>PutValue</code></li></ul><p>Note: the E5 specification prohibits a binding or assignment to an identifier named <code>eval</code> or <code>arguments</code> in strict mode. This is actually prevented during compilation, and causes a compile time <code>SyntaxError</code>:</p><ul><li>E5 Section 11.13: single or compound assignment</li><li>E5 Section 12.2.1: variable or function declaration in a function body</li><li>E5 Section 13.1: function argument name</li><li>E5 Section 12.14.1: <code>catch</code> clause variable name</li></ul><p>As a result, there is no need to check for this at run time when assigning values to variables (either in actual program code, or in bytecode prologue initializing function bindings). The implementation does assert for this condition though.</p><p>Let&#39;s look at <code>PutValue</code> first.</p><h3 id="putvalue" tabindex="-1">PutValue <a class="header-anchor" href="#putvalue" aria-label="Permalink to &quot;PutValue&quot;">​</a></h3><p>PutValue simplifies to (here, <code>V</code> is the Reference and <code>W</code> is the value):</p><ol><li>Let <code>base</code> be the result of calling <code>GetBase(V)</code> (which must be an environment record).</li><li>If <code>IsUnresolvableReference(V)</code>, then: a. If <code>IsStrictReference(V)</code> is <code>true</code> then throw a <code>ReferenceError</code> exception. b. Call the <code>[[Put]]</code> internal method of the global object, passing <code>GetReferencedName(V)</code> for the property name, <code>W</code> for the value, and <code>false</code> for the <code>Throw</code> flag.</li><li>Call the <code>SetMutableBinding</code> (10.2.1) concrete method of <code>base</code>, passing <code>GetReferencedName(V)</code>, <code>W</code>, and <code>IsStrictReference(V)</code> as arguments.</li><li>Return.</li></ol><p>Inlining the <code>SetMutableBinding</code> calls (E5 Sections 10.2.1.1.3 and 10.2.1.2.3):</p><ol><li>Let <code>base</code> be the result of calling <code>GetBase(V)</code> (which must be an environment record).</li><li>If <code>IsUnresolvableReference(V)</code>, then: a. If <code>IsStrictReference(V)</code> is <code>true</code> then throw a <code>ReferenceError</code> exception. b. Call the <code>[[Put]]</code> internal method of the global object, passing <code>GetReferencedName(V)</code> for the property name, <code>W</code> for the value, and <code>false</code> for the <code>Throw</code> flag.</li><li>If <code>base</code> is a declarative environment record, then: a. If the binding for <code>GetReferencedName(V)</code> in <code>base</code> is a mutable binding, change its bound value to <code>W</code>. b. Else this must be an attempt to change the value of an immutable binding so throw a <code>TypeError</code> exception.</li><li>Else <code>base</code> must be an object environment record and: a. Let <code>bindings</code> be the binding object for <code>base</code>. b. Call the <code>[[Put]]</code> internal method of <code>bindings</code> with arguments <code>GetReferencedName(V)</code>, <code>W</code>, and <code>IsStrictReference(V)</code>. (Note: this may invoke an accessor.)</li><li>Return.</li></ol><p>Notes:</p><ul><li>Step 4.c may have a wide variety of side effects including resizing any object property allocation or valstack.</li></ul><h3 id="using-getidref-1" tabindex="-1">Using GETIDREF <a class="header-anchor" href="#using-getidref-1" aria-label="Permalink to &quot;Using GETIDREF&quot;">​</a></h3><p>Arguments are environment record <code>env</code>, identifier name <code>name</code>, new identifier value <code>val</code>, and a <code>strict</code> flag indicating whether the code executing a PUTVAR is strict.</p><ol><li>Let <code>res</code> be the result of calling <code>GETIDREF</code> with the arguments <code>env</code>, <code>name</code>, and <code>parents</code> set to <code>true</code>.</li><li>If <code>res.result</code> is <code>false</code>: a. If <code>strict</code> is <code>true</code>, throw a <code>ReferenceError</code>. b. Call the <code>[[Put]]</code> internal method of the global object, passing <code>name</code> for the property name, <code>val</code> for the value, and <code>false</code> for the <code>Throw</code> flag.</li><li>If <code>res.value</code> is not NULL (identifier bound to a register, or to a property in a declarative environment record) and <code>res.attrs</code> indicates value is writable, then: a. Write <code>val</code> to the target of the pointer <code>res.value</code>. (Identifier bound to a register in a declarative environment record.) b. Return.</li><li>Else <code>res.holder</code> must not be NULL. Identifier is bound to a declarative environment record (an immutable binding) or an object environment record target object: a. Call the <code>[[Put]]</code> internal method of <code>res.holder</code> with arguments <code>name</code>, <code>val</code>, and <code>strict</code>. (Note: this may invoke an accessor.) b. Return.</li></ol><p>Notes:</p><ul><li>In step 4, note that the <code>[[Put]]</code> call may invoke a setter and may thus have an arbitrary number of side effects, including resizing of the property allocation of any object and any valstack. Any existing <code>duk_tval</code> pointers may be invalidated.</li></ul><h2 id="delvar-delete-identifier" tabindex="-1">DELVAR: delete identifier <a class="header-anchor" href="#delvar-delete-identifier" aria-label="Permalink to &quot;DELVAR: delete identifier&quot;">​</a></h2><ul><li><code>GetIdentifierReference</code></li><li><code>delete</code> operator applied to an identifier (not a property)</li><li><code>DeleteBinding</code></li></ul><p>The deletion process locates the nearest declaration and deletes that (if possible). There may be on outer declaration which is still in effect. For instance (Rhino):</p><pre><code>js&gt; var a = 10;
js&gt; function f() {
...     eval(&quot;var a = 20; print(a); &quot; +
...          &quot;print(delete a); print(a); &quot; +
...          &quot;print(delete a)&quot;); };
js&gt; f()
20
true
10
false
</code></pre><p>The innermost binding is an established by eval into an empty declarative environment of the function. The declaration succeeds and creates a deletable, mutable binding, which is then printed and successfully deleted. The global binding is still visible, but it is a non-deletable, mutable binding, so the delete fails. Multiple levels of deletable bindings for the same identifier are thus possible, and <code>delete</code> will always try to delete the one that is currently visible.</p><h3 id="the-delete-operator" tabindex="-1">The delete operator <a class="header-anchor" href="#the-delete-operator" aria-label="Permalink to &quot;The delete operator&quot;">​</a></h3><p>The <code>delete</code> operator is defined in E5 Section 11.4.1. A few notes:</p><ul><li><p>In non-strict mode, deletion of an unresolvable identifier succeeds silently (step 3.b), e.g.:</p><pre><code>function f() { return delete foo; }
print(f());  // prints true
</code></pre></li><li><p>In non-strict mode, deletion of a resolvable but undeletable binding succeeds with <code>false</code>:</p><pre><code>// &#39;x&#39; is a non-deletable mutable binding
function f() {
    var x = 1;
    print(delete x);
}

// -&gt; false
f();
</code></pre></li><li><p>In non-strict mode, deletion of a resolvable and deletable binding succeeds with <code>true</code>:</p><pre><code>foo = 1;  // establishes &#39;foo&#39; into global object

// -&gt; {&quot;value&quot;:1,&quot;writable&quot;:true,
//     &quot;enumerable&quot;:true,&quot;configurable&quot;:true}
print(JSON.stringify(this, &#39;foo&#39;));

// -&gt; true
print(delete foo);

// -&gt; empty
print(JSON.stringify(this, &#39;foo&#39;));
</code></pre></li><li><p>In strict mode, any attempt to delete an identifier (resolvable or not) is always a <em>compile time</em> <code>SyntaxError</code>, see steps 3.a and 5.a.</p><ul><li><p>Example 1:</p><pre><code>// SyntaxError (compile time)
function f() {
    &#39;use strict&#39;;
    delete foo;  // unresolvable
}
</code></pre></li><li><p>Example 2:</p><pre><code>// SyntaxError (compile time)
foo = 1;
function f() {
    &#39;use strict&#39;;
    delete foo;  // resolves, still a SyntaxError
}
</code></pre></li><li><p>Example 3 (applies even to object bindings):</p><pre><code>foo = { bar: 1};

with (foo) {
    var f = function() {
        &#39;use strict&#39;;
        delete bar;  // resolves, still a SyntaxError
    }
}
</code></pre></li></ul></li></ul><p>Note that <em>all</em> <code>SyntaxError</code> exceptions must be thrown at compile time (E5 Section 16). So, any run time attempts to delete identifiers with a DELVAR operation <em>must</em> happen from non-strict code.</p><p>With this in mind, the <em>run time part</em> of <code>delete</code> operator (i.e., the DELVAR primitive) only executes in non-strict code, and for a reference <code>ref</code> becomes:</p><ol><li>If <code>IsUnresolvableReference(ref)</code> then return <code>true</code>.</li><li>Else <code>ref</code> is a reference to an environment record binding; let <code>bindings</code> be <code>GetBase(ref)</code>.</li><li>Return the result of calling the <code>DeleteBinding</code> concrete method of <code>bindings</code>, providing <code>GetReferencedName(ref)</code> as the argument.</li></ol><p>Inlining the concrete <code>DeleteBinding</code> algorithms (E5 Sections 10.2.1.1.5 and 10.2.1.2.5), and renaming <code>ref</code> to <code>V</code> and <code>bindings</code> to <code>base</code> to match the GETVAR and PUTVAR algorithms:</p><ol><li>If <code>IsUnresolvableReference(V)</code> then return <code>true</code>.</li><li>Else <code>V</code> is a reference to an environment record binding; let <code>base</code> be <code>GetBase(V)</code>.</li><li>If <code>base</code> is a declarative environment record, then: a. If <code>base</code> does not have a binding for the name <code>GetReferencedName(V)</code>, return <code>true</code>. b. If the binding for <code>GetReferencedName(V)</code> in <code>base</code> cannot be deleted, return <code>false</code>. c. Remove the binding for <code>GetReferencedName(V)</code> from <code>base</code>. d. Return <code>true</code>.</li><li>Else <code>base</code> must be an object environment record and: a. Let <code>bindings</code> be the binding (target) object for <code>base</code>. b. Return the result of calling <code>[[Delete]]</code> internal method of <code>bindings</code>, passing <code>GetReferencedName(V)</code> and <code>false</code> arguments.</li></ol><p>Notes:</p><ul><li>In step 4.b: <code>[[Delete]]</code> returns <code>true</code> if the own property either does not exist, or the property exists and is deletable. <code>false</code> is only returned if a non-configurable own property exists. This matches the behavior for identifiers in declarative environment records.</li></ul><h3 id="using-getidref-2" tabindex="-1">Using GETIDREF <a class="header-anchor" href="#using-getidref-2" aria-label="Permalink to &quot;Using GETIDREF&quot;">​</a></h3><p>Arguments are environment record <code>env</code>, identifier name <code>name</code>, new identifier value <code>val</code>, and a <code>strict</code> flag indicating whether the code executing a DELVAR is strict (the <code>strict</code> flag is always <code>false</code>, though).</p><ol><li>Let <code>res</code> be the result of calling <code>GETIDREF</code> with the arguments <code>env</code>, <code>name</code>, and <code>parents</code> set to <code>true</code>.</li><li>If <code>res.result</code> is <code>false</code>: a. Return <code>true</code>.</li><li>If <code>res.value</code> is not NULL (identifier bound to a register, or a property in a declarative environment record) and <code>res.attrs</code> indicates value is non-configurable, then: a. Return <code>false</code>. (Note: register-bound identifiers are not deletable.)</li><li>Else <code>res.holder</code> must not be NULL (identifier bound to a declarative environment record or an object environment record target object): a. Call the <code>[[Delete]]</code> internal method of <code>res.holder</code> with arguments <code>name</code> and <code>false</code>. b. Return.</li></ol><p>Notes:</p><ul><li>The compiler should never emit a DELVAR for strict code, and the bytecode executor should refuse to execute such an instruction for strict code. There is no explicit check in the algorithm.</li><li>Step 4.a covers two cases: <ol><li>An identifier bound to a declarative environment record. In this case <code>res.holder</code> is the internal environment record, and the property delete follows normal <code>[[Delete]]</code> behavior. In particular, <code>[[Delete]]</code> only returns <code>false</code> if the property exists and is not configurable. Otherwise <code>[[Delete]]</code> returns <code>true</code>. This matches the desired behavior for declarative environment records (see the abstract, inlined version of the algorithm).</li><li>An identifier bound to an object environment record. In this case <code>res.holder</code> is the target object, and the <code>[[Delete]]</code> call is the desired behavior.</li></ol></li></ul><h2 id="declvar-declare-identifier" tabindex="-1">DECLVAR: declare identifier <a class="header-anchor" href="#declvar-declare-identifier" aria-label="Permalink to &quot;DECLVAR: declare identifier&quot;">​</a></h2><h3 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h3><p>Bindings are created with <code>CreateMutableBinding</code> and <code>CreateImmutableBinding</code> in E5 Section 10.5 (Declaration Binding Instantiation) and Section 12.14 (<code>catch</code> clause).</p><p><code>CreateMutableBinding</code> and <code>CreateImmutableBinding</code> both assume that they are never called if the binding has already been declared. The algorithms establishing new bindings carefully use <code>HasBinding</code> to avoid duplicate declaration attempts (see &quot;declaration binding instantiation&quot; for instance).</p><p>Declarations always go to a specified environment record; its outer environment (parent) is not checked or affected. Thus, a variable name can be re-declared if it exists in an outer context, e.g.:</p><pre><code>var a = 10;
function f() {
  // new declarative environment
  var a = 20;
}
</code></pre><p>More specifically, new bindings are created in the following places (the method of preventing a duplicate declaration is in parentheses):</p><ul><li>Section 10.5 step 4.d.iii - 4.d.iv: argument binding (checks for existing binding)</li><li>Section 10.5 step 5.c - 5.d: function declaration (checks for existing binding; special handling for re-declarations of global functions added in E5.1)</li><li>Section 10.5 step 6, 7.b.i, and 7.c.i: <code>arguments</code> binding (checks for existing binding)</li><li>Section 10.5 step 8.b - 8.c: variable declaration (checks for existing binding)</li><li>Section 12.14 <code>catch</code> step 4: <code>catch</code> variable binding (new environment, no need to check)</li></ul><p>The DECLVAR algorithm can ignore attempts to re-declare a variable, except that the re-declaration of global functions has special handling in E5.1.</p><p>Note that unlike GETVAR, PUTVAR, and DELVAR, DECLVAR has no &quot;baseline&quot; algorithm in the E5 specification. Rather, it is a primitive which is useful internally, and needs to match the scattered variable declaration needs identified above.</p><p>Also note that all non-register-bound identifiers are stored as object properties (either of an internal or an external object). Hence, DECLVAR ultimately adds or updates a property of some holder object.</p><h3 id="algorithm" tabindex="-1">Algorithm <a class="header-anchor" href="#algorithm" aria-label="Permalink to &quot;Algorithm&quot;">​</a></h3><p>Inputs:</p><ul><li>environment record <code>env</code></li><li>variable name <code>name</code></li><li>initial value <code>val</code></li><li>property attributes <code>attrs</code>, which allow the caller to control whether the binding is deletable (<code>[[Configurable]]</code> attribute) and mutable (<code>[[Writable]]</code> attribute)</li><li>flag <code>is_func_decl</code>, which indicates whether the binding being declared is a function declaration; this has no other effect than to control the special global function re-declaration behavior of E5.1</li></ul><p>Outputs:</p><ul><li>none</li></ul><p>Algorithm:</p><ol><li>Let <code>res</code> be the result of calling <code>GETIDREF</code> with the arguments <code>env</code>, <code>name</code>, and <code>parents</code> set to <code>false</code>.</li><li>If <code>res.result</code> is <code>true</code> (already declared): a. If <code>is_func_decl</code> is <code>false</code> or <code>env</code> is not the global object environment record, return (ignore re-declaration). Else <code>is_func_decl</code> is <code>true</code> and <code>env</code> is the global object environment record, and E5.1 special behavior is needed. b. Let <code>holder</code> be <code>ref.holder</code>; this must be the global object, which must hold an own property called <code>name</code>. This is the case because the global object has a <code>null</code> internal prototype. c. Let <code>X</code> be the property descriptor for <code>name</code> in <code>holder</code>. d. If <code>X.[[Configurable]]</code> is <code>false</code>: 1. If <code>X</code> is an accessor property, throw a <code>TypeError</code>. 2. If <code>X.[[Writable]]</code> is <code>false</code> or <code>X.[[Enumerable]]</code> is <code>false</code>, throw a <code>TypeError</code>. 3. Set <code>attrs</code> to the current property attributes of <code>X</code>. (Note: in effect, don&#39;t update <code>X</code> attributes; we know it is writable, enumerable, and non-configurable.) e. Update the property <code>name</code> of <code>holder</code> to be a data property with the value <code>val</code>, and attributes set to <code>attrs</code>. f. Return.</li><li>Let <code>holder</code> be the property holder object of <code>env</code> (this is <code>env</code> itself for a declarative environment, and the target (bindings) object for an object environment).</li><li>Define a new property <code>name</code> to <code>holder</code> with property attributes <code>attrs</code>. Note that this may fail if <code>holder</code> is not extensible; this can only happen for object environment records, as declarative environment records are never non-extensible.</li><li>Return.</li></ol><p>Notes:</p><ul><li>The concrete implementation has to deal with the fact that <code>env</code> creation for an activation may be delayed. So, the environment needs to be created on-the-fly if it doesn&#39;t exist yet.</li><li>Step 2 inlines yet another version of <code>[[DefineOwnProperty]]</code>.</li><li>If a function is redeclared, it must have its binding value updated.</li></ul><h2 id="fast-path" tabindex="-1">Fast path <a class="header-anchor" href="#fast-path" aria-label="Permalink to &quot;Fast path&quot;">​</a></h2><p>As a general rule, the compiler uses static analysis in an attempt to allocate variables to registers and convert variable accesses to direct register read/write operations. Only a minority of variable accesses thus happen using the slow identifier lookup described above.</p><p>If the compiler can determine that <em>all</em> variable accesses can be handled this way (and no dynamic accesses are possible e.g. through a direct <code>eval</code> call), the control information does not need to be recorded in the compiled function at all. However, if the compiler cannot rule out the possibility of arbitrary dynamic variable lookups, the control information needs to be stored.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><ul><li>A declarative environment record now records <code>_Callee</code> to get access to its <code>_Varmap</code> property. Instead, the record could store a <code>_Varmap</code> reference directly, which would drop one step from lookup of a register mapped variable. Also, if the function itself is freed, only the varmap needs to survive in the heap. The downside would be that there would be no access to function metadata, should that be useful (e.g. for debugging).</li></ul><p>[^1]: See the following E5 sections:</p><pre><code>-   Section 10.5 steps 2, 5.d, 8.c (eval code)
-   Section 10.5 step 7.b (\`arguments\` binding)
-   Section 13 (function expression)
</code></pre><p>[^2]: See the following E5 sections:</p><pre><code>-   Section 10.5, steps 7.b.i and 7.b.ii (\`arguments\` for a strict
    function)
-   Section 13, named function expression algorithm, steps 3-5
    (named function expressions)
</code></pre><p>[^3]: See the following E5 sections:</p><pre><code>-   Sections 10.2.1.1.6, 10.2.1.2.6: when implicit \`this\` is
    provided
-   Section 11.2.3 step 6.b: function call handling
-   Sections 10.2.1.2, 12.10: object environment records which have
    \`provideThis\` set (\`with\` statement only)
</code></pre><p>[^4]: See the following E5 sections:</p><pre><code>-   Section 10.4.2, step 3: strict eval code
-   Section 10.4.3: function call
-   Section 12.14: \`catch\` clause, step 3
-   Section 13.1: function expression
</code></pre><p>[^5]: See the following E5 sections:</p><pre><code>-   Section 10.2.3: global environment record
-   Section 12.10: \`with\` statement, step 4
</code></pre>`,229)]))}const f=o(a,[["render",r]]);export{p as __pageData,f as default};
