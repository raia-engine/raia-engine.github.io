import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.CKGreiRV.js";const E=JSON.parse('{"title":"Dartの型システム","description":"","frontmatter":{},"headers":[],"relativePath":"resource/dart/language/types/type_system.md","filePath":"resource/dart/language/types/type_system.md","lastUpdated":1732376957000}'),l={name:"resource/dart/language/types/type_system.md"};function h(p,s,e,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="dartの型システム" tabindex="-1">Dartの型システム <a class="header-anchor" href="#dartの型システム" aria-label="Permalink to &quot;Dartの型システム&quot;">​</a></h1><p>Dart言語は型安全です。静的な型チェックと実行時のチェックを組み合わせて、変数の値が常にその変数の静的な型と一致するようにします。型は必須ですが、型推論のため型注釈は省略可能です。</p><p>静的型チェックの利点の1つは、Dartの静的アナライザを使ってコンパイル時にバグを発見できることだ。</p><p>ジェネリクス・クラスに型アノテーションを追加することで、ほとんどの静的解析エラーを修正することができます。最も一般的なジェネリクス・クラスは、コレクション型の<code>List&lt;T&gt;</code>と<code>Map&lt;K,V&gt;</code>です。</p><p>例えば、以下のコードでは<code>printInts()</code>関数が整数リストを表示し、<code>main()</code>がリストを作成して<code>printInts()</code>に渡しています。</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printInts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printInts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><p>先のコードでは、printInts(list)の呼び出しでlist（上で強調表示）の型エラーが発生する：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error - The argument type &#39;List&lt;dynamic&gt;&#39; can&#39;t be assigned to the parameter type &#39;List&lt;int&gt;&#39;. - argument_type_not_assignable</span></span></code></pre></div><p>このエラーは、<code>List&lt;dynamic&gt;</code>から<code>List&lt;int&gt;</code>への不健全な暗黙のキャストを強調しています。<code>list</code>変数は静的な<code>List&lt;dynamic&gt;</code>型を持っています。これは、初期化宣言 <code>var list = []</code> が、<code>dynamic</code> よりも具体的な型引数を推測するのに十分な情報を解析器に提供していないためです。<code>printInts()</code>関数は、<code>List&lt;int&gt;</code>型のパラメータを予期しているため、型の不一致が発生します。</p><p>リストの作成時に型アノテーション（<code>&lt;int&gt;</code>）を追加すると（以下でハイライト）、文字列引数をintパラメータに代入できないとアナライザーが文句を言う。<code>list.add(&#39;2&#39;)</code>の引用符を削除すると、静的解析をパスし、エラーや警告なしで実行されるコードになります。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printInts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printInts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="健全性とは何か" tabindex="-1">健全性とは何か？ <a class="header-anchor" href="#健全性とは何か" aria-label="Permalink to &quot;健全性とは何か？&quot;">​</a></h2><p>健全性とは、プログラムが特定の無効な状態に陥らないことを保証することである。健全な型システムとは、ある式が評価されたときに、その式の静的型と一致しない値が返されるような状態にならないことを意味します。例えば、式の静的型がStringの場合、実行時に式を評価すると文字列しか得られないことが保証されます。</p><p>Dartの型システムは、JavaやC#の型システムと同様、健全です。静的チェック（コンパイル時のエラー）と実行時のチェックを組み合わせることで、その健全性を強化している。例えば、Stringをintに代入するのはコンパイル時のエラーである。オブジェクトがStringでない場合、as Stringを使ってオブジェクトをStringにキャストすると、実行時エラーになる。</p><h2 id="健全性のメリット" tabindex="-1">健全性のメリット <a class="header-anchor" href="#健全性のメリット" aria-label="Permalink to &quot;健全性のメリット&quot;">​</a></h2><p>健全な型システムにはいくつかの利点がある：</p><ul><li>コンパイル時に型関連のバグを明らかにする: 健全な型システムは、コードがその型について曖昧でないことを強制する。そのため、実行時には見つけにくい型関連のバグが、コンパイル時に明らかになる。</li><li>より読みやすいコード: コードが読みやすくなるのは、値が実際に指定された型を持つことを信頼できるからです。健全性のあるDartでは、型は嘘をつけない。</li><li>保守性の高いコード: 健全な型システムでは、あるコードを変更したときに、型システムが他のコードが壊れたことを警告してくれる。</li><li>より良い先行（AOT）コンパイル: 型がなくてもAOTコンパイルは可能だが、生成されるコードの効率はかなり落ちる。</li></ul><h2 id="静的解析をパスするためのヒント" tabindex="-1">静的解析をパスするためのヒント <a class="header-anchor" href="#静的解析をパスするためのヒント" aria-label="Permalink to &quot;静的解析をパスするためのヒント&quot;">​</a></h2><p>静的型のルールのほとんどは理解しやすい。ここでは、あまり目立たないルールをいくつか紹介しよう：</p><ul><li>メソッドをオーバーライドするときは、健全な戻り値の型を使用する。</li><li>メソッドをオーバーライドするときは、適切なパラメータ・タイプを使用する。</li><li>動的リストを型付きリストとして使用しない。</li></ul><p>以下の型階層を使った例で、これらのルールを詳しく見てみよう：</p><p>(図)スーパータイプがAnimalで、サブタイプがAlligator、Cat、HoneyBadgerである動物の階層。CatにはLionとMaineCoonのサブタイプがあります。</p><h3 id="メソッドをオーバーライドするときは、サウンド・リターン・タイプを使用する" tabindex="-1">メソッドをオーバーライドするときは、サウンド・リターン・タイプを使用する <a class="header-anchor" href="#メソッドをオーバーライドするときは、サウンド・リターン・タイプを使用する" aria-label="Permalink to &quot;メソッドをオーバーライドするときは、サウンド・リターン・タイプを使用する&quot;">​</a></h3><p>サブクラスのメソッドのリターン・タイプは、スーパークラスのメソッドのリターン・タイプと同じか、そのサブタイプでなければならない。Animalクラスのゲッター・メソッドを考えてみましょう：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Animal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>親ゲッターメソッドはAnimalを返します。HoneyBadgerのサブクラスでは、ゲッターの戻り値の型をHoneyBadger（またはAnimalの他のサブタイプ）に置き換えることができますが、無関係な型を指定することはできません。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HoneyBadger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  HoneyBadger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HoneyBadger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><h3 id="メソッドをオーバーライドするときは、健全なパラメータ型を使用する" tabindex="-1">メソッドをオーバーライドするときは、健全なパラメータ型を使用する <a class="header-anchor" href="#メソッドをオーバーライドするときは、健全なパラメータ型を使用する" aria-label="Permalink to &quot;メソッドをオーバーライドするときは、健全なパラメータ型を使用する&quot;">​</a></h3><p>オーバーライドされたメソッドのパラメータは、スーパークラスの対応するパラメータと同じ型またはスーパー型のいずれかを持つ必要があります。パラメータ型を元のパラメータのサブタイプに置き換えて &quot;タイト化&quot; してはいけません。</p><div class="info custom-block"><p class="custom-block-title">Note</p><p>サブタイプを使う正当な理由があれば、covariantキーワードを使うことができる。</p></div><p>Animalクラスのchase(Animal)メソッドを考えてみよう：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Animal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>chase()メソッドはAnimalを取る。HoneyBadgerは何でも追いかける。chase()メソッドをオーバーライドして、何でも（Object）を受け取るようにしても構わない。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HoneyBadger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Animal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>次のコードでは、chase()メソッドのパラメータをAnimalからAnimalのサブクラスであるMouseに変更している。</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Mouse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Cat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mouse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><p>このコードは型安全ではない。なぜなら、ネコを定義してワニの後を追わせることが可能になってしまうからだ：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Alligator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 猫には安全ではない。</span></span></code></pre></div><h3 id="ダイナミック・リストを型付きリストとして使わない" tabindex="-1">ダイナミック・リストを型付きリストとして使わない <a class="header-anchor" href="#ダイナミック・リストを型付きリストとして使わない" aria-label="Permalink to &quot;ダイナミック・リストを型付きリストとして使わない&quot;">​</a></h3><p>ダイナミック・リストは、さまざまな種類のものを含むリストを持ちたい場合に適している。しかし、動的リストを型付きリストとして使うことはできない。</p><p>このルールはジェネリック型のインスタンスにも適用される。</p><p>以下のコードでは、Dogの動的リストを作成し、それをCat型のリストに代入しているが、これは静的解析時にエラーを発生させる。</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void main() {</span></span>
<span class="line"><span>  List&lt;Cat&gt; foo = &lt;dynamic&gt;[Dog()]; // Error</span></span>
<span class="line"><span>  List&lt;dynamic&gt; bar = &lt;dynamic&gt;[Dog(), Cat()]; // OK</span></span>
<span class="line"><span>}</span></span></code></pre></div></div><h2 id="ランタイム・チェック" tabindex="-1">ランタイム・チェック <a class="header-anchor" href="#ランタイム・チェック" aria-label="Permalink to &quot;ランタイム・チェック&quot;">​</a></h2><p>ランタイム・チェックは、コンパイル時には検出できない型安全性の問題を扱う。</p><p>例えば、以下のコードは犬のリストを猫のリストにキャストするのはエラーなので、実行時に例外をスローする：</p><div class="danger custom-block"><p class="custom-block-title">✗ runtime: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; animals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dog</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; cats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><h2 id="型推論" tabindex="-1">型推論 <a class="header-anchor" href="#型推論" aria-label="Permalink to &quot;型推論&quot;">​</a></h2><p>解析器はフィールド、メソッド、ローカル変数、そしてほとんどの汎用型引数の型を推論することができます。特定の型を推測するのに十分な情報がない場合は、動的型を使用します。</p><p>ジェネリックスの型推論の例を示します。この例では、argumentsという変数に、文字列のキーとさまざまな型の値をペアにしたマップが格納されています。</p><p>この変数を明示的に型付けすると、次のようになります：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dynamic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; arguments </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;argA&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;argB&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>あるいは、varまたはfinalを使い、Dartに型を推測させることもできる：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arguments </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;argA&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;argB&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Map&lt;String, Object&gt;</span></span></code></pre></div><p>マップ・リテラルはその項目から型を推測し、次に変数はマップ・リテラルの型から型を推測する。このマップでは、キーは両方とも文字列だが、値は異なる型を持っている。 (Object を始まりとする String と int). つまり、マップリテラルの型は<code>Map&lt;String, Object&gt;</code>であり、引数変数も同様である。</p><h3 id="フィールドとメソッドの推論" tabindex="-1">フィールドとメソッドの推論 <a class="header-anchor" href="#フィールドとメソッドの推論" aria-label="Permalink to &quot;フィールドとメソッドの推論&quot;">​</a></h3><p>型の指定がなく、スーパークラスのフィールドまたはメソッドをオーバーライドするフィールドまたはメソッドは、スーパークラスのメソッドまたはフィールドの型を継承します。</p><p>宣言または継承された型を持たないが、初期値とともに宣言されたフィールドは、初期値に基づいて推論された型を取得します。</p><h3 id="静的フィールド推論" tabindex="-1">静的フィールド推論 <a class="header-anchor" href="#静的フィールド推論" aria-label="Permalink to &quot;静的フィールド推論&quot;">​</a></h3><p>静的フィールドと変数は、イニシャライザーから型を推論します。推論がサイクルに遭遇すると失敗することに注意してください（つまり、変数の型を推論するかどうかは、その変数の型を知っているかどうかに依存します）。</p><h3 id="局所変数の推論" tabindex="-1">局所変数の推論 <a class="header-anchor" href="#局所変数の推論" aria-label="Permalink to &quot;局所変数の推論&quot;">​</a></h3><p>ローカル変数の型は、初期化子があればそこから推測される。それ以降の代入は考慮されません。このため、正確すぎる型が推論される可能性があります。その場合は、型アノテーションを追加します。</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// x is inferred as an int.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></div><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// A num can be double or int.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="type-argument-inference" tabindex="-1">Type argument inference <a class="header-anchor" href="#type-argument-inference" aria-label="Permalink to &quot;Type argument inference&quot;">​</a></h3><p>コンストラクタ呼び出しやジェネリクスメソッド呼び出しの型引数は、発生コンテキストからの下向きの情報と、コンストラクタやジェネリクスメソッドの引数からの上向きの情報の組み合わせに基づいて推論されます。推論が思い通りにならない場合は、いつでも明示的に型引数を指定することができます。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Inferred as if you wrote &lt;int&gt;[].</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; listOfInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Inferred as if you wrote &lt;double&gt;[3.0].</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listOfDouble </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Inferred as Iterable&lt;int&gt;.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ints </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listOfDouble.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>最後の例では、xは下向きの情報を使ってdoubleと推論される。クロージャの戻り値の型は、上向きの情報を使用して <code>int</code> と推論されます。Dart は、<code>map()</code> メソッドの型引数を推論する際に、この戻り値の型を上方情報として使用します：<code>&lt;int&gt;</code> です。</p><h2 id="タイプの代用" tabindex="-1">タイプの代用 <a class="header-anchor" href="#タイプの代用" aria-label="Permalink to &quot;タイプの代用&quot;">​</a></h2><p>メソッドをオーバーライドする場合、（古いメソッドの）ある型を、（新しいメソッドの）新しい型に置き換えることになります。同様に、関数に引数を渡すとき、ある型を持つもの（宣言された型を持つパラメータ）を別の型を持つもの（実際の引数）に置き換えることになります。ある型を持つものを、サブタイプやスーパータイプを持つものに置き換えることができるのは、どのような場合でしょうか？</p><p>型を置き換える場合、消費者と生産者という観点から考えることが役に立つ。消費者はタイプを吸収し、生産者はタイプを生成する。</p><p>コンシューマーの型をスーパータイプに、プロデューサーの型をサブタイプに置き換えることができる。</p><p>単純な型の代入とジェネリック型による代入の例を見てみよう。</p><h2 id="単純なタイプ割り当て" tabindex="-1">単純なタイプ割り当て <a class="header-anchor" href="#単純なタイプ割り当て" aria-label="Permalink to &quot;単純なタイプ割り当て&quot;">​</a></h2><p>オブジェクトをオブジェクトに割り当てるとき、いつ型を別の型に置き換えることができるだろうか？答えは、オブジェクトがコンシューマーかプロデューサーのどちらであるかによって決まる。</p><p>次のような型階層を考えてみよう：</p><p>(図)スーパータイプがAnimalで、サブタイプがAlligator、Cat、HoneyBadgerである動物の階層。CatはLionとMaineCoonのサブタイプを持つ。</p><p><code>Cat c</code>がコンシューマーで、<code>Cat()</code>がプロデューサーである次のような単純な割り当てを考えてみよう：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>消費する立場では、特定の種類を消費するもの（猫）を、何でも消費するもの（動物）に置き換えても問題ない。したがって、Cat cをAnimal cに置き換えることは可能である。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>しかし、<code>Cat c</code>を<code>MaineCoon c</code>に置き換えると、スーパークラスが<code>Lion</code>のような異なる振る舞いをする<code>Cat</code>の型を提供する可能性があるため、型安全性が壊れてしまう：</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MaineCoon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></div><p>In a producing position, it&#39;s safe to replace something that produces a type (Cat) with a more specific type (MaineCoon). So, the following is allowed:</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MaineCoon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="generic-type-assignment" tabindex="-1">Generic type assignment <a class="header-anchor" href="#generic-type-assignment" aria-label="Permalink to &quot;Generic type assignment&quot;">​</a></h3><p>ジェネリック・タイプでもルールは同じですか？そうだ。CatのリストはAnimalのリストのサブタイプであり、MaineCoonのリストのスーパータイプです：</p><p>(図)<code>List&lt;Animal&gt; -&gt; List&lt;Cat&gt; -&gt; List&lt;MaineCoon&gt;</code></p><p>次の例では、<code>List&lt;MaineCoon&gt;</code> は <code>List&lt;Cat&gt;</code> のサブタイプなので、メインクーンのリストを myCats に代入することができる：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//✔ static analysis: successdart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MaineCoon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myMaineCoons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myCats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myMaineCoons;</span></span></code></pre></div><p>他の方向はどうだろう？<code>List&lt;Cat&gt;</code>にAnimalリストを割り当てることはできますか？</p><div class="danger custom-block"><p class="custom-block-title">✗ static analysis: failuredart</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myAnimals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myCats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAnimals;</span></span></code></pre></div></div><p>この代入は暗黙のダウンキャストを作成するため、静的解析を通過しない。これはAnimalのような非動的型では禁止されている。</p><p>この種のコードを静的解析に合格させるには、明示的なキャストを使えばいい。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myAnimals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; myCats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAnimals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span></code></pre></div><p>しかし、明示的なキャストは、キャストされるリストの実際の型（myAnimals）によっては、実行時に失敗するかもしれない。</p><h2 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h2><p>メソッドをオーバーライドする場合も、プロデューサとコンシューマのルールは適用されます。例えば</p><p>(図)Animalクラスでは、chaseメソッドがコンシューマー、parentゲッターがプロデューサーです。</p><p>コンシューマー（chase(Animal)メソッドなど）では、パラメーターの型をスーパータイプに置き換えることができます。プロデューサ（親ゲッターメソッドなど）の場合は、戻り値の型をサブタイプに置き換えることができます。</p><p>詳細は、&quot;メソッドをオーバーライドする場合は健全なリターン型を使用する&quot; および &quot;メソッドをオーバーライドする場合は健全なパラメータ型を使用する&quot; を参照してください。</p><h2 id="その他のリソース" tabindex="-1">その他のリソース <a class="header-anchor" href="#その他のリソース" aria-label="Permalink to &quot;その他のリソース&quot;">​</a></h2><p>Dartの健全性に関する詳しい情報は、以下のリソースをご参照ください：</p><ul><li>一般的な型に関する問題の解決 - 健全なDartのコードを記述する際に遭遇する可能性のあるエラーとその解決方法。</li><li>型推進エラーの修正 - 型推進エラーを理解し、修正する方法を学ぶ。</li><li>健全なヌル安全性 - 健全なヌル安全性を持つコードの記述について学びます。</li><li>静的解析のカスタマイズ - 解析オプション・ファイルを使用してアナライザとリンターを設定し、カスタマイズする方法。</li></ul>`,105)]))}const c=i(l,[["render",h]]);export{E as __pageData,c as default};
