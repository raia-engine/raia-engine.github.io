import{_ as n,c as t,a2 as s,o as i}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"Duktape 1.0 release notes","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/release-notes-v1-0.md","filePath":"resource/duktape/doc/release-notes-v1-0.md","lastUpdated":1732350347000}'),a={name:"resource/duktape/doc/release-notes-v1-0.md"};function o(r,e,l,c,d,u){return i(),t("div",null,e[0]||(e[0]=[s(`<h1 id="duktape-1-0-release-notes" tabindex="-1">Duktape 1.0 release notes <a class="header-anchor" href="#duktape-1-0-release-notes" aria-label="Permalink to &quot;Duktape 1.0 release notes&quot;">​</a></h1><h2 id="release-overview" tabindex="-1">Release overview <a class="header-anchor" href="#release-overview" aria-label="Permalink to &quot;Release overview&quot;">​</a></h2><p>First release with a stable API. This release will get bug fixes at least until 1.1.0 is released (and probably some time beyond that).</p><p><strong>This release is now obsolete, please upgrade to Duktape 1.1.x which has several critical fixes not present in 1.0.x.</strong></p><h2 id="known-issues" tabindex="-1">Known issues <a class="header-anchor" href="#known-issues" aria-label="Permalink to &quot;Known issues&quot;">​</a></h2><p>This release has the following known issues worth noting.</p><h3 id="ecmascript-features" tabindex="-1">ECMAScript features <a class="header-anchor" href="#ecmascript-features" aria-label="Permalink to &quot;ECMAScript features&quot;">​</a></h3><ul><li>Non-compliant behavior for array indices near 2G or 4G elements.</li><li>RegExp parser is strict and won&#39;t accept some real world RegExps which are technically not compliant with ECMAScript E5/E5.1 specification.</li><li>Final mantissa bit rounding issues in the internal number-to-string conversion.</li><li>If a function contains a lot of constants (over 511 strings or non-integers), the compiler fails to compile a try-catch statement. The workaround is to place the try-catch in a separate function outside the problematic function.</li></ul><h3 id="portability-and-platforms" tabindex="-1">Portability and platforms <a class="header-anchor" href="#portability-and-platforms" aria-label="Permalink to &quot;Portability and platforms&quot;">​</a></h3><ul><li>On some older clang/llvm versions (e.g. Clang 3.3 on FreeBSD 10): when <code>-m32</code> is used, Duktape will end up using the 8-byte packed value representation but clang will generate incorrect code for union assignment (see <code>misc/clang_aliasing.c</code>). The issue can be detected by defining <code>DUK_OPT_SELF_TESTS</code>. A workaround is to avoid packed types in this case by defining <code>DUK_OPT_NO_PACKED_TVAL</code>.</li><li>On some older clang/llvm versions (e.g. Clang 3.3 on FreeBSD 10): compilation may produce a warning &quot;generic selections are a C11-specific feature&quot;. The warning should be harmless.</li><li>On some older clang/llvm versions (e.g. Clang 3.3 on FreeBSD 10): harmless compilation warning for &quot;duk_repl_isinf&quot; being unused.</li><li>On some GCC versions and compilation options you may get a warning &quot;variable idx_func might be clobbered by longjmp or vfork [-Wclobbered]&quot;. This warning seems spurious and causes no known problems.</li><li>GCC <code>-O4</code> may produce a warning &quot;assuming signed overflow does not occur when assuming that (X - c) &gt; X is always false&quot; for some assertions. This warning seems spurious and causes no known problems.</li><li>GCC <code>-pedantic</code> without -std=c99 causes the <code>unsigned long long</code> type to be used by Duktape, and an associated warning about the type. This is harmless and most easily fixed by simply using <code>-std=c99</code>.</li><li>MinGW and Cygwin GCC compilation produces symbol visibility warnings when compiling Duktape from <code>src-separate</code>.</li><li>On platforms where <code>SIZE_MAX</code> is incorrectly set e.g. as <code>0x7fffffff</code> compilation may fail with <code>#error size_t is too small</code>. This has been fixed in Duktape 1.1.0. (GH-101)</li></ul><h2 id="raw-issues-from-test-runs" tabindex="-1">Raw issues from test runs <a class="header-anchor" href="#raw-issues-from-test-runs" aria-label="Permalink to &quot;Raw issues from test runs&quot;">​</a></h2><h3 id="api-tests" tabindex="-1">API tests <a class="header-anchor" href="#api-tests" aria-label="Permalink to &quot;API tests&quot;">​</a></h3><pre><code>test-to-number.c: fail; 15 diff lines; known issue: number parsing bug for strings containing NUL characters (e.g. &#39;&#39;)
</code></pre><h3 id="ecmascript-tests" tabindex="-1">ECMAScript tests <a class="header-anchor" href="#ecmascript-tests" aria-label="Permalink to &quot;ECMAScript tests&quot;">​</a></h3><pre><code>test-bi-date-tzoffset-brute-fi: fail; 12 diff lines; known issue: year 1970 deviates from expected, Duktape uses equiv. year for 1970 on purpose at the moment; requires special feature options: test case has been written for Finnish locale
test-bi-function-nonstd-caller-prop: fail; 178 diff lines; requires special feature options: DUK_OPT_NONSTD_FUNC_CALLER_PROPERTY
test-bi-global-parseint-oct: fail; 20 diff lines; known issue: non-standard octal behavior does not match V8/Rhino
test-bi-global-parseint: fail; 108 diff lines; known issue: rounding differences for parsing integers larger than 2^53
test-bi-json-dec-types: fail; 21 diff lines; known issue: &#39;\\x&#39; should be allowed by eval() but not by JSON.parse(), Duktape rejects &#39;\\x&#39; in both
test-bi-json-enc-proplist-dups: fail; 8 diff lines; known issue: JSON.stringify() can be given a property list to serialize; duplicates should be eliminated but Duktape (and other engines) will happily serialize a property multiple times
test-bi-number-proto-toexponential: fail; 75 diff lines; known issue: corner case rounding errors in toExponential()
test-bi-number-proto-tostring: fail; 46 diff lines; known issue: expect strings to be checked, but probably Duktape rounding issues
test-bi-regexp-gh39: fail; 5 diff lines; known issue: requires leniency for non-standard regexps
test-bug-enum-shadow-nonenumerable: fail; 12 diff lines; known issue: corner case enumeration semantics, not sure what correct behavior is (test262 ch12/12.6/12.6.4/12.6.4-2)
test-bug-error-linenumber-2: fail; 10 diff lines; known issue: in corner cases (related to automatic semicolon insertion) throw statement error linenumber can be unexpected
test-bug-invalid-oct-as-dec: fail; 14 diff lines; known issue: V8/Rhino parse invalid octal constants as decimal values, Duktape doesn&#39;t at the moment
test-bug-json-parse-__proto__: fail; 18 diff lines; known issue: when ES6 __proto__ enabled, JSON.parse() parses &#39;__proto__&#39; property incorrectly when a specially crafted reviver is used
test-bug-labelled-block: fail; 9 diff lines; known issue: label attached to a plain block statement can cause an INVALID opcode error
test-bug-numconv-1e23: fail; 10 diff lines; known issue: corner case in floating point parse rounding
test-bug-numconv-denorm-toprec: fail; 7 diff lines; known issue: in a denormal corner case toPrecision() can output a zero leading digit
test-bug-tonumber-u0000: fail; 7 diff lines; known issue: &#39;\\u0000&#39; should ToNumber() coerce to NaN, but now coerces to zero like an empty string
test-bug-trycatch-many-constants: fail; 5 diff lines; known issue: out of regs for try-catch in Duktape 1.0
test-conv-number-tostring-tonumber-roundtrip: fail; 5 diff lines; known issue: rounding corner cases
test-dev-bound-thread-start-func: fail; 13 diff lines; known issue: initial function of a new coroutine cannot be bound
test-dev-func-cons-args: fail; 18 diff lines; known issue: corner cases for &#39;new Function()&#39; when arguments and code are given as strings
test-dev-labelled-break: fail; 21 diff lines; known issue: label attached to a plain block statement can cause an INVALID opcode error
test-dev-yield-after-callapply: fail; 8 diff lines; known issue: yield() not allowed when function called via Function.prototype.(call|apply)()
test-lex-unterminated-hex-uni-escape: fail; 29 diff lines; known issue: unterminated hex escapes should be parsed leniently, e.g. &#39;\\uX&#39; -&gt; &#39;uX&#39; but Duktape now refuses to parse them
test-numconv-parse-misc: fail; 12 diff lines; known issue: rounding corner case for 1e+23 (parses/prints as 1.0000000000000001e+23)
test-numconv-tostring-gen: fail; 279 diff lines; known issue: rounding corner cases in number-to-string coercion
test-numconv-tostring-misc: fail; 6 diff lines; known issue: rounding corner case, 1e+23 string coerces to 1.0000000000000001e+23
test-regexp-empty-quantified: fail; 15 diff lines; known issue: a suitable empty quantified (e.g. &#39;(x*)*&#39;) causes regexp parsing to terminate due to step limit
test-regexp-invalid-charclass: fail; 7 diff lines; known issue: some invalid character classes are accepted (e.g. &#39;[\\d-z]&#39; and &#39;[z-x]&#39;)
test-regexp-nonstandard-patternchar: fail; 6 diff lines; known issue: other engines allow an unescaped brace to appear literally (e.g. /{/), Duktape does not (which seems correct but is against real world behavior)
test-stmt-for-in: fail; 6 diff lines; known issue: for-in allows some invalid left-hand-side expressions which cause a runtime ReferenceError instead of a compile-time SyntaxError (e.g. &#39;for (a+b in [0,1]) {...}&#39;)
</code></pre><h3 id="test262" tabindex="-1">test262 <a class="header-anchor" href="#test262" aria-label="Permalink to &quot;test262&quot;">​</a></h3><p>See <code>test262-status.rst</code> and <code>test262-known-issues.yaml</code>. With ECMAScript 6 and Intl module tests removed:</p><pre><code>annexB/B.RegExp.prototype.compile in non-strict mode   // KNOWN: RegExp.prototype.compile() not part of E5.1
ch07/7.8/7.8.5/S7.8.5_A1.4_T1 in non-strict mode   // KNOWN: uses invalid RegExp formats, e.g. &#39;/\\1/&#39; and &#39;/\\a/&#39;
ch07/7.8/7.8.5/S7.8.5_A1.4_T2 in non-strict mode   // KNOWN: uses invalid RegExp format &#39;/\\1/&#39; (#0031)
ch07/7.8/7.8.5/S7.8.5_A2.4_T1 in non-strict mode   // KNOWN: uses invalid RegExp format &#39;/\\1/&#39;
ch07/7.8/7.8.5/S7.8.5_A2.4_T2 in non-strict mode   // KNOWN: uses invalid RegExp format &#39;/\\1/&#39; (#0031)
ch15/15.1/15.1.2/15.1.2.2/S15.1.2.2_A5.1_T1 in non-strict mode   // KNOWN: octal input to parseInt() accepted by Duktape
ch15/15.10/15.10.2/S15.10.2_A1_T1 in non-strict mode   // KNOWN: XML Shallow Parsing with Regular Expression: [^]]*]([^]]+])*]+.  The intent of [^]] is probably [^\\]].  An unescaped &#39;]&#39; is not allowed in a character class, so the expression is parsed as [^] (empty inverted class) followed by a literal &#39;]&#39;, which is a SyntaxError.  There are two other literal &#39;]&#39; issues.  The RegExp can be fixed to: /[^\\]]*\\]([^\\]]+\\])*\\]+/.
ch15/15.10/15.10.2/15.10.2.10/S15.10.2.10_A2.1_T3 in non-strict mode   // KNOWN: uses invalid RegExp control escape &#39;\\cX&#39; where X is non-ASCII
ch15/15.10/15.10.2/15.10.2.10/S15.10.2.10_A5.1_T1 in non-strict mode   // KNOWN: possible test case bug, compiles invalid RegExp &#39;/\\undefined/&#39;
ch15/15.10/15.10.2/15.10.2.13/S15.10.2.13_A1_T16 in non-strict mode   // KNOWN: uses invalid DecimalEscape inside a character class, &#39;/[\\12-\\14]/&#39;
ch15/15.10/15.10.2/15.10.2.6/S15.10.2.6_A4_T7 in non-strict mode   // KNOWN: the test case has unescaped invalid PatternCharacters (^, ] {, }) which follow the escaped &#39;\\[&#39;
ch15/15.10/15.10.2/15.10.2.9/S15.10.2.9_A1_T4 in non-strict mode   // KNOWN: invalid backreference &#39;\\2&#39;, RegExp only has one capture; in E5.1 this is a SyntaxError
ch15/15.2/15.2.3/15.2.3.6/15.2.3.6-4-574 in non-strict mode   // KNOWN: Duktape provides property name as a (intended non-standard) second parameter to setter, this testcase tests that no extra parameter is given so it breaks
ch15/15.5/15.5.4/15.5.4.7/S15.5.4.7_A1_T11 in non-strict mode   // KNOWN: test case relies on locale specific Date format, Duktape uses ISO 8601 for Date toString()
ch15/15.9/15.9.3/S15.9.3.1_A5_T1 in non-strict mode   // KNOWN: apparently test case bug
ch15/15.9/15.9.3/S15.9.3.1_A5_T2 in non-strict mode   // KNOWN: apparently test case bug
ch15/15.9/15.9.3/S15.9.3.1_A5_T3 in non-strict mode   // KNOWN: apparently test case bug
ch15/15.9/15.9.3/S15.9.3.1_A5_T4 in non-strict mode   // KNOWN: apparently test case bug
ch15/15.9/15.9.3/S15.9.3.1_A5_T5 in non-strict mode   // KNOWN: apparently test case bug
ch15/15.9/15.9.3/S15.9.3.1_A5_T6 in non-strict mode   // KNOWN: apparently test case bug
ch12/12.6/12.6.1/S12.6.1_A4_T5 in non-strict mode   // diagnosed: INVALID opcode (0)
ch12/12.6/12.6.2/S12.6.2_A4_T5 in non-strict mode   // diagnosed: INVALID opcode (0)
ch12/12.6/12.6.4/12.6.4-2 in non-strict mode   // diagnosed: enumeration corner case issue, see test-bug-enum-shadow-nonenumerable.js
ch15/15.10/15.10.2/15.10.2.5/S15.10.2.5_A1_T5 in non-strict mode   // diagnosed: Duktape bug, matching /(a*)b\\1+/ against &#39;baaaac&#39; causes first capture to match the empty string; the &#39;\\1+&#39; part will then use the &#39;+&#39; quantifier over the empty string.  As there is no handling to empty quantified now, Duktape bails out with a RangeError.
ch15/15.10/15.10.2/15.10.2.9/S15.10.2.9_A1_T5 in non-strict mode   // diagnosed: Duktape bug, matching /(a*)b\\1+/ against &#39;baaac&#39; causes first capture to be empty, the &#39;\\1+&#39; part will then quantify over an empty string leading to Duktape RangeError (there is no proper handling for an empty quantified now)
ch15/15.4/15.4.4/15.4.4.10/S15.4.4.10_A3_T3 in non-strict mode   // diagnosed: probably Duktape bug related to long array corner cases or &#39;length&#39; sign handling (C typing?)
ch15/15.4/15.4.4/15.4.4.12/S15.4.4.12_A3_T3 in non-strict mode   // diagnosed: probably Duktape bug related to long array corner cases or &#39;length&#39; sign handling (C typing?)
ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-5-12 in non-strict mode   // diagnosed: Array length over 2G, not supported right now
ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-5-16 in non-strict mode   // diagnosed: Array length over 2G, not supported right now
ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-9-9 in non-strict mode   // diagnosed: a.indexOf(&lt;n&gt;,4294967290) returns -1 for all indices n=2,3,4,5 but is supposed to return 4294967294 for n=2.  The cause is long array corner case handling, possibly signed length handling (C typing?)
ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-5-12 in non-strict mode   // diagnosed: probably Duktape bug: long array corner cases (C typing?)
ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-5-16 in non-strict mode   // diagnosed: probably Duktape bug: long array corner cases (C typing?)
ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-8-9 in non-strict mode   // diagnosed: probably Duktape bug: long array corner cases (C typing?)
</code></pre>`,18)]))}const f=n(a,[["render",o]]);export{h as __pageData,f as default};
