import{_ as t,c as o,a2 as a,o as r}from"./chunks/framework.DzmM640o.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/guide/coroutines.md","filePath":"resource/duktape/guide/coroutines.md","lastUpdated":1732350347000}'),p={name:"resource/duktape/guide/coroutines.md"};function i(l,e,u,c,n,d){return r(),o("div",null,e[0]||(e[0]=[a('<h2 id="coroutines" tabindex="-1">コルーチン <a class="header-anchor" href="#coroutines" aria-label="Permalink to &quot;コルーチン {#coroutines}&quot;">​</a></h2><p>Duktapeは、単純なコルーチンをサポートしています。コルーチン A はコルーチン B を再開または開始し、コルーチン B は降伏または終了（成功またはキャッチされないエラー）するまで実行し、その後コルーチン A は降伏結果で実行を継続します。</p><p>コルーチンは new Duktape.Thread() で作成され、その唯一の引数は、新しいコルーチンが最初のレジュームで実行を開始する初期関数として取得します。レジューム引数は、初期関数の最初の（そして唯一の）引数値となります。</p><p>Duktape.Thread.resume()は、再開するコルーチン、再開値、（オプションで）再開値が通常の値か、対象のコルーチンに注入されるエラーであるかを示すフラグを引数にとります。エラー投入とは、レジューム値をターゲットコルーチンの最後のyield操作の場所で &quot;throw &quot;することを意味します。つまり、通常の値で戻るのではなく、一見、エラーを投げるように見える。</p><p>Duktape.Thread.yield()は、yieldする値と、（オプションで）yield値が通常の値であるか、再開するコルーチンのコンテキストで投げられるエラーであるかを示すフラグを引数として取ります。言い換えれば、エラー値を指定すると、レジューム操作で通常の値を返す代わりにエラーを投げるように見える。</p><p>コルーチンが正常に存在する場合、すなわち、初期関数が値を返して終了する場合は、戻り値でyieldと同様に処理される。捕捉されないエラーによってコルーチンが存在する場合、それはエラーを伴うyieldと同様に扱われる：再開操作は、再開するコルーチンのコンテキストでそのエラーを再スローする。いずれの場合も、終了したコルーチンはもはや再開することができません; 再開しようとするとTypeErrorが発生します。</p><p>現在、yield が可能な場合、厳しい制限がある。つまり、コルーチンのアクティブなコールスタック全体が ECMAScript から ECMAScript への呼び出しで構成されている場合のみ、降伏が可能です。以下のものは、降伏するコルーチンのコールスタックのどこかに存在する場合、降伏を防ぎます。</p><ul><li>Duktape/C関数呼び出し</li><li>ゲッター/セッター呼び出し</li><li>プロキシ・トラップ呼び出し</li><li>eval() 呼び出し</li><li>ファイナライザー呼び出し</li></ul><blockquote><p>Duktape 2.2以降、コンストラクタ呼び出し（new Func()）、Function.prototype.call()、 Function.prototype.apply() 、 Reflect.apply() 、 Reflect.construct() は yield を防止しなくなった。</p></blockquote><p>例として、コルーチンの使い方を参照してください。</p>',10)]))}const y=t(p,[["render",i]]);export{k as __pageData,y as default};
