import{_ as e,c as t,a2 as r,o as l}from"./chunks/framework.CKGreiRV.js";const c=JSON.parse('{"title":"ベアメタルプラットフォームでの実行方法","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/wiki/how_to_run_on_bare_metal_platforms.md","filePath":"resource/duktape/wiki/how_to_run_on_bare_metal_platforms.md","lastUpdated":1732350347000}'),o={name:"resource/duktape/wiki/how_to_run_on_bare_metal_platforms.md"};function i(p,a,s,n,u,m){return l(),t("div",null,a[0]||(a[0]=[r('<h1 id="ベアメタルプラットフォームでの実行方法" tabindex="-1">ベアメタルプラットフォームでの実行方法 <a class="header-anchor" href="#ベアメタルプラットフォームでの実行方法" aria-label="Permalink to &quot;ベアメタルプラットフォームでの実行方法&quot;">​</a></h1><p>ベアメタルプラットフォームは通常、最小限のリアルタイムオペレーティングシステム（RTOS）か、従来のオペレーティングシステムが全く動作しないものです。ページング、メモリ割り当てプリミティブ、ファイルシステムなど、通常のサービスはまったく利用できないかもしれません。割り込みハンドラもなく、すべてのコードがビジーポーリング・ビットバンギングループで実行されているかもしれません。通常、libc は存在しないか、その一部 (多くの場合、非準拠) のみです。</p><p>Duktape はベアメタルターゲットで動作するように設計されています。 プラットフォーム依存は慎重に最小化され、プラットフォーム関数へのアクセスはすべて duk_config.h で定義されたラッパー・マクロを介して行われます。そのため、これらはカスタムプロバイダーで簡単に置き換えることができます。</p><p>この文書では、ベアメタルターゲット上で Duktape をコンパイルし、実行する際の通常の問題について説明します。こちらもご覧ください。</p><ul><li><a href="https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst</a></li></ul><h2 id="フットプリントへの期待" tabindex="-1">フットプリントへの期待 <a class="header-anchor" href="#フットプリントへの期待" aria-label="Permalink to &quot;フットプリントへの期待&quot;">​</a></h2><p>Duktapeの設定オプションは、最終的なフットプリントに大きな影響を与えます。以下の構成は、ARMプラットフォームで約160kBにコンパイルされ、32kBのRAMで（非常に最小限の）動作が可能です。</p><ul><li>最小限のRTOSです。</li><li>Duktapeは、ES5ベースの最小限の低メモリ構成で、RegExpsやコルーチンなどは無効化されています。sin()のような超越数学関数は、関連する大規模なlibcコードを避けるために無効化されています。カスタム日付プロバイダ。</li><li>libc の大規模な実装を避けるための最小限の s(n)printf() と sscanf() の置き換え: <a href="https://github.com/svaarala/duktape/tree/master/extras/minimal-printf" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/tree/master/extras/minimal-printf</a>.</li><li>シンプルなプールアロケータ: <a href="https://github.com/svaarala/duktape/tree/master/extras/alloc-pool" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/tree/master/extras/alloc-pool</a>.</li><li>setjmp()、longjmp()、そしてサードパーティの libc 実装によって提供される様々なオッズアンドエンド。</li><li>いくつかのネイティブバインディング、例えばシリアルリード/ライトバインディング、LEDフラッシュ。</li></ul><p>ECMAScriptのビルトインバインディングを削除することで、160kBを大きく下回るフットプリントを実現することが可能です。</p><ul><li>例えば、Duktape master の &quot;stripped&quot; ビルドでは、コマンドラインの eval ツールを x86 で 80kB 未満にコンパイルできます (libc などは含まれません)。しかし、Array.prototype.forEach()のようなビルトインは、このビルドには含まれていません。YAMLメタデータを使えば、特定のバインディングだけを削除するなど、より正確にバインディングをカスタマイズすることができます。</li></ul><h2 id="典型的な移植の手順" tabindex="-1">典型的な移植の手順 <a class="header-anchor" href="#典型的な移植の手順" aria-label="Permalink to &quot;典型的な移植の手順&quot;">​</a></h2><h2 id="コンフィギュレーションと-duk-config-h" tabindex="-1">コンフィギュレーションと duk_config.h <a class="header-anchor" href="#コンフィギュレーションと-duk-config-h" aria-label="Permalink to &quot;コンフィギュレーションと duk_config.h&quot;">​</a></h2><ul><li>カスタム設定を作成するには tools/configure.py を使用します。<a href="https://github.com/svaarala/duktape/blob/master/config/examples/low_memory.yaml" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/config/examples/low_memory.yaml</a> にある低メモリ設定は、妥当な出発点です。</li><li>YAML config フォーマットを使って、Duktape の設定にカスタムの微調整を加える。</li><li>存在しない、あるいは避けるべきプラットフォーム関数を再定義するために、fixupヘッダを使用します。例えば、<code>#undef DUK_FLOOR #define DUK_FLOOR my_floor_replacement</code> といった具合です。</li><li>Duktapeのコンパイルがそのプロトタイプを知ることができるように、カスタム置換の宣言を提供するためにfixupヘッダを使用します： <code>extern double my_floor_replacement(double x);</code> 。</li><li>標準的なヘッダーが利用できない場合、duk_config.h を編集して、問題のある #include 行を削除する必要があるかもしれません。genconfig にカスタムプラットフォームを追加し、そのプラットフォーム用の duk_config.h を作成することで、よりきれいにこれを達成することができます。</li><li>Date 組み込みは、非常に頻繁に置き換える必要があります。</li><li><a href="https://github.com/svaarala/duktape/blob/master/doc/datetime.rst#implementing-an-external-date-provider" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/doc/datetime.rst#implementing-an-external-date-provider</a></li><li><a href="https://github.com/svaarala/duktape/tree/master/examples/dummy-date-provider" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/tree/master/examples/dummy-date-provider</a></li><li>RAM が非常に厳しい場合、&quot;ROM built-ins &quot;オプションにより、組み込みのバインディング・ オブジェクト（例えば Math, Math.cos, Array）を読み取り専用のコードセクションに コンパイルすることができます。これにより、パックド・ポインタも使用する場合、Duktapeは約3kBのRAMで起動することができます。ただし、ROM内蔵を使用すると、コードのフットプリントが大きくなります。</li></ul><h3 id="コンパイルと実行" tabindex="-1">コンパイルと実行 <a class="header-anchor" href="#コンパイルと実行" aria-label="Permalink to &quot;コンパイルと実行&quot;">​</a></h3><p>これは明らかにコンパイラに依存しますが、フットプリントを最小にするオプションを使用すること、最終的なリンクで未使用の関数を削除することなどが重要です。例えば、以下を参照してください。</p><ul><li><a href="https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst#optimizing-code-footprint" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst#optimizing-code-footprint</a></li></ul><p>フラッシュから直接コードを実行するには、「execute in place」を有効にする必要がある場合があります。</p>',17)]))}const h=e(o,[["render",i]]);export{c as __pageData,h as default};
