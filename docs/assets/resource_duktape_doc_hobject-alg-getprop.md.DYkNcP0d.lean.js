import{_ as o,c,a2 as t,o as d}from"./chunks/framework.CKGreiRV.js";const u=JSON.parse('{"title":"GETPROP: exposed property get algorithm","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-getprop.md","filePath":"resource/duktape/doc/hobject-alg-getprop.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/hobject-alg-getprop.md"};function r(a,e,n,s,l,h){return d(),c("div",null,e[0]||(e[0]=[t(`<h1 id="getprop-exposed-property-get-algorithm" tabindex="-1">GETPROP: exposed property get algorithm <a class="header-anchor" href="#getprop-exposed-property-get-algorithm" aria-label="Permalink to &quot;GETPROP: exposed property get algorithm&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>Consider the following expression:</p><pre><code>x = y[z]
</code></pre><p>The following happens compile time:</p><ul><li><code>z</code> is parsed as an identifier reference</li><li><code>y</code> is parsed as an identifier reference</li><li><code>y[z]</code> is parsed as a property accessor (E5 Section 11.2.1)</li><li>When the simple assignment is parsed, the <code>y[z]</code> compiler knows that the property accessor is used as a right-hand-side value, so it emits whatever internal bytecode is required to read the property value during execution</li></ul><p>The following happens run time:</p><ul><li>The compiled code contains the sequence described in E5 Section 11.2.1: <ul><li><code>baseValue = GetValue(y)</code>, where <code>y</code> is the identifier reference</li><li><code>propertyNameValue = GetValue(z)</code>, where <code>z</code> is the identifier reference</li><li><code>CheckObjectCoercible(baseValue)</code>, which throws a <code>TypeError</code> if the <code>baseValue</code> is <code>null</code> or <code>undefined</code></li><li>Create a property reference with <code>baseValue</code> as the base reference and <code>ToString(propertyNameValue)</code> as the property name (and strict flag based on current code strictness)</li></ul></li><li>Call <code>GetValue()</code> for the property reference. This results in the following sub-steps of E5 Section 8.7.1 to be executed: <ul><li><code>base</code> is the result of <code>GetValue(y)</code> (identifier lookup result directly)</li><li>The referenced name is <code>ToString(GetValue(z))</code> (identifier lookup result with coercion)</li><li>If <code>base</code> is not a primitive: use <code>[[Get]]</code> directly for <code>base</code> and the referenced name</li><li>Else use a variant for <code>[[Get]]</code></li></ul></li></ul><p>The <code>[[Get]]</code> variant for a primitive base is specified explicitly in E5 Section 8.7.1. This seems a bit odd, as it seems equivalent to:</p><ul><li>Let <code>O</code> be <code>ToObject(base)</code></li><li>Call <code>[[Get]]</code> for <code>O</code> and referenced name</li></ul><p>However, <em>this is not the case</em>. There is a subtle difference in the case that the property is an accessor. Normally the <code>this</code> binding for the getter is the object given to <code>[[Get]]</code>. Here the <code>this</code> binding is the <em>uncoerced primitive value</em>.</p><p>This leads to externally visible behavior, illustrated in the following:</p><pre><code>// add test getter
Object.defineProperty(String.prototype, &#39;test&#39;, {
  get: function() { print(typeof this); },
  set: function(x) { print(typeof this); },
});

&quot;foo&quot;.test;  // prints &#39;string&#39;

var s = new String(&quot;foo&quot;);
s.test;      // prints &#39;object&#39;
</code></pre><p>Behavior in ECMAScript implementations seems to vary:</p><ul><li>NodeJS / V8: prints &#39;string&#39; and &#39;object&#39; as expected</li><li>Rhino: prints &#39;object&#39; and &#39;object&#39;</li><li>Smjs: prints &#39;object&#39; and &#39;object&#39;</li></ul><p><code>GetValue()</code> allows the caller to skip creation of the coerced object (which is one of: a <code>Boolean</code>, a <code>Number</code>, or a <code>String</code>; see E5 Section 9.9, <code>ToObject()</code>).</p><p>Note: the replacement <code>[[Get]]</code> overrides whatever <code>[[Get]]</code> function would normally be used for the target object. For instance, if there were some primitive-to-object coercion which created an arguments object, the arguments object exotic <code>[[Get]]</code> behavior would be skipped. However, since the arguments and <code>Function</code> objects are the only objects with non-default <code>[[Get]]</code>, this is not an issue in practice.</p><h2 id="first-draft" tabindex="-1">First draft <a class="header-anchor" href="#first-draft" aria-label="Permalink to &quot;First draft&quot;">​</a></h2><p>When the property accessor is created, the base reference and property name are &quot;coerced&quot; to a value using <code>GetValue()</code>. In the example above, this causes <code>x</code>&#39;s and <code>foo</code>&#39;s values to be looked up. These correspond to steps 1-4 of the property accessor expression in E5 Section 11.2.1. When compiling, these are converted into whatever code is necessary to fetch the two values into VM registers.</p><p>The relevant part begins after that in steps 5-8, which first perform some coercions and then create a property accessor. The accessor is then acted upon by <code>GetValue()</code>, and ultimately <code>[[Get]]</code> or its variant.</p><p>Combining all of these, we get the first draft (for base value <code>O</code> and property name value <code>P</code>):</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible getter call.)</li><li>Call <code>CheckObjectCoercible</code> with <code>O</code> as argument. In practice: if <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>.</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li>Let <code>O</code> be <code>ToObject(O)</code>. (This is side effect free.)</li><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>Notes:</p><ul><li><p>Steps 2-3 come from the property accessor evaluation rules in E5 Section 11.2.1. In particular, <code>CheckObjectCoercible()</code> is called before the key is coerced to a string. Since the key string coercion may have side effects, the order of evaluation matters.</p><p>Note that <code>ToObject()</code> has no side effects (this can be seen from a case by case inspection), so steps 3 and 4 can be reversed.</p></li><li><p>Step 4 comes from <code>GetValue()</code>.</p></li><li><p>Steps 5 and forward come from <code>[[Get]]</code>; here with exotic behaviors inlined, but <code>[[GetProperty]]</code> not inlined.</p></li></ul><p>We could inline the <code>[[GetProperty]]</code> call to the algorithm. However, because the current implementation doesn&#39;t do so, that has been omitted for now.</p><h2 id="improving-type-checking-of-base-value" tabindex="-1">Improving type checking of base value <a class="header-anchor" href="#improving-type-checking-of-base-value" aria-label="Permalink to &quot;Improving type checking of base value&quot;">​</a></h2><p>A variant where steps 3 and 4 are reversed and expanded is as follows:</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part.) b. Else if <code>O</code> is a boolean, a number, or a string, set <code>O</code> to <code>ToObject(O)</code>. c. Else if <code>O</code> is an object, do nothing. d. Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-c are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><h2 id="avoiding-temporary-objects" tabindex="-1">Avoiding temporary objects <a class="header-anchor" href="#avoiding-temporary-objects" aria-label="Permalink to &quot;Avoiding temporary objects&quot;">​</a></h2><p>If the base value is not an object, step 4 in the above algorithm creates a temporary object given to <code>[[GetProperty]]</code> for a property descriptor lookup. The first object in the prototype chain is the temporary object, while the rest are already established non-temporary objects.</p><p>If we knew that the property <code>P</code> could never be an <em>own property</em> of the temporary object, we could skip creation of the temporary object altogether. Instead, we could simply start <code>[[GetProperty]]</code> from the internal prototype that the coerced object would get without actually creating the object.</p><p>Since the coerced object is created by <code>ToObject</code> from a primitive value, we know that it is a <code>Boolean</code> instance, a <code>Number</code> instance, or a <code>String</code> instance (see E5 Section 9.9). The &quot;own properties&quot; of these are:</p><ul><li><code>Boolean</code>: none</li><li><code>Number</code>: none</li><li><code>String</code>: <code>&quot;length&quot;</code> and index properties for string characters</li></ul><p>So, the coercion can be skipped safely for everything except <code>String</code>s. This is unfortunate, because it is conceivably the string primitive value which is most likely to be accessed through a coercion, e.g. as in:</p><pre><code>var t = &quot;my string&quot;;
print(t.length);
</code></pre><p>In any case, avoiding temporary creation for everything but <code>Strings</code> can be worked into the algorithm e.g. as follows:</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original fora possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part.) b. If <code>O</code> is a boolean: set <code>O</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>O</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string, set <code>O</code> to <code>ToObject(O)</code>. e. Else if <code>O</code> is an object, do nothing. f. Else, throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li>If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>If we change step 2.d to get the related string value (length or character of the string) directly, no temporaries need to be created due to coercion. However, if the property name <code>P</code> is checked, it needs to be string coerced which happens only later in step 3. If we add a separate coercion to step 2.d, <code>P</code> will be coerced twice unless step 3 is then explicitly skipped; this is not an issue as the latter coercion is a NOP and can in any case be easily skipped.</p><p>This variant is as follows:</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part.) b. If <code>O</code> is a boolean: set <code>O</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>O</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 2. If <code>P</code> is <code>length</code>, return the length of the primitive string value as a number. 3. If <code>P</code> is a valid array index within the string length, return a one-character substring of the primitive string value at the specified index. 4. Else, set <code>O</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 5. Goto LOOKUP. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object, do nothing. f. Else, throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>LOOKUP:</strong> If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><h2 id="fast-path-for-array-indices" tabindex="-1">Fast path for array indices <a class="header-anchor" href="#fast-path-for-array-indices" aria-label="Permalink to &quot;Fast path for array indices&quot;">​</a></h2><p>When the property name is a number and a <em>valid array index</em>, we&#39;d prefer to be able to lookup the property without coercing the number to a string. This &quot;fast path&quot; needs to work for the common cases; rare cases can go through the ordinary algorithm which requires a <code>ToString()</code> coercion.</p><p>There are many ways to do a (compliant) fast path. The simple case we&#39;re considering here is the case when the target object has an &quot;own property&quot; matching the property name (a number).</p><p>A simple &quot;shallow fast path&quot; could be:</p><ul><li>If <code>P</code> is a whole number in the range [0,2**32-2] (a valid array index) AND <code>O</code> has an array part AND <code>O</code> has no conflicting &quot;exotic behaviors&quot;, then: <ul><li>Let <code>idx</code> be the array index represented by <code>P</code></li><li>If the array part of <code>O</code> contains <code>idx</code> and the key exists, read and return the value. Note that the value can be <code>undefined</code></li></ul></li><li>Else use normal algorithm.</li></ul><p>Some notes:</p><ul><li><p>The behavior of the fast path must match the behavior of the normal algorithm exactly (including side effects). This should be the case here, but can be verified by simulating the normal algorithm with the assumption of a number as a property name, with the target property present as an &quot;own data property&quot; of the target object.</p></li><li><p>The conflicting exotic behaviors are currently: <code>String</code> object exotic behavior, and arguments object exotic behavior. Array exotic behaviors are not conflicting for read operations.</p></li><li><p>A certain key in the array can be defined even if the value is <code>undefined</code>. The check is whether the key has been defined, i.e. <code>[[HasProperty]]</code> would be true. Internally, the value &quot;unused&quot; is used to denote unused entries with unused keys, while the value &quot;undefined&quot; represents an undefined value with a defined key. For instance, the following defines an array key:</p><pre><code>var a = [];
a[10] = undefined;  // &quot;10&quot; will now enumerate
</code></pre></li><li><p>The fast path avoids the <code>ToString()</code> coercion which <em>may</em>, in general, have side effects (at least for objects). However, the fast path only applies if <code>P</code> is a number, and the <code>ToString()</code> coercion of a number is side effect free.</p></li><li><p>If the array part does <em>not</em> contain the key, the normal algorithm is always used, regardless of whether the ancestors contain the key or not. This means that if a non-existent key is accessed from the array (even if the index is within the current array length), string interning will be required with this fast path. For instance:</p><pre><code>var a = [];
a[0] = &#39;foo&#39;;
a[2] = &#39;bar&#39;;

// fast path ok, no string interning
print(a[0]);

// fast path fails, string interned but still not found
print(a[1]);
</code></pre></li></ul><p>Inlining the above shallow fast path with the variant which avoids temporaries altogether produces:</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part.) b. If <code>O</code> is a boolean: set <code>O</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>O</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 2. If <code>P</code> is <code>length</code>, return the length of the primitive string value as a number. 3. If <code>P</code> is a valid array index within the string length, return a one-character substring of the primitive string value at the specified index. 4. Else, set <code>O</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 5. Goto LOOKUP. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: 1. Array fast path: If <code>O</code> is an object (always true here) AND <code>P</code> is a number and a valid array index (whole number in [0,2**32-2]) AND <code>O</code> internal representation has an array part AND <code>O</code> does not have conflicting exotic behaviors (cannot have <code>String</code> or arguments exotic behaviors, may have <code>Array</code> behavior), then: a. Let <code>idx</code> be the array index represented by <code>P</code> b. If the array part of <code>O</code> contains <code>idx</code> and the key exists, read and return that value. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>LOOKUP:</strong> If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>We can further improve this by adding a fast path for the case where <code>O</code> is a primitive string (in step 2.d):</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original fora possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part; the throw is unconditional.) b. If <code>O</code> is a boolean: set <code>O</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>O</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. If <code>P</code> is a number, is a whole number, a valid array index, and within the string length, return a one-character substring of the primitive string value at the specified index. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) 2. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 3. If <code>P</code> is <code>length</code>, return the length of the primitive string value as a number. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 4. If <code>P</code> is a valid array index within the string length, return a one-character substring of the primitive string value at the specified index. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 5. Else, set <code>O</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 6. Goto LOOKUP. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: 1. Array fast path: If <code>O</code> is an object (always true here) AND <code>P</code> is a number and a valid array index (whole number in [0,2**32-2]) AND <code>O</code> internal representation has an array part AND <code>O</code> does not have conflicting exotic behaviors (cannot have <code>String</code> or arguments exotic behaviors, may have <code>Array</code> behavior), then: a. Let <code>idx</code> be the array index represented by <code>P</code> b. If the array part of <code>O</code> contains <code>idx</code> and the key exists, read and return that value. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>LOOKUP:</strong> If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument.</li><li>Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>We can also move step 4 (arguments exotic behavior) to step 2.e. This has the problem that step 4 assumes <code>P</code> has been string coerced already. So, a duplicate coercion is needed (like for strings):</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible getter call.)</li><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part; the throw is unconditional.) b. If <code>O</code> is a boolean: set <code>O</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>O</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. If <code>P</code> is a number, is a whole number, a valid array index, and within the string length, return a one-character substring of the primitive string value at the specified index. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) 2. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 3. If <code>P</code> is <code>length</code>, return the length of the primitive string value as a number. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 4. If <code>P</code> is a valid array index within the string length, return a one-character substring of the primitive string value at the specified index. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 5. Set <code>O</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 6. Goto LOOKUP. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: 1. Array fast path: If <code>O</code> is an object (always true here) AND <code>P</code> is a number and a valid array index (whole number in [0,2**32-2]) AND <code>O</code> internal representation has an array part AND <code>O</code> does not have conflicting exotic behaviors (cannot have <code>String</code> or arguments exotic behaviors, may have <code>Array</code> behavior), then: a. Let <code>idx</code> be the array index represented by <code>P</code>. b. If the array part of <code>O</code> contains <code>idx</code> and the key exists, read and return that value. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) 2. If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. Set <code>P</code> to <code>ToString(P)</code>. b. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. c. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument. d. Else, goto LOOKUP. (Avoid double coercion of <code>P</code>.) f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>LOOKUP:</strong> Let <code>desc</code> be the result of calling the <code>[[GetProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>, return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>orig</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>orig</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><p>::: note ::: title Note :::</p><p>The above is the current &quot;shallow fast path&quot; approach, which has a couple of annoying limitations. For instance, if the array index is not used, the key will be coerced to string (regardless of whether ancestors have the key or not). Many improvements are possible; these are future work. :::</p><h2 id="inlining-getproperty" tabindex="-1">Inlining GetProperty <a class="header-anchor" href="#inlining-getproperty" aria-label="Permalink to &quot;Inlining GetProperty&quot;">​</a></h2><p>Inlining <code>[[GetProperty]]</code> (but not <code>[[GetOwnProperty]]</code>), maintaining the original input value in <code>O</code> instead of <code>orig</code>, and using <code>curr</code> instead of <code>O</code> otherwise, we get:</p><ol><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part; the throw is unconditional.) b. If <code>O</code> is a boolean: set <code>curr</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>curr</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. If <code>P</code> is a number, is a whole number, a valid array index, and within the string length, return a one-character substring of the primitive string value at the specified index. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) 2. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 3. If <code>P</code> is <code>length</code>, return the length of the primitive string value as a number. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 4. If <code>P</code> is a valid array index within the string length, return a one-character substring of the primitive string value at the specified index. (Note: The <code>&quot;caller&quot;</code> check for <code>P</code> is skipped, but would never match.) 5. Set <code>curr</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 6. Goto NEXT. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: 1. Set <code>curr</code> to <code>O</code>. 2. Array fast path: If <code>O</code> is an object (always true here) AND <code>P</code> is a number and a valid array index (whole number in [0,2**32-2]) AND <code>O</code> internal representation has an array part AND <code>O</code> does not have conflicting exotic behaviors (cannot have <code>String</code> or arguments exotic behaviors, may have <code>Array</code> behavior), then: a. Let <code>idx</code> be the array index represented by <code>P</code>. b. If the array part of <code>O</code> contains <code>idx</code> and the key exists, read and return that value. (Note: <code>ToString(P)</code> is skipped, but it would have no side effects as <code>P</code> is a number. The <code>&quot;caller&quot;</code> check for <code>P</code> is also skipped, but it would never match because <code>P</code> is a number.) 3. If <code>O</code> is an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. Set <code>P</code> to <code>ToString(P)</code>. b. (Arguments object exotic behavior.) Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. c. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>: 1. Return the result of calling the <code>[[Get]]</code> internal method of <code>map</code> passing <code>P</code> as the argument. d. Else, goto NEXT. (Avoid double coercion of <code>P</code>.) f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the [[GetOwnProperty]] internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. Return <code>undefined</code>.</li><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>: a. Let <code>res</code> be <code>desc.[[Value]]</code>.</li><li>Otherwise, <code>IsAccessorDescriptor(desc)</code> must be <code>true</code>: a. Let <code>getter</code> be <code>desc.[[Get]]</code>. b. If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>. c. Else let <code>res</code> be the result of calling the <code>[[Call]]</code> internal method of <code>getter</code> providing <code>O</code> as the <code>this</code> value and providing no arguments. (Note: the difference to a basic <code>[[Get]]</code> is that the getter <code>this</code> binding is the original, uncoerced object.)</li><li>If <code>O</code> is a <code>Function</code> object or an <code>arguments</code> object which contains a <code>[[ParameterMap]]</code> internal property: a. (Arguments or Function object exotic behavior.) If <code>P</code> is <code>&quot;caller&quot;</code> and <code>res</code> is a strict mode <code>Function</code> object, throw a <code>TypeError</code> exception.</li><li>Return <code>res</code>.</li></ol><h2 id="final-version" tabindex="-1">Final version <a class="header-anchor" href="#final-version" aria-label="Permalink to &quot;Final version&quot;">​</a></h2><p>(See above.)</p>`,60)]))}const f=o(i,[["render",r]]);export{u as __pageData,f as default};
