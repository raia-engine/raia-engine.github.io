import{_ as t,c as r,a2 as a,o as i}from"./chunks/framework.DPuwY6B9.js";const f=JSON.parse('{"title":"Buffers","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/buffers.md","filePath":"resource/duktape/doc/buffers.md","lastUpdated":1732350347000}'),o={name:"resource/duktape/doc/buffers.md"};function n(s,e,l,d,p,u){return i(),r("div",null,e[0]||(e[0]=[a(`<h1 id="buffers" tabindex="-1">Buffers <a class="header-anchor" href="#buffers" aria-label="Permalink to &quot;Buffers&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>ECMAScript did not originally have a binary array (or binary string) data type so various approaches are used:</p><ul><li><p>Khronos typed array:</p><ul><li><a href="https://www.khronos.org/registry/typedarray/specs/latest/" target="_blank" rel="noreferrer">https://www.khronos.org/registry/typedarray/specs/latest/</a></li><li><code>svn co -r 30720 https://cvs.khronos.org/svn/repos/registry/trunk/public/typedarray</code></li><li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noreferrer">https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays</a></li><li><a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/" target="_blank" rel="noreferrer">http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/</a></li><li><a href="http://clokep.blogspot.fi/2012/11/javascript-typed-arrays-pain.html" target="_blank" rel="noreferrer">http://clokep.blogspot.fi/2012/11/javascript-typed-arrays-pain.html</a></li><li><a href="http://blogs.msdn.com/b/ie/archive/2011/12/01/working-with-binary-data-using-typed-arrays.aspx" target="_blank" rel="noreferrer">http://blogs.msdn.com/b/ie/archive/2011/12/01/working-with-binary-data-using-typed-arrays.aspx</a></li><li><a href="https://www.inkling.com/read/javascript-definitive-guide-david-flanagan-6th/chapter-22/typed-arrays-and-arraybuffers" target="_blank" rel="noreferrer">https://www.inkling.com/read/javascript-definitive-guide-david-flanagan-6th/chapter-22/typed-arrays-and-arraybuffers</a></li></ul></li><li><p>ES2015 has adopted the Khronos specification, with more specific semantics:</p><ul><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arraybuffer-constructor" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arraybuffer-constructor</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-typedarray-constructors" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-typedarray-constructors</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arraybuffer-objects" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arraybuffer-objects</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview-objects" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview-objects</a></p><p>These section links point to specific built-ins but link to the above:</p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-constructor-properties-of-the-global-object-arraybuffer" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-constructor-properties-of-the-global-object-arraybuffer</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-constructor-properties-of-the-global-object-dataview" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-constructor-properties-of-the-global-object-dataview</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint8array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint8array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint8clampedarray" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint8clampedarray</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint16array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint16array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint32array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-uint32array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int8array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int8array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int16array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int16array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int32array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-int32array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-float32array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-float32array</a></p></li><li><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-float64array" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-float64array</a></p><p>ES2015 spec:</p></li><li><p><a href="http:/www.ecma-international.org/ecma-262/6.0/index.html/" target="_blank" rel="noreferrer">http:/www.ecma-international.org/ecma-262/6.0/index.html/</a></p></li></ul></li><li><p>Node.js Buffer:</p><ul><li><a href="http://nodejs.org/api/buffer.html" target="_blank" rel="noreferrer">http://nodejs.org/api/buffer.html</a></li><li><a href="https://nodejs.org/docs/v6.9.1/api/buffer.html" target="_blank" rel="noreferrer">https://nodejs.org/docs/v6.9.1/api/buffer.html</a></li><li><a href="https://github.com/joyent/node/blob/master/lib/buffer.js" target="_blank" rel="noreferrer">https://github.com/joyent/node/blob/master/lib/buffer.js</a></li></ul></li><li><p>Duktape has a custom plain buffer type which has a minimal memory footprint:</p><ul><li>The plain buffer data type which can point to a fixed size buffer, a dynamic (resizable) buffer, or an external (user allocated) buffer.</li><li>The plain buffer behaves like Uint8Array for ECMAScript code but maintains separate typing in the C API. It object coerces to an actual <code>Uint8Array</code> sharing the same underlying storage.</li></ul></li><li><p>Blob; not very relevant for Duktape:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/Blob</a></li></ul></li></ul><p>This document describes how various buffer types have been implemented in Duktape. The goal is to minimize footprint, so the internal buffer type implementation shares a lot of code even though multiple APIs are provided.</p><h2 id="duktape-buffer-support" tabindex="-1">Duktape buffer support <a class="header-anchor" href="#duktape-buffer-support" aria-label="Permalink to &quot;Duktape buffer support&quot;">​</a></h2><h3 id="overview-1" tabindex="-1">Overview <a class="header-anchor" href="#overview-1" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>Duktape currently supports the following buffer and buffer-related values:</p><ul><li>Plain Duktape buffer</li><li>Node.js Buffer object</li><li>ArrayBuffer, DataView, and TypedArray (Uint8Array etc) objects</li></ul><p>The plain buffer value forms the basic underlying type for all the other buffer types; the relationship is similar to a plain string and a String object. Plain buffers can be fixed, dynamic, or external:</p><ul><li>Fixed buffers cannot be resized but have a stable data pointer.</li><li>Dynamic buffers can be resized at the cost of an unstable data pointer. You can also &quot;steal&quot; the current buffer allocation through the duk_steal_buffer() API call.</li><li>External buffers point to user-allocated external data area whose pointer and length can be changed but Duktape won&#39;t resize or automatically free the buffer.</li></ul><p>Plain buffers have Uint8Array-like virtual properties for buffer byte indices, .length, .byteOffset, .byteLength, and .BYTES_PER_ELEMENT. Assignment has the same semantics as Uint8Array: bytes are written with modulo 256 semantics, bytes read back as unsigned 8-bit values. The plain buffer type is designed to be as friendly as possible for low level embedded programming, and has a minimal footprint because there&#39;s no ECMAScript object associated with it. It is mostly intended to be accessed from C code. Duktape also uses buffer values internally.</p><p>The various buffer and view objects ultimately point to an underlying buffer and provide access to the full buffer or a slice/view of the buffer using either accessor methods (like getUint32()) or virtual index properties.</p><p>All buffer objects are internally implemented using the <code>duk_hbufobj</code> type which makes it easy to mix values between different APIs. As a result Duktape e.g. accepts a Node.js Buffer as an input for a Khronos DataView.</p><h3 id="duk-hbufobj" tabindex="-1">duk_hbufobj <a class="header-anchor" href="#duk-hbufobj" aria-label="Permalink to &quot;duk_hbufobj&quot;">​</a></h3><p>The internal <code>duk_hbufobj</code> type is a heap-allocated structure extended from <code>duk_hobject</code>. In addition having the usual object property tables and such, it has C struct fields for quick access:</p><ul><li>A reference to an underlying plain buffer value (<code>duk_hbuffer</code>), which may be of any type: fixed, dynamic, or external.</li><li>A byte offset/length pair providing a window into the underlying buffer. These values directly map to the virtual <code>byteOffset</code> and <code>byteLength</code> properties.</li><li>An element type and a shift count. These provide enough information to support Khronos TypedArray views so that index values can be mapped to byte offsets and encoded/decoded appropriately. The virtual <code>length</code> property indicates the number of <em>elements</em> (not bytes) available, and is provided by dividing the byte length field with the element size (rounding downwards). The virtual <code>BYTES_PER_ELEMENT</code> is provided based on the element shift count (as &quot;1 &lt;&lt; shift&quot;).</li></ul><p>The following figure illustrates these for a fictional Int16-view:</p><pre><code>:  0  1: 2  3  4  5  6  7  8  9 10 11:12 13 14 15 :
+------+-----------------------------+------------+
| xx xx:xx xx xx xx xx xx xx xx xx xx:xx xx xx xx |   underlying buffer
+------+-----------------------------+------------+   (16 bytes)
       :     :     :     :     :     :
       :     :     :     :     :     :    shift is 1, element size is
       :     :     :     :     :     :    (1 &lt;&lt; 1) =&gt; 2 bytes
       |-----|-----|-----|-----|-----|    (= .BYTES_PER_ELEMENT)
       : [0] : [1] : [2] : [3] : [4] :
       :     :                            elem. type is Int16 (signed)
       :     :
       :&lt;---&gt;:  (2-byte elements)         byte offset: 2 (= .byteOffset)
                                          byte length: 10 (= .byteLength)
                                          =&gt; view maps byte range [2,12[

                                          length in elements: 5 (= .length)
                                          virtual indices: 0, 1, 2, 3, 4
</code></pre><p>Each <code>duk_hbufobj</code> has virtual index behavior with indices mapping logically to elements in the range [0,length[. Elements may be signed or unsigned integers of multiple sizes, IEEE floats, or IEEE doubles. All accesses to the underlying buffer are byte-based, and no alignment is required by Duktape; however, Khronos TypedArray specification restricts creation of non-element-aligned views. All multi-byte elements are accessed in the host endianness (this is required by the ES2015 TypedArray specification).</p><p>A <code>duk_hbufobj</code> acts as a both a buffer representation (providing Node.js Buffer and ArrayBuffer) and a view representation (prodiving e.g. DataView, Uint8Array, and other TypedArray views). It supports both a direct 1:1 mapping to an underlying buffer and a slice/view mapping to a subset of the buffer.</p><p>The byteLength/byteOffset pair provides a logical window for the buffer object. The underlying buffer may be smaller, e.g. as a result of a dynamic buffer being resized after a <code>duk_hbufobj</code> was created. For example:</p><pre><code>+------+---------------------+
| xx xx:xx xx xx xx xx xx xx | / / / /    underlying buffer resized to 9 bytes
+------+---------------------+
       :     :     :     :     :     :
       :     :     :     :  ?  :  ?  :    index 3 is only partially mapped
       :     :     :     :     :     :    inde4 5 is not mapped
       |-----|-----|-----|-----|-----:
       : [0] : [1] : [2] : [3] : [4] :
</code></pre><p>This is not intended to be a normal usage scenario, so the main goal for Duktape is only to provide memory safe behavior:</p><ul><li>The virtual properties (byteLength, byteOffset, length) are unchanged.</li><li>Attempt to read outside the view (fully or partially) returns zero values.</li><li>Attempt to write outside the view (fully or partially) is silently ignored.</li><li>Other operations requiring access to the underlying buffer vary in behavior, some operations are silently skipped, some cause a TypeError, etc.</li></ul><p>Beyond memory safety, any specific behavior is not part of versioning guarantees and may change even between minor versions.</p><h3 id="summary-of-buffer-related-values" tabindex="-1">Summary of buffer-related values <a class="header-anchor" href="#summary-of-buffer-related-values" aria-label="Permalink to &quot;Summary of buffer-related values&quot;">​</a></h3><hr><p>Type Specification .length .byteLength .byteOffset .BYTES_PER_ELEMENT .buffer [index] Element Read Write Endianness Accessor Notes type coercion coercion methods</p><hr><p>plain buffer Duktape yes (bytes) yes yes 1 no yes uint8 uint8 ToUint32() &amp; n/a no Mimic Uint8Array, 0xff inherit from Uint8Array.prototype.</p><p>Buffer Node.js yes (bytes) yes yes 1 no yes uint8 uint8 ToUint32() &amp; n/a yes Based on Node.js 0xff v0.12.1.</p><p>ArrayBuffer TypedArray no yes no no no no n/a n/a n/a n/a no</p><p>DataView TypedArray yes (bytes) yes yes 1 yes yes uint8 uint8 ToUint32() &amp; n/a yes 0xff</p><p>Int8Array TypedArray yes (bytes) yes yes 1 yes yes int8 int8 ToUint32() &amp; n/a no 0xff</p><p>Uint8Array TypedArray yes (bytes) yes yes 1 yes yes uint8 uint8 ToUint32() &amp; n/a no 0xff</p><p>Uint8ClampedArray TypedArray yes (bytes) yes yes 1 yes yes uint8 uint8 special n/a no Write: special clamp/round.</p><p>Int16Array TypedArray yes yes yes 2 yes yes int16 int16 ToUint32() &amp; host no (elements) 0xffff</p><p>Uint16Array TypedArray yes yes yes 2 yes yes uint16 uint16 ToUint32() &amp; host no (elements) 0xffff</p><p>Int32Array TypedArray yes yes yes 4 yes yes int32 int32 ToUint32() host no (elements)</p><p>Uint32Array TypedArray yes yes yes 4 yes yes uint32 uint32 ToUint32() host no (elements)</p><p>Float32Array TypedArray yes yes yes 4 yes yes float float cast to host no (elements) float</p><h2 id="float64array-typedarray-yes-yes-yes-8-yes-yes-double-double-cast-to-host-no-elements-double" tabindex="-1">Float64Array TypedArray yes yes yes 8 yes yes double double cast to host no (elements) double <a class="header-anchor" href="#float64array-typedarray-yes-yes-yes-8-yes-yes-double-double-cast-to-host-no-elements-double" aria-label="Permalink to &quot;Float64Array        TypedArray      yes          yes           yes           8                    yes       yes         double    double     cast to      host         no
                                      (elements)                                                                                               double&quot;">​</a></h2><p>Notes:</p><ul><li><p>A plain buffer mimics an Uint8Array wherever possible, and inherits methods and other properties through <code>Uint8Array.prototype</code>.</p></li><li><p>DataView and Node.js Buffer inherit a set of accessor methods from their prototype. These accessors allow fields of different width and type to be manipulated directly. Endianness can be specified, but is limited to little/big (there&#39;s no support for ARM mixed endian IEEE doubles).</p></li><li><p>TypedArray views are host endian. Their byte offset relative to the ArrayBuffer they are used on must also be a multiple of the element size (i.e. views must be naturally aligned). These requirements are not very useful from Duktape point of view but they are required by the ES2015 specification.</p><p>(It would be trivial to use a specific endianness or allow unaligned views because Duktape works with the values byte-by-byte anyway.)</p></li><li><p><code>Uint8ClampedArray</code> has a very specific clamping and rounding behavior which differs from all other view types.</p></li><li><p>An unsigned <code>ToUint32()</code> coercion is used in writing signed values too. For the bytes written to memory the signedness of this coercion doesn&#39;t really matter.</p></li></ul><h3 id="built-in-objects-related-to-buffers" tabindex="-1">Built-in objects related to buffers <a class="header-anchor" href="#built-in-objects-related-to-buffers" aria-label="Permalink to &quot;Built-in objects related to buffers&quot;">​</a></h3><p>Duktape plain buffer value:</p><ul><li>None</li></ul><p>Node.js Buffer:</p><ul><li>Buffer</li><li>Buffer.prototype</li><li>SlowBuffer, only available if one does: require(&quot;buffer&quot;) and omitted from Duktape implementation</li></ul><p>TypedArray:</p><ul><li>ArrayBuffer</li><li>ArrayBuffer.prototype</li><li>DataView</li><li>DataView.prototype</li><li>Int8Array</li><li>Int8Array.prototype</li><li>Uint8Array</li><li>Uint8Array.prototype</li><li>Uint8ClampedArray</li><li>Uint8ClampedArray.prototype</li><li>Int16Array</li><li>Int16Array.prototype</li><li>Uint16Array</li><li>Uint16Array.prototype</li><li>Int32Array</li><li>Int32Array.prototype</li><li>Uint32Array</li><li>Uint32Array.prototype</li><li>Float32Array</li><li>Float32Array.prototype</li><li>Float64Array</li><li>Float64Array.prototype</li></ul><p>None of the prototype objects are mandated by the Khronos specification but are present in ES2015.</p><h3 id="conversions-between-buffer-values" tabindex="-1">Conversions between buffer values <a class="header-anchor" href="#conversions-between-buffer-values" aria-label="Permalink to &quot;Conversions between buffer values&quot;">​</a></h3><p>Because Duktape supports three Buffer object APIs, it&#39;s important that buffer values can be comfortably exchanged between the APIs (none of the API specifications require such behavior, of course).</p><p>As a general rule:</p><ul><li>Any Buffer object/view (implemented internally as a <code>duk_hbufobj</code>) is accepted by any API expecting a specific object/view. For example, Khronos DataView() constructor accepts a Node.js Buffer, and Node.js Buffer() accepts a Uint8Array as an input.</li><li>A plain Duktape buffer is accepted as if it was coerced to an Uint8Array. To simplify implementation many internals actually do an explicit Uint8Array coercion when given plain buffers.</li></ul><p>This general rules is complicated by a few practical issues:</p><ul><li>Some APIs create slices/views that share an underlying buffer value, while others create copies. Both behaviors are necessary in some situations.</li><li>A slice/view which doesn&#39;t map 1:1 to an underlying buffer cannot be coerced to a plain buffer value without copying, as the extra offset and length information is not supported for plain buffer values.</li></ul><p>The current mixing behavior is described in Duktape Wiki:</p><ul><li><a href="http://wiki.duktape.org/HowtoBuffers.html" target="_blank" rel="noreferrer">http://wiki.duktape.org/HowtoBuffers.html</a></li></ul><h3 id="buffer-values-in-the-duktape-c-api" tabindex="-1">Buffer values in the Duktape C API <a class="header-anchor" href="#buffer-values-in-the-duktape-c-api" aria-label="Permalink to &quot;Buffer values in the Duktape C API&quot;">​</a></h3><p>The C API for plain buffer and buffer object handling is described in Duktape Wiki:</p><ul><li><a href="http://wiki.duktape.org/HowtoBuffers.html" target="_blank" rel="noreferrer">http://wiki.duktape.org/HowtoBuffers.html</a></li></ul><h2 id="node-js-buffer-notes" tabindex="-1">Node.js Buffer notes <a class="header-anchor" href="#node-js-buffer-notes" aria-label="Permalink to &quot;Node.js Buffer notes&quot;">​</a></h2><p>The Node.js <code>Buffer</code> type is widely used in server-side programming but is not standardized as such.</p><h3 id="specification-notes" tabindex="-1">Specification notes <a class="header-anchor" href="#specification-notes" aria-label="Permalink to &quot;Specification notes&quot;">​</a></h3><p>Specification notes:</p><ul><li>A Buffer may point to a slice of an underlying buffer.</li><li>String-to-buffer coercion has a set of encoding values (other than UTF-8).</li><li>Buffer prototype&#39;s <code>slice()</code> does not copy contents of the slice, but creates a new Buffer which points to the same underlying buffer. This is similar to the TypedArray <code>subarray()</code> operation, but different from the ArrayBuffer <code>slice()</code> operation which creates a new buffer for the slice. With typed arrays a non-copying slice would just be a new view on top of a previous one instead of a new ArrayBuffer.</li><li>The <code>slice()</code> operation provides offsetted access to the underlying buffer (same as with e.g. Uint8Array). However, a slice is a fully fledged buffer and can be used to create another slice() etc.</li><li>Buffers have virtual index properties and a virtual &#39;length&#39; property.</li><li>Reads and writes have an optional offset and value range check which causes an error for out-of-bounds indices (RangeError) and values (TypeError); the behavior is not always consistent, and chosen Duktape behavior is documented in testcases. When the checks are disabled (noAssert == true), the behavior is memory unsafe and variable; some memory unsafe behavior results. Duktape semantics are always memory safe even at the cost of some performance.</li><li>Buffer accessor method read and write offsets are byte offsets regardless of data type being accessed. This is similar to Khronos DataView, but different from Khronos TypedArray views whose indices are element-based.</li><li>There are no alignment requirements for field access. This also matches Khronos DataView behavior, but differs from Khronos TypedArrays which must be aligned.</li><li>write(U)Int(LEBE) operate on variable-size integers (up to 48-bit) and caller selects number of bytes (and endianness) to read or write.</li><li>Newly created buffers don&#39;t seem to be zeroed automatically. Duktape zeroes buffer data as a side effect of underlying <code>duk_hbuffer</code> values being automatically zeroed. However, if DUK_USE_ZERO_BUFFER_DATA is not set, Node.js Buffers are not zeroed.</li><li>Buffer inspect() provides a limited hex dump of buffer contents. Duktape doesn&#39;t currently provide a similar function by default.</li><li>SlowBuffer: probably not needed.</li><li>User code can <code>require(&#39;buffer&#39;)</code>; this is not supported by Duktape.</li></ul><h3 id="implementation-notes" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h3><ul><li>Representation must point to a plain buffer and also needs internal slice offset/length properties to implement slice semantics. Slices must be valid inputs for other slices; such slice-of-slice objects can point to the same plain buffer with offset/length pairs resolved at each step.</li><li>For fast operations, guaranteed property slots could be used. Alternatively a dedicated <code>duk_hobject</code> subtype can be used. (The latter was chosen.)</li><li>Should be optional and disabled by default because of footprint concerns.</li><li>Should have a toLogString() which prints inspect() output or some other useful oneliner?</li></ul><h3 id="buffers-are-not-automatically-zeroed" tabindex="-1">Buffers are not automatically zeroed <a class="header-anchor" href="#buffers-are-not-automatically-zeroed" aria-label="Permalink to &quot;Buffers are not automatically zeroed&quot;">​</a></h3><pre><code>&gt; b = new Buffer(16)
&lt;Buffer 00 99 f2 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
&gt; b.fill(0)
undefined
&gt; b
&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
</code></pre><h3 id="range-checks-and-partial-writes" tabindex="-1">Range checks and partial writes <a class="header-anchor" href="#range-checks-and-partial-writes" aria-label="Permalink to &quot;Range checks and partial writes&quot;">​</a></h3><p>By default offset and value ranges are checked:</p><pre><code>&gt; b.writeUInt8(0x101, 0)
TypeError: value is out of bounds
    at TypeError (&lt;anonymous&gt;)
    at checkInt (buffer.js:784:11)
    [...]
</code></pre><p>With an explicit option asserts can be turned off. With assertions disabled invalid offsets are ignored and values are treated with modulo semantics:</p><pre><code>&gt; b.writeUInt8(0x101, 0, true)
undefined
&gt; b
&lt;Buffer 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
</code></pre><p>When writing values larger than a byte, partial writes are allowed:</p><pre><code>&gt; b.fill(0)
undefined
&gt; b.writeUInt32BE(0xdeadbeef, 13)
RangeError: Trying to write outside buffer length
    at RangeError (&lt;anonymous&gt;)
    at checkInt (buffer.js:788:11)
    [...]
&gt; b.writeUInt32BE(0xdeadbeef, 13, true)
undefined
&gt; b
&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 de ad be&gt;
&gt; b.fill(0)
undefined
&gt; b.writeUInt32BE(0xdeadbeef, -1, true)
undefined
&gt; b
&lt;Buffer ad be ef 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
</code></pre><p>However, such values are not actually &quot;dropped&quot; but can actually be read back with an unchecked out-of-bounds read:</p><pre><code>&gt; b = new Buffer(16); b.fill(0); b.writeUInt32BE(0xdeadbeef, -1, true); b
&lt;Buffer ad be ef 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
&gt; b.readUInt32BE(-1, true).toString(16)
&#39;deadbeef&#39;
&gt; b.fill(1); b
&lt;Buffer 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01&gt;
&gt; b.readUInt32BE(-1, true).toString(16)
&#39;de010101&#39;
</code></pre><p>This is not just a &quot;safe zone&quot; to avoid implementing partial writes: the out-of-bounds offsets can be large:</p><pre><code>&gt; b = new Buffer(16); b.fill(0); b.writeUInt32BE(0xdeadbeef, -10000, true); b
&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;
&gt; b.readUInt32BE(-10003, true).toString(16)
&#39;de&#39;
&gt; b.readUInt32BE(-10000, true).toString(16)
&#39;deadbeef&#39;
</code></pre><p>Running under valgrind this causes no valgrind gripes, so apparently this is supported behavior. It might be caused by &quot;buffer sharing&quot; where Node.js actually uses a large Buffer to provide multiple smaller Buffers (as slices), and these out-of-bounds accesses hit the shared large Buffer. Sometimes memory unsafe behavior occurs, though.</p><p>This behavior is difficult to implement in Duktape, so probably the best approach is to either ignore partial reads/writes, or implement them in an actual &quot;clipping&quot; manner.</p><h2 id="khronos-typed-array-notes" tabindex="-1">Khronos typed array notes <a class="header-anchor" href="#khronos-typed-array-notes" aria-label="Permalink to &quot;Khronos typed array notes&quot;">​</a></h2><p>The Khronos typed array specification is related to HTML canvas and WebGL programming. Some of the design choices are affected by this, e.g. the endianness handling and clamped byte write support. The Khronos specification has been refined and merged into ES2015 so this specification has an official status now.</p><h3 id="specification-notes-1" tabindex="-1">Specification notes <a class="header-anchor" href="#specification-notes-1" aria-label="Permalink to &quot;Specification notes&quot;">​</a></h3><ul><li><p>ArrayBuffer wraps an underlying buffer object, ArrayBufferView and DataView classes provide &quot;windowed&quot; access to some underlying ArrayBuffer. A buffer object can be &quot;neutered&quot;. Apparently neutering happens when &quot;transferring&quot; an ArrayBuffer which is HTML specific. Unsure if neutering needs to be supported.</p></li><li><p>ArrayBuffer does not have virtual indices or &#39;length&#39; behavior, but TypedArray views do. DataView does not have virtual indices but e.g. V8 provides them in practice.</p></li><li><p>ArrayBuffer has &#39;byteLength&#39;. Views have a &#39;byteLength&#39; and a &#39;length&#39;, where &#39;length&#39; refers to number of elements, not bytes. For example a Uint32Array view with length 4 would have byteLength 16. (For internal reasons, all Duktape ArrayBuffer and view objects provide &#39;length&#39;, &#39;byteLength&#39;, and &#39;byteOffset&#39;.)</p></li><li><p>ArrayBufferView classes are host endian. DataView is endian independent because caller specifies endianness for each call.</p></li><li><p>TypedArray instances must be created with a byte offset that is a multiple of the element size (i.e. aligned). DataView doesn&#39;t have this restriction. (This requirement is unnecessary for Duktape because the implementation never assumes alignment. But, this requirement is implemented for compatibility.)</p></li><li><p>NaN handling is rather fortunate, as it is compatible with packed duk_tval: in other words, NaNs can be substituted with one another. When coerced to integer, NaN is coerced to zero.</p></li><li><p>Modulo semantics for number writes, except Uint8ClampedArray which provides clamped semantics with special rounding when writin values. Both modulo and clamping coerces NaN to zero. With modulo semantics flooring is used (1.999 writes as 1) while clamped semantics uses a specific form of rounding.</p></li><li><p>For the clamping behavior, see:</p><ul><li><p><a href="http://heycam.github.io/webidl/#Clamp" target="_blank" rel="noreferrer">http://heycam.github.io/webidl/#Clamp</a></p></li><li><p><a href="http://heycam.github.io/webidl/#es-type-mapping" target="_blank" rel="noreferrer">http://heycam.github.io/webidl/#es-type-mapping</a></p></li><li><p><a href="http://heycam.github.io/webidl/#es-byte" target="_blank" rel="noreferrer">http://heycam.github.io/webidl/#es-byte</a></p><p>Steps for unsigned byte (octet) clamped coercion:</p></li><li><p>Set x to min(max(x, 0), 2^8 - 1).</p></li><li><p>Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than -0.</p></li><li><p>Return the IDL octet value that represents the same numeric value as x.</p></li></ul></li><li><p>Error is thrown for out-of-bounds accesses.</p></li><li><p>When using <code>set()</code> the arrays may refer to the same underlying array and the write source and destination may overlap. Must handle as if a temporary copy was made, i.e. like <code>memmove()</code>.</p></li><li><p>DataView and Node.js buffer have similar (but not identical) methods, which can share the same underlying implementation. Endianness is specified with an argument in DataView but is implicit in Node.js buffer:</p><pre><code>  // DataView
  setUint16(unsigned long byteOffset, unsigned short value, optional boolean littleEndian)

  // Node.js buffer
  buf.writeUInt16LE(value, offset, [noAssert])
  buf.writeUInt16BE(value, offset, [noAssert])
</code></pre><p>Unfortunately also the argument order (value/offset) are swapped.</p></li><li><p>There are explicit zeroing guarantees for ArrayBuffer constructor and typedarray constructors, so buffer data must be zeroed even when DUK_USE_ZERO_BUFFER_DATA is not set.</p></li></ul><h3 id="implementation-notes-1" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes-1" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h3><ul><li>ArrayBuffer wraps an underlying buffer object. A buffer object can be &quot;neutered&quot;.</li><li>ArrayBufferView classes and DataView refer to an underlying ArrayBuffer, and may have an offset. These could be implemented similar to Node.js Buffer: refer to a plain underlying buffer, byte offset, and byte length in internal properties. Reference to the original ArrayBuffer (boxed buffer) is unfortunately also needed, via the &#39;.buffer&#39; property.</li><li>There are a lot of classes in the typed array specification. Each class is an object, so this is rather heavyweight.</li><li>Should be optional and disabled by default because of footprint concerns.</li></ul><h2 id="merged-read-write-algorithm-for-element-access" tabindex="-1">Merged read/write algorithm for element access <a class="header-anchor" href="#merged-read-write-algorithm-for-element-access" aria-label="Permalink to &quot;Merged read/write algorithm for element access&quot;">​</a></h2><p>This section describes a merged algorithm for reading and writing fields (uint8, int8, uint16, int16, etc) with the explicit read/write calls provided by DataView and Node.js Buffer. The same native code can be used with &quot;magic&quot; value providing flags for differences in behavior.</p><p>Virtual index properties also need handling; they can either be implemented separately or call into this algorithm.</p><h3 id="summary-of-read-methods" tabindex="-1">Summary of read methods <a class="header-anchor" href="#summary-of-read-methods" aria-label="Permalink to &quot;Summary of read methods&quot;">​</a></h3><p>Related methods are summarized in the table below, notes:</p><ul><li><p>&quot;buf.XXX&quot; refers to Node.JS Buffer instance methods (inherited)</p></li><li><p>&quot;dv.XXX&quot; refers to Khronos DataView instance methods (inherited)</p></li><li><p>&quot;XyzArray index&quot; refers to Khronos typed array view number index reads</p></li><li><p>Endianness &quot;user&quot; means that caller gives a littleEndian flag so that effective endianness is either big or little (there&#39;s no support for ARM mixed endian)</p></li><li><p>Endianness &quot;host&quot; means that host endianness is used</p></li><li><p>When reading values, there&#39;s no clamping behavior because integers are converted to IEEE doubles upon read in the natural way (zeroes read out as positive zeroes).</p></li><li><p>Bounds &quot;arg&quot; means argument indicates yes/no, &quot;yes&quot; means bounds are checked, &quot;n/a&quot; means not applicable. Virtual indices don&#39;t really have bounds checking, as any reads outside the range [0,length[ just become concrete string-keyed property lookups.</p><hr><p>Method Endian Bytes Bounds Notes</p><hr><p>buf.readIntLE little 1-6 arg Can read up to 48-bit integers, caller specifies</p><p>buf.readIntBE big 1-6 arg Can read up to 48-bit integers, caller specifies</p><p>buf.readUIntLE little 1-6 arg Can read up to 48-bit integers, caller specifies</p><p>buf.readUIntBE big 1-6 arg Can read up to 48-bit integers, caller specifies</p><p>buf.readInt8 n/a 1 arg</p><p>buf.readUInt8 n/a 1 arg</p><p>buf.readInt16LE little 2 arg</p><p>buf.readInt16BE big 2 arg</p><p>buf.readUInt16LE little 2 arg</p><p>buf.readUInt16BE big 2 arg</p><p>buf.readInt32LE little 4 arg</p><p>buf.readInt32BE big 4 arg</p><p>buf.readUInt32LE little 4 arg</p><p>buf.readUInt32BE big 4 arg</p><p>buf.readFloatLE little 4 arg</p><p>buf.readFloatBE big 4 arg</p><p>buf.readDoubleLE little 8 arg</p><p>buf.readDoubleBE big 8 arg</p><p>DataView.getInt8 n/a 1 yes</p><p>DataView.getUint8 n/a 1 yes</p><p>DataView.getInt16 user 2 yes</p><p>DataView.getUint16 user 2 yes</p><p>DataView.getInt32 user 4 yes</p><p>DataView.getUint32 user 4 yes</p><p>DataView.getFloat32 user 4 yes</p><p>DataView.getFloat64 user 8 yes</p><p>Int8Array index n/a 1 n/a</p><p>Uint8Array index n/a 1 n/a</p><p>Uint8ClampedArray n/a 1 n/a index</p><p>Int16Array index host 2 n/a</p><p>Uint16Array index host 2 n/a</p><p>Int32Array index host 4 n/a</p><p>Uint32Array index host 4 n/a</p><p>Float32Array index host 4 n/a</p></li></ul><h2 id="float64array-index-host-8-n-a" tabindex="-1">Float64Array index host 8 n/a <a class="header-anchor" href="#float64array-index-host-8-n-a" aria-label="Permalink to &quot;Float64Array index    host     8       n/a&quot;">​</a></h2><h3 id="summary-of-write-methods" tabindex="-1">Summary of write methods <a class="header-anchor" href="#summary-of-write-methods" aria-label="Permalink to &quot;Summary of write methods&quot;">​</a></h3><p>Related methods are summarized in the table below, notes:</p><ul><li><p>&quot;buf.XXX&quot; refers to Node.JS Buffer instance methods (inherited)</p></li><li><p>&quot;dv.XXX&quot; refers to Khronos DataView instance methods (inherited)</p></li><li><p>&quot;XyzArray index&quot; refers to Khronos typed array view number index writes</p></li><li><p>Endianness &quot;user&quot; means that caller gives a littleEndian flag so that effective endianness is either big or little (there&#39;s no support for ARM mixed endian)</p></li><li><p>Endianness &quot;host&quot; means that host endianness is used</p></li><li><p>Coercion behavior describes how an input value is coerced into an integer value; usually truncation but there are special cases. &quot;truncate*&quot; means that truncation happens in Node.js Buffer API calls when &quot;noAssert==true&quot;; a TypeError occurs for out-of-range writes (though fractional values are still silently accepted).</p></li><li><p>Bounds &quot;arg&quot; means argument indicates yes/no, &quot;yes&quot; means bounds are checked, &quot;n/a&quot; means not applicable. Virtual indices don&#39;t really have bounds checking, as any writes outside the range [0,length[ just become concrete string-keyed properties of the object (provided the object is extensible).</p></li><li><p>Return value of Node.js Buffer write calls is the number of bytes written. TypedArray write return value is <code>undefined</code>.</p></li><li><p>Node.js Buffer write() method is left out because it&#39;s not an element write</p><hr><p>Method Endian Bytes Bounds Coercion Notes</p><hr><p>buf.writeIntLE little 1-6 arg truncate* Can write up to 48-bit integers, caller specifies</p><p>buf.writeIntBE big 1-6 arg truncate* Can write up to 48-bit integers, caller specifies</p><p>buf.writeUIntLE little 1-6 arg truncate* Can write up to 48-bit integers, caller specifies</p><p>buf.writeUIntBE big 1-6 arg truncate* Can write up to 48-bit integers, caller specifies</p><p>buf.writeInt8 n/a 1 arg truncate*</p><p>buf.writeUInt8 n/a 1 arg truncate*</p><p>buf.writeInt16LE little 2 arg truncate*</p><p>buf.writeInt16BE big 2 arg truncate*</p><p>buf.writeUInt16LE little 2 arg truncate*</p><p>buf.writeUInt16BE big 2 arg truncate*</p><p>buf.writeInt32LE little 4 arg truncate*</p><p>buf.writeInt32BE big 4 arg truncate*</p><p>buf.writeUInt32LE little 4 arg truncate*</p><p>buf.writeUInt32BE big 4 arg truncate*</p><p>buf.writeFloatLE little 4 arg truncate*</p><p>buf.writeFloatBE big 4 arg truncate*</p><p>buf.writeDoubleLE little 8 arg truncate*</p><p>buf.writeDoubleBE big 8 arg truncate*</p><p>DataView.setInt8 n/a 1 yes truncate</p><p>DataView.setUint8 n/a 1 yes truncate</p><p>DataView.setInt16 user 2 yes truncate</p><p>DataView.setUint16 user 2 yes truncate</p><p>DataView.setInt32 user 4 yes truncate</p><p>DataView.setUint32 user 4 yes truncate</p><p>DataView.setFloat32 user 4 yes truncate</p><p>DataView.setFloat64 user 8 yes truncate</p><p>Int8Array index n/a 1 n/a truncate</p><p>Uint8Array index n/a 1 n/a truncate</p><p>Uint8ClampedArray n/a 1 n/a special Coercion is rounding with index specific rules</p><p>Int16Array index host 2 n/a truncate</p><p>Uint16Array index host 2 n/a truncate</p><p>Int32Array index host 4 n/a truncate</p><p>Uint32Array index host 4 n/a truncate</p><p>Float32Array index host 4 n/a truncate</p></li></ul><h2 id="float64array-index-host-8-n-a-truncate" tabindex="-1">Float64Array index host 8 n/a truncate <a class="header-anchor" href="#float64array-index-host-8-n-a-truncate" aria-label="Permalink to &quot;Float64Array index    host     8       n/a      truncate&quot;">​</a></h2><h2 id="implementation-notes-2" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes-2" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h2><h3 id="typedarray-inheritance" tabindex="-1">TypedArray inheritance <a class="header-anchor" href="#typedarray-inheritance" aria-label="Permalink to &quot;TypedArray inheritance&quot;">​</a></h3><p>The prototype chain for a TypedArray instance in V8 is:</p><pre><code>view object -&gt; Uint8Array.prototype -&gt; Object.prototype
</code></pre><p>This means that view properties like <code>set()</code> and <code>subarray()</code> are provided by the prototype, and each view type has its own prototype with these properties. This duplicates the properties several times.</p><p>Duktape now inherits from an intermediate object:</p><pre><code>view object -&gt; Uint8Array.prototype -&gt; TypedArray prototype -&gt; Object.prototype
</code></pre><p>The <code>set()</code> and <code>subarray()</code> methods are inherited from the intermediate prototype object. This reduces property count by about 16 at the cost of one additional object.</p><p>ES2015 makes this the standard model; the TypedArreay prototype is referred to as %TypedArrayPrototype% intrinsic object in the ES2015 specification.</p><h3 id="view-slice-notes" tabindex="-1">View/slice notes <a class="header-anchor" href="#view-slice-notes" aria-label="Permalink to &quot;View/slice notes&quot;">​</a></h3><ul><li>Affects all code that accesses the underlying buffer through an Object reference (Buffer, ArrayBuffer, DataView, Uint8Array, etc): <ul><li>Must look up internal plain buffer but also check for offset/length information.</li><li>Lookups should be fast, so: <ul><li>Use an extended structure like for compiled functions</li><li>Use slotted internal properties (must be non-configurable so that their location won&#39;t change by accident)</li></ul></li></ul></li><li>Need reference to underlying buffer: <ul><li>Could use a raw pointer to the buffer data as long as there&#39;s also a buffer reference to avoid freeing the underlying data.</li><li>But a raw pointer would only work with a fixed buffer which has a stable buffer pointer.</li><li>So, must reference the original buffer and figure out its data area dynamically.</li></ul></li><li>Need byte offset and length for the view: <ul><li>These should be validated on creation so that sanity checks are not necessary for every access.</li><li>If internal properties, should be non-writable and non-configurable to ensure that only C code can create a situation where assertions fail.</li></ul></li><li>Need element size for the view: <ul><li>For Node.js Buffer the element size is the byte size. For TypedArrays it may be 1, 2, 4, or 8 bytes.</li><li>Virtual &quot;length&quot; property must provide length in elements. Maintain two length fields (byte and element) or only the other and shift as necessary.</li><li>Virtual element &quot;length&quot;: easier index/bound checks, virtual &quot;length&quot; read needs no change. Must be taken into account when byte length is needed.</li></ul></li></ul><h3 id="buffer-validity-checksand-unbacked-buffers" tabindex="-1">Buffer validity checksand unbacked buffers <a class="header-anchor" href="#buffer-validity-checksand-unbacked-buffers" aria-label="Permalink to &quot;Buffer validity checksand unbacked buffers&quot;">​</a></h3><p>To ensure memory safety, all memory accesses need to be checked against the size of the underlying buffer even if the access is within the configured view/slice. This is needed because an underlying buffer may be dynamic or external and can be resized/reconfigured at any point.</p><p>In particular, the underlying buffer may be resized as a side effect of any operation that triggers code to run: the code may call into user code which manipulates the buffer.</p><p>As a result, the following checks must be made just before an operation and there must be no side effects between the check and the operation:</p><ul><li>Checking that byte range is covered by underlying buffer</li><li>Checking that bufferobject is neutered (buf == NULL vs. buf != NULL)</li></ul><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="missing-es2015-features" tabindex="-1">Missing ES2015 features <a class="header-anchor" href="#missing-es2015-features" aria-label="Permalink to &quot;Missing ES2015 features&quot;">​</a></h3><p>General semantics:</p><ul><li>ToLength() coercion allows ArrayBuffer and typed array length up to <code>2^53 - 1</code>.</li><li>Virtual index getters/setters don&#39;t handle out-of-bound accesses correctly (they should not be inherited through the inheritance chain).</li><li>Behavior for &quot;detached&quot; ArrayBuffers don&#39;t necessarily implement the behavior described in <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-arraybuffer-instances" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-arraybuffer-instances</a>: &quot;... all operators to access or modify data contained in the ArrayBuffer instance will fail.&quot; However, there&#39;s no support for creating a detached buffer now, so this doesn&#39;t really matter.</li><li>Coercion behavior may be correct, but needs to be checked for typed arrays and DataView.</li></ul><p>ArrayBuffer:</p><ul><li><code>ArrayBuffer.prototype[@@toStringTag]</code> missing.</li></ul><p>DataView:</p><ul><li><code>DataView.prototype.buffer</code> is an accessor property, currently <code>.buffer</code> is a concrete property.</li><li><code>DataView.prototype[@@toStringTag]</code> missing.</li></ul><p>Typed arrays:</p><ul><li>Typed array constructors like <code>Uint8Array</code> should inherit from an unnamed prototype object which hosts shared properties like <code>.from()</code>.</li><li><code>%TypedArray%.from</code> missing.</li><li><code>%TypedArray%.of</code> missing.</li><li><code>%TypedArray%.prototype</code> is <code>%TypedArrayPrototype%</code> which Duktape is actually already using.</li><li>The <code>.buffer</code> property should be inherited from <code>%TypedArray%.prototype.buffer</code> instead of being a concrete property.</li><li>The <code>.byteLength</code> property should be inherited, but is virtual. The difference matters if inheritance relationship is altered.</li><li>The <code>.byteOffset</code> property should be inherited, but is virtual.</li><li>The <code>.length</code> property should be inherited, but is virtual.</li><li><code>%TypedArray%.prototype.copyWithin()</code> is missing.</li><li><code>%TypedArray%.prototype.entries()</code> is missing.</li><li><code>%TypedArray%.prototype.every()</code> is missing.</li><li><code>%TypedArray%.prototype.fill()</code> is missing.</li><li><code>%TypedArray%.prototype.filter()</code> is missing.</li><li><code>%TypedArray%.prototype.find()</code> is missing.</li><li><code>%TypedArray%.prototype.findIndex()</code> is missing.</li><li><code>%TypedArray%.prototype.forEach()</code> is missing.</li><li><code>%TypedArray%.prototype.indexOf()</code> is missing.</li><li><code>%TypedArray%.prototype.join()</code> is missing.</li><li><code>%TypedArray%.prototype.keys()</code> is missing.</li><li><code>%TypedArray%.prototype.lastIndexOf()</code> is missing.</li><li><code>%TypedArray%.prototype.map()</code> is missing.</li><li><code>%TypedArray%.prototype.reduce()</code> is missing.</li><li><code>%TypedArray%.prototype.reduceRight()</code> is missing.</li><li><code>%TypedArray%.prototype.reverse()</code> is missing.</li><li><code>%TypedArray%.prototype.set()</code> exists, semantics need to be checked.</li><li><code>%TypedArray%.prototype.slice()</code> is missing.</li><li><code>%TypedArray%.prototype.some()</code> is missing.</li><li><code>%TypedArray%.prototype.sort()</code> is missing.</li><li><code>%TypedArray%.prototype.subarray()</code> exists, semantics need to be checked.</li><li><code>%TypedArray%.prototype.toLocaleString()</code> is missing.</li><li><code>%TypedArray%.prototype.toString()</code> is missing.</li><li><code>%TypedArray%.prototype.values()</code> is missing.</li><li><code>%TypedArray%.prototype[@@iterator]()</code> is missing.</li><li><code>get %TypedArray%.prototype[@@toStringTag]</code> is missing.</li></ul><p>The initial implementations for some of the missing methods can be the equivalent methods in <code>Array.prototype</code> with the caveat that <code>.length</code> should be accessed directly without invoking side effects. For now this would not be an issue because typed array <code>.length</code> is a virtual own property, and accessing it has no side effects.</p><h3 id="update-to-newer-node-js-buffer-api-version" tabindex="-1">Update to newer Node.js Buffer API version <a class="header-anchor" href="#update-to-newer-node-js-buffer-api-version" aria-label="Permalink to &quot;Update to newer Node.js Buffer API version&quot;">​</a></h3><p>Current:</p><ul><li><a href="https://nodejs.org/docs/v0.12.1/api/buffer.html" target="_blank" rel="noreferrer">https://nodejs.org/docs/v0.12.1/api/buffer.html</a></li></ul><p>Latest at time of writing:</p><ul><li><a href="https://nodejs.org/docs/v6.9.1/api/buffer.html" target="_blank" rel="noreferrer">https://nodejs.org/docs/v6.9.1/api/buffer.html</a></li></ul><p>Gap between current implementation and latest:</p><ul><li><p>Buffers can be for-of iterated; buf.values(), buf.keys(), and buf.entries() create iterators. For-of iteration requires @@iterator support.</p></li><li><p><code>new Buffer(...)</code> is deprecated in favor of <code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code>.</p></li><li><p><code>new Buffer(arrayBuffer[, byteOffset [, length]])</code> variant is not supported. This variant is already deprecated.</p></li><li><p><code>new Buffer(string[, encoding])</code> does not handle encoding correctly. The internal string representation (CESU-8, extended UTF-8, or even invalid UTF-8) is used as buffer bytes as-is. This is also incorrect for Node.js Buffer v0.12.1 (and already incorrect in master).</p></li><li><p><code>Buffer.alloc(size[, fill[, encoding]])</code> is missing.</p></li><li><p><code>Buffer.allocUnsafe(size)</code> is missing. In practice could be implemented as <code>Buffer.alloc(size)</code> (ignoring any further parameters) so that a zero-filled buffer is allocated.</p></li><li><p><code>Buffer.allocUnsafeSlow(size)</code> is missing. Could be implemented as <code>Buffer.alloc(size)</code> (ignoring any further parameters).</p></li><li><p><code>Buffer.byteLength(string[, encoding])</code> ignores the encoding argument and just returns the byte length of the internal string representation (CESU-8 typically, but not always). It also doesn&#39;t handle buffer, Uint8Array, etc values which now have special handling in v6.9.1.</p></li><li><p><code>Buffer.from()</code> is missing. It can share most code with the constructor.</p></li><li><p><code>Buffer.isEncoding()</code> is implemented but (still) only narrowly recognizes the exact string <code>&quot;utf8&quot;</code>.</p></li><li><p><code>Buffer.poolSize</code> is not provided. The value is meaningless if it&#39;s not used by the implementation (i.e. no &quot;unsafe&quot; buffers are implemented).</p></li><li><p><code>SlowBuffer</code> is not implemented; it&#39;s part of v0.12.1 and deprecated (but present) in v6.9.1. If deprecated features are supported, it should be implemented.</p></li><li><p><code>buf.compare()</code> has additional arguments in v6.9.1 (source/target indices) which are not implemented.</p></li><li><p><code>buf.copy()</code> return value has been specified explicitly, must compare against current implementation (also for truncated copys).</p></li><li><p><code>buf.entries()</code> missing. Depends on general iterator support.</p></li><li><p><code>buf.fill()</code> has an explicit encoding argument which has an effect if the fill argument is a string. Depends on generally supporting string encodings for Buffer API.</p></li><li><p><code>buf.indexOf()</code> missing. Note that this is not the same as the typed array indexOf() because it recognizes Buffers.</p></li><li><p><code>buf.includes()</code> missing. Note that this is not the same as typed array includes().</p></li><li><p><code>buf.keys()</code> missing.</p></li><li><p><code>buf.lastIndexOf()</code> missing. Note that this is not the same as typed array lastIndexOf().</p></li><li><p><code>buf.length</code> writability comments in v6.9.1 may need documentation.</p></li><li><p><code>buf.readDoubleBE()</code>, <code>buf.writeDoubleBE()</code> and all the other read/write accessors seem to be the same in v6.9.1. Duktape doesn&#39;t implement the <code>noAssert</code> argument and always checks the offsets (which should be within the specification because:</p><blockquote><p>Setting noAssert to true allows offset to be beyond the end of buf, but the result should be considered undefined behavior.</p></blockquote></li><li><p><code>buf.swap16()</code>, <code>buf.swap32()</code>, <code>buf.swap64()</code> missing.</p></li><li><p><code>buf.toString()</code> always decodes the buffer using UTF-8 (with replacement characters for invalid sequences), and ignores the encoding argument.</p></li><li><p><code>buf.values()</code> missing.</p></li><li><p><code>buf.write()</code> doesn&#39;t implement encoding. In both v0.12.1 and v6.9.1 partially encoded characters won&#39;t be written at all so that a few bytes at the end of the buffer may (apparently) be left untouched on a truncated write. Duktape doesn&#39;t currently implement this behavior.</p></li><li><p><code>buffer.INSPECT_MAX_BYTES</code> not implemented. It&#39;s a property on the <code>require(&#39;buffer&#39;)</code> module rather than <code>Buffer</code> or a <code>Buffer</code> instance.</p></li><li><p><code>SlowBuffer</code> is not implemented.</p></li></ul><p>Other notes:</p><ul><li>Deprecated features could be moved behind a config option, e.g. <code>DUK_USE_NODEJS_BUFFER_DEPRECATED</code>.</li><li>Node.js Buffer binding should have its own config option, e.g. <code>DUK_USE_NODEJS_BUFFER</code>.</li></ul><h3 id="improve-consistency-of-argument-coercion" tabindex="-1">Improve consistency of argument coercion <a class="header-anchor" href="#improve-consistency-of-argument-coercion" aria-label="Permalink to &quot;Improve consistency of argument coercion&quot;">​</a></h3><p>For Node.js Buffer bindings there&#39;s considerable variation of how arguments are coerced (in both Node.js and Duktape; and these are not always the same now). Improve consistency either by matching Node.js more closely, or by making Duktape specific behavior more consistent with itself.</p><h3 id="add-support-for-neutering-detached-buffer" tabindex="-1">Add support for neutering (detached buffer) <a class="header-anchor" href="#add-support-for-neutering-detached-buffer" aria-label="Permalink to &quot;Add support for neutering (detached buffer)&quot;">​</a></h3><p>Currently not supported. Neutering an ArrayBuffer must also affect all views referencing that ArrayBuffer. Because duk_hbufobj has a direct duk_hbuffer pointer (not a pointer to ArrayBuffer which is stored as .buffer) the neutering cannot be implemented by replacing the duk_hbuffer pointer with zero, as that wouldn&#39;t affect all the shared views.</p><p>Instead, neutering probably needs to be implemented at the plain buffer level; for example, by adding a &quot;neutered&quot; flag to duk_hbuffer. A dynamic buffer can also be resized to zero bytes at neutering time.</p><p>Another option is to support neutering only when the underlying buffer is dynamic, and simply resize the buffer to zero bytes. This produces much of the required behavior (e.g. zero .byteLength) but not all (e.g. zero .byteOffset). So an explicit neutered check, or a change in data structures, may be necessary.</p><p>In ES2015 neutering seems to be covered under the name &quot;detached buffer&quot; and many operations on detached buffers (like reads and writes) throw a TypeError which is close to what current code is doing:</p><ul><li>See e.g. Step 9 of <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-setviewvalue" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-setviewvalue</a></li></ul><h3 id="configurable-endianness-for-typedarray-views" tabindex="-1">Configurable endianness for TypedArray views <a class="header-anchor" href="#configurable-endianness-for-typedarray-views" aria-label="Permalink to &quot;Configurable endianness for TypedArray views&quot;">​</a></h3><p>Change duk_hbufobj so that it records requested endianness explicitly: host, little, or big endian. Then use the specified endianness in readfield and writefield internal primitives.</p><p>This should be relatively straightforward to do, and perhaps useful.</p><h3 id="allow-non-aligned-views" tabindex="-1">Allow non-aligned views <a class="header-anchor" href="#allow-non-aligned-views" aria-label="Permalink to &quot;Allow non-aligned views&quot;">​</a></h3><p>The ES2015 alignment limitation is not necessary with Duktape because all element accesses are ultimately done using byte-by-byte reads without making any alignment assumptions.</p><h3 id="additional-arguments-to-typedarray-set" tabindex="-1">Additional arguments to TypedArray .set() <a class="header-anchor" href="#additional-arguments-to-typedarray-set" aria-label="Permalink to &quot;Additional arguments to TypedArray .set()&quot;">​</a></h3><p>It would be nice to be able to specify an offset/length (or offset/end) for a .set() call, so that one could:</p><pre><code>v1.set(v2, 5, 10);
</code></pre><p>Currently one needs to do something like:</p><pre><code>v1.set(v2.subarray(5, 15));
</code></pre><h3 id="additional-arguments-to-typedarray-constructor" tabindex="-1">Additional arguments to TypedArray constructor <a class="header-anchor" href="#additional-arguments-to-typedarray-constructor" aria-label="Permalink to &quot;Additional arguments to TypedArray constructor&quot;">​</a></h3><p>It would be nice to have offset/length when constructing a TypedArray from another TypedArray.</p><h3 id="node-js-parent-property" tabindex="-1">Node.js .parent property <a class="header-anchor" href="#node-js-parent-property" aria-label="Permalink to &quot;Node.js .parent property&quot;">​</a></h3><p>Not currently included in Node.js Buffer instances.</p><h3 id="testcase-coverage-improvements" tabindex="-1">Testcase coverage improvements <a class="header-anchor" href="#testcase-coverage-improvements" aria-label="Permalink to &quot;Testcase coverage improvements&quot;">​</a></h3><ul><li>Fine-grained tests for argument/this coercion</li><li>Property attributes</li><li>Object.defineProperty() and Object.getOwnPropertyDescriptor() for virtual properties</li><li>Constructing DataView and TypedArray from another view (allowed now but semantics may need improvement)</li><li>Node.js Buffer slice() coverage, argument coercion, etc.</li></ul><h3 id="low-memory-support" tabindex="-1">Low memory support <a class="header-anchor" href="#low-memory-support" aria-label="Permalink to &quot;Low memory support&quot;">​</a></h3><p>Implement low-memory support (16-bit fields, pointer compression, etc) for Buffer objects. Currently buffer objects will have &quot;long&quot; fields.</p><h3 id="improve-fastint-support" tabindex="-1">Improve fastint support <a class="header-anchor" href="#improve-fastint-support" aria-label="Permalink to &quot;Improve fastint support&quot;">​</a></h3><p>Improve fastint handling for buffer indices, lengths, values, etc.</p><h3 id="unsorted-future-work" tabindex="-1">Unsorted future work <a class="header-anchor" href="#unsorted-future-work" aria-label="Permalink to &quot;Unsorted future work&quot;">​</a></h3><ul><li>Clean up <code>duk_hbufobj</code> <code>buf == NULL</code> handling. Perhaps don&#39;t allow <code>NULL</code> at all; this depends on the neutering / detached buffer solution.</li><li>Implement and test for integer arithmetic wrap checks e.g. when coercing an index into a byte offset by shifting.</li><li>duk_to_buffer(): coerce a Buffer object into a plain buffer value (similarly to how duk_to_string() coerces a String to a plain string)? Slice information will be lost unless a copy is made.</li><li>duk_is_buffer(): return true for a Buffer object? For comparison, duk_is_string() returns false for a String object, so returning false might be most consistent.</li><li>Other Duktape C API changes to interact with Buffer objects.</li><li>Node.js Buffer.isBuffer(): what is the best behavior for plain buffer and other buffer object values?</li><li>What to do with Node.js SlowBuffer, INSPECT_MAX_BYTES, and code that does <code>require(&#39;buffer&#39;)</code>?</li><li>Mixing buffer types between APIs: go through the various cases, document, add testcases, etc.</li><li>Implement fast path for Node.js Buffer constructor when argument is another duk_hbufobj (now reads indexed properties explicitly).</li><li>Duktape C API tests for buffer handling.</li><li>Duktape C API test exercising &quot;underlying buffer doesn&#39;t cover logical buffer slice&quot; cases which cannot be exercised with plain ECMAScript code.</li><li>Document Buffer object relationship to JSON, JX, and JC.</li><li>Explicit maximum element and byte size checks for all operations that create new bufferobjects.</li><li>Change the TypedArray subarray() implementation to avoid copying the argument internal prototype and use a &quot;default&quot; prototype instead (e.g. Uint8Array.prototype instead of copying the argument internal prototype which may be different).</li></ul>`,169)]))}const h=t(o,[["render",n]]);export{f as __pageData,h as default};
