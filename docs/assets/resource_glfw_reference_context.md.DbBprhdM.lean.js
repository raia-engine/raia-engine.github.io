import{_ as t,c as i,a2 as e,o as a}from"./chunks/framework.DPuwY6B9.js";const c=JSON.parse('{"title":"コンテキスト","description":"","frontmatter":{},"headers":[],"relativePath":"resource/glfw/reference/context.md","filePath":"resource/glfw/reference/context.md","lastUpdated":null}'),n={name:"resource/glfw/reference/context.md"};function p(l,s,r,o,d,h){return a(),i("div",null,s[0]||(s[0]=[e('<h1 id="コンテキスト" tabindex="-1">コンテキスト <a class="header-anchor" href="#コンテキスト" aria-label="Permalink to &quot;コンテキスト&quot;">​</a></h1><p>これはOpenGLとOpenGL ESのコンテキスト関連関数のリファレンス・ドキュメントです。よりタスク指向の情報については、コンテキストガイドを参照してください。</p><nav class="table-of-contents"><ul><li><a href="#型定義">型定義</a></li><li><a href="#関数">関数</a></li></ul></nav><h2 id="型定義" tabindex="-1">型定義 <a class="header-anchor" href="#型定義" aria-label="Permalink to &quot;型定義&quot;">​</a></h2><table tabindex="0"><thead><tr><th>型定義</th><th>説明</th></tr></thead><tbody><tr><td><code>typedef void(* GLFWglproc)</code></td><td>クライアント API 関数のポインタ型。</td></tr></tbody></table><details class="details custom-block"><summary><code>void(* GLFWglproc)</code></summary><p>通常のポインタからのキャストを強いることなく、クライアントAPIの関数ポインタを返すために使用される汎用関数ポインタ。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLFWglproc) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>参照</strong>:</p><ul><li>OpenGL and OpenGL ES extensions</li><li>glfwGetProcAddress</li></ul><p><strong>追加</strong>:</p><p>バージョン3.0で追加。</p></details><h2 id="関数" tabindex="-1">関数 <a class="header-anchor" href="#関数" aria-label="Permalink to &quot;関数&quot;">​</a></h2><table tabindex="0"><thead><tr><th>関数名</th><th>説明</th></tr></thead><tbody><tr><td>glfwMakeContextCurrent</td><td>指定されたウィンドウのコンテキストを、呼び出し元のスレッドに対してカレントにします。</td></tr><tr><td>glfwGetCurrentContext</td><td>呼び出し元のスレッドで現在のコンテキストを持つウィンドウを返します。</td></tr><tr><td>glfwSwapInterval</td><td>現在のコンテキストのスワップ間隔を設定します。</td></tr><tr><td>glfwExtensionSupported</td><td>指定した拡張子が利用可能かどうかを返します。</td></tr><tr><td>glfwGetProcAddress</td><td>現在のコンテキストの指定された関数のアドレスを返します。</td></tr></tbody></table><details class="details custom-block"><summary><code>glfwMakeContextCurrent()</code></summary><p>この関数は、指定されたウィンドウのOpenGLまたはOpenGL ESコンテキストを、呼び出したスレッドでカレントにします。コンテキストは一度に単一のスレッド上でのみカレントでなければならず、各スレッドは一度に単一のカレントコンテキストしか持つことができません。</p><p>スレッド間でコンテキストを移動させる場合は、古いスレッドで非カレントにしてから、新しいスレッドでカレントにしなければならない。</p><p>デフォルトでは、コンテキストをnon-currentにすると、暗黙的にパイプラインフラッシュが強制される。GL_KHR_context_flush_controlをサポートするマシンでは、GLFW_CONTEXT_RELEASE_BEHAVIORヒントを設定することによって、コンテキストがこのフラッシュを実行するかどうかを制御することができます。</p><p>指定されたウィンドウは、OpenGLまたはOpenGL ESのコンテキストを持っている必要があります。コンテキストのないウィンドウを指定すると、GLFW_NO_WINDOW_CONTEXTエラーが発生します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwMakeContextCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>引数</strong>:</p><ul><li><code>window [in]</code>: 現在のコンテキストにするウィンドウ、または現在のコンテキストを切り離すNULL。</li></ul><p><strong>エラー</strong>:</p><p>起こりうるエラーは GLFW_NOT_INITIALIZED、 GLFW_NO_WINDOW_CONTEXT、 GLFW_PLATFORM_ERROR です。</p><p><strong>スレッドセーフ</strong>:</p><p>この関数はどのスレッドからでも呼び出すことができる。</p><p><strong>参照</strong>:</p><ul><li>Current context</li><li>glfwGetCurrentContext</li></ul><p><strong>追加</strong>:</p><p>バージョン3.0で追加。</p></details><details class="details custom-block"><summary><code>glfwGetCurrentContext()</code></summary><p>この関数は、OpenGLまたはOpenGL ESのコンテキストが呼び出し元のスレッドで現在使用されているウィンドウを返します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWwindow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetCurrentContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>戻り値</strong>:</p><p>現在のコンテキストを持つウィンドウ、または現在のコンテキストを持つウィンドウがない場合はNULL。</p><p><strong>エラー</strong>:</p><p>考えられるエラーはGLFW_NOT_INITIALIZED。</p><p><strong>スレッドセーフ</strong>:</p><p>この関数はどのスレッドからでも呼び出すことができる。</p><p><strong>参照</strong>:</p><ul><li>Current context</li><li>glfwMakeContextCurrent</li></ul><p><strong>追加</strong>:</p><p>バージョン3.0で追加。</p></details><details class="details custom-block"><summary><code>glfwSwapInterval()</code></summary><p>この関数は、現在のOpenGLまたはOpenGL ESコンテキストのスワップ間隔を設定します。つまり、バッファをスワップして戻る前に、glfwSwapBuffersが呼び出された時点から待機する画面更新の数を設定します。これは垂直同期、垂直リトレース同期、または単にvsyncと呼ばれることがあります。</p><p>WGL_EXT_swap_control_tearおよびGLX_EXT_swap_control_tear拡張のいずれかをサポートするコンテキストは、負のスワップ間隔も受け付けます。これらの拡張がサポートされているかどうかは glfwExtensionSupported で確認できます。</p><p>コンテキストは、呼び出すスレッド上でカレントでなければならない。現在のコンテキストなしでこの関数を呼び出すと GLFW_NO_CURRENT_CONTEXT エラーが発生します。</p><p>この関数はVulkanには適用されません。Vulkanでレンダリングする場合は、代わりにスワップチェーンの現在のモードを参照してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwSwapInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>引数</strong>:</p><ul><li><code>[in] interval</code>: glfwSwapBuffersによってバッファがスワップされるまで待つ画面更新の最小回数。</li></ul><p><strong>エラー</strong>:</p><p>起こりうるエラーは、GLFW_NOT_INITIALIZED、 GLFW_NO_CURRENT_CONTEXT、GLFW_PLATFORM_ERRORである。</p><p><strong>備考</strong>:</p><p>この関数はコンテキストの作成中には呼び出されず、スワップ間隔をそのプラットフォームのデフォルト値のままにしておく。これは、GLFW が使用するスワップ間隔拡張の中には、スワップ間隔を一度ゼロ以外の値に設定するとゼロにリセットできないものがあるためである。</p><p>一部のGPUドライバは、アプリケーションの要求を上書きするユーザー設定やドライバのバグが原因で、要求されたスワップ間隔を守らないことがあります。</p><p><strong>スレッドセーフ</strong>:</p><p>この関数はどのスレッドからでも呼び出すことができる。</p><p><strong>参照</strong>:</p><ul><li>Buffer swapping</li><li>glfwSwapBuffers</li></ul><p><strong>追加</strong>:</p><p>バージョン1.0で追加。</p></details><details class="details custom-block"><summary><code>glfwExtensionSupported()</code></summary><p>この関数は、指定されたAPI拡張が現在のOpenGLまたはOpenGL ESコンテキストでサポートされているかどうかを返します。クライアントAPI拡張とコンテキスト作成API拡張の両方を検索します。</p><p>コンテキストは呼び出し元のスレッドで現在使用されている必要があります。現在のコンテキストなしでこの関数を呼び出すと、GLFW_NO_CURRENT_CONTEXTエラーが発生します。</p><p>この関数は呼び出すたびに1つ以上の拡張文字列を検索するので、頻繁に使用する場合は結果をキャッシュしておくことを推奨します。拡張文字列はコンテキストの有効期間中に変更されることはないので、これを行うことに危険はありません。</p><p>この関数はVulkanには適用されません。Vulkan を使用している場合は、代わりに glfwGetRequiredInstanceExtensions, vkEnumerateInstanceExtensionProperties, vkEnumerateDeviceExtensionProperties を参照してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwExtensionSupported</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> extension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>引数</strong>:</p><ul><li><code>[in] extension</code>: ASCIIエンコードされた拡張子の名前。</li></ul><p><strong>戻り値</strong>:</p><p>拡張が利用可能であれば GLFW_TRUE、そうでなければ GLFW_FALSE。</p><p><strong>エラー</strong>:</p><p>起こりうるエラーはGLFW_NOT_INITIALIZED、 GLFW_NO_CURRENT_CONTEXT、 GLFW_INVALID_VALUE、 GLFW_PLATFORM_ERRORである。</p><p><strong>スレッドセーフ</strong>:</p><p>この関数はどのスレッドからでも呼び出すことができる。</p><p><strong>参照</strong>:</p><ul><li>OpenGL and OpenGL ES extensions</li><li>glfwGetProcAddress</li></ul><p><strong>追加</strong>:</p><p>バージョン1.0で追加。</p></details><details class="details custom-block"><summary><code>glfwGetProcAddress()</code></summary><p>この関数は、指定されたOpenGLまたはOpenGL ESコアまたは拡張関数のアドレスを返します（現在のコンテキストでサポートされている場合）。</p><p>コンテキストは、呼び出し元のスレッドでカレントでなければなりません。現在のコンテキストなしでこの関数を呼び出すと、GLFW_NO_CURRENT_CONTEXTエラーが発生します。</p><p>この関数はVulkanには適用されません。Vulkanでレンダリングする場合は、代わりにglfwGetInstanceProcAddress、vkGetInstanceProcAddr、vkGetDeviceProcAddrを参照してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWglproc </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetProcAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> procname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>引数</strong>:</p><ul><li><code>[in] procname</code>: ASCIIエンコードされた関数名。</li></ul><p><strong>戻り値</strong>:</p><p>関数のアドレス。エラーが発生した場合は NULL。</p><p><strong>エラー</strong>:</p><p>起こりうるエラーは、GLFW_NOT_INITIALIZED、 GLFW_NO_CURRENT_CONTEXT、GLFW_PLATFORM_ERRORである。</p><p><strong>備考</strong>:</p><p>与えられた関数のアドレスは、コンテキスト間で同じであることは保証されない。</p><p>この関数は、関連するバージョンや拡張が利用できないにもかかわらず、NULLでないアドレスを返すことがある。常に、最初にコンテキストのバージョンまたは拡張子の文字列を確認する。</p><p><strong>ポインタの寿命</strong>:</p><p>返された関数ポインターは、コンテキストが破棄されるかライブラリが終了するまで有効である。</p><p><strong>スレッドセーフ</strong>:</p><p>この関数はどのスレッドからでも呼び出すことができる。</p><p><strong>参照</strong>:</p><ul><li>OpenGL and OpenGL ES extensions</li><li>glfwExtensionSupported</li></ul><p><strong>追加</strong>:</p><p>バージョン1.0で追加。</p></details>',13)]))}const k=t(n,[["render",p]]);export{c as __pageData,k as default};
