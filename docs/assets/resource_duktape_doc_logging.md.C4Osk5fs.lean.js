import{_ as t,c as o,a2 as a,o as r}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"Duktape logging framework","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/logging.md","filePath":"resource/duktape/doc/logging.md","lastUpdated":1732350347000}'),n={name:"resource/duktape/doc/logging.md"};function i(l,e,s,g,c,d){return r(),o("div",null,e[0]||(e[0]=[a(`<h1 id="duktape-logging-framework" tabindex="-1">Duktape logging framework <a class="header-anchor" href="#duktape-logging-framework" aria-label="Permalink to &quot;Duktape logging framework&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>Duktape 1.x contains a built-in very minimal logging framework which has a small footprint (around 1kB), reasonably high performance, and makes it easy to change both the frontend and the backend of logging. It is easy to write log entries from both C and ECMAScript, and then redirect all the log output to a custom backend. Lazy formatting is also possible.</p><p>In Duktape 2.x the logging framework was moved into an optional extra (<code>extras/logging</code>) to avoid portability issues on exotic target platforms. The extra has the same feature set as Duktape 1.x built-in logging and provides the same bindings (<code>Duktape.Logger</code> object, <code>duk_log()</code> and <code>duk_log_va()</code> API calls).</p><p>The framework focuses on how logger objects are created and what the logger interface looks like. Other features are quite barebones; for example, the default backend simply writes to the <code>stderr</code> and there is no advanced backend configuration like multiple log outputs. The user can easily replace the frontend and the backend functions to extend the basic feature set in a transparent manner.</p><p>The logging framework also provides API calls to write log entries from C code. This is very convenient, as these log entries will then nicely interleave with log entries written from ECMAScript code.</p><p>The logger object API is close to log4javascript except that there is no special handling for an error object as the last call argument. See:</p><ul><li><a href="http://log4javascript.org/docs/quickstart.html" target="_blank" rel="noreferrer">http://log4javascript.org/docs/quickstart.html</a></li></ul><h2 id="writing-log-entries-from-ecmascript" tabindex="-1">Writing log entries from ECMAScript <a class="header-anchor" href="#writing-log-entries-from-ecmascript" aria-label="Permalink to &quot;Writing log entries from ECMAScript&quot;">​</a></h2><p>A logger object is first created:</p><pre><code>// Without arguments, the logger defaults to the fileName of the call site
var logger = new Duktape.Logger();

// Explicitly name
var logger = new Duktape.Logger(&#39;myLogger&#39;);

// Explicitly unnamed (any non-string argument, null probably best)
var logger = new Duktape.Logger(undefined);
var logger = new Duktape.Logger(null);
</code></pre><p>After a logger has been created, log entries are written with the exposed log writing calls inherited from the logger prototype. There are six log levels, each with its own frontend function. Each log level also has a number (0 to 5) which is used e.g. to control log level, and a 3-letter abbreviation (like INF) used in the log prefix. Some example log calls:</p><pre><code>logger.trace(&#39;loop iteration:&#39;, i, &#39;out of&#39;, n);   // level 0 (TRC)
logger.debug(&#39;objects:&#39;, obj1, obj2, obj3);        // level 1 (DBG)
logger.info(&#39;normal log message&#39;);                 // level 2 (INF)
logger.warn(&#39;exceptional condition&#39;);              // level 3 (WRN)
logger.error(&#39;something went wrong&#39;);              // level 4 (ERR)
logger.fatal(&#39;something went really wrong&#39;);       // level 5 (FTL)
</code></pre><p>The logger functions make a logging decision based on log level. If the entry gets logged, call arguments are formatted into strings, concatenated with spaces, and a prefix is added. The prefix contains a timestamp, the log level, and the logger name. Example:</p><pre><code>duk&gt; logger.info(&#39;test&#39;, 123)
2014-03-19T02:42:20.425Z INF myLogger: test 123
</code></pre><p>Each argument is formatted separately, and if an error is thrown during formatting, the argument is replaced with string coercion of the error. Non-object values are formatted in pure C by the default logger functions to minimize unnecessary calls. Object values are formatted by calling <code>fmt()</code> method of the logger, usually inherited from <code>Duktape.Logger.prototype.fmt()</code>.</p><p>The default object formatting function calls the <code>toLogString()</code> function of the object if it has one, else it simply coerces with <code>String(val)</code>. The <code>toLogString()</code> function is a Duktape custom function which allows the user to control how an object should appear in logs by default.</p><p>Although arguments whose formatting fails get replaced by an error, the logger API does <strong>not</strong> guarantee that no errors can be thrown. For example, if formatting fails and also string coercing the formatting error fails, the latter error will propagate out of the logger. As always, internal errors like out-of-memory or out-of-stack can occur at any time.</p><p>The final log message is passed as a buffer to the logging backend, provided by <code>Duktape.Logger.prototype.raw()</code>. The default implementation writes the log message to <code>stderr</code> and appends a newline. The log message is provided as a buffer (instead of a string) to avoid interning the message unnecessarily. For short messages, a single dynamic buffer is reused over and over by modifying the visible size of the buffer (the dynamic buffer is not reallocated), to eliminate memory churn.</p><p>Logger related properties like the logger name (<code>p</code>), log level (<code>l</code>), and the <code>fmt()</code> and <code>raw()</code> functions are all looked up through the logger instance so that they can overridden either in the prototype, or on a per-logger basis.</p><h2 id="writing-log-entries-from-c" tabindex="-1">Writing log entries from C <a class="header-anchor" href="#writing-log-entries-from-c" aria-label="Permalink to &quot;Writing log entries from C&quot;">​</a></h2><p>The Duktape API provides a snprintf-like log call which allows C code to log to the same backend as ECMAScript code:</p><pre><code>duk_log(ctx, DUK_LOG_INFO, &quot;return value: %d&quot;, rc);
</code></pre><p>Note that if you just want to format a plain string, you <em>must</em> use a <code>%s</code> format to avoid security holes (your string might contain a <code>%</code> which would cause uncontrolled memory accesses):</p><pre><code>const char *my_plain_string = &quot;beware of the %s&quot;;
duk_log(ctx, DUK_LOG_WARN, &quot;%s&quot;, my_plain_string);
</code></pre><p>Log writes from C code use a representative logger instance stored in <code>Duktape.Logger.clog</code>. You can manipulate or replace this logger to control C log writes more explicitly.</p><h2 id="logger-objects" tabindex="-1">Logger objects <a class="header-anchor" href="#logger-objects" aria-label="Permalink to &quot;Logger objects&quot;">​</a></h2><p>Each logger is an object with a few possible properties:</p><ul><li><code>n</code>: name of the logger, added to log lines. If not given, defaults to the <code>fileName</code> of the function where to logger is created. If even that is missing, the value will be missing from the object, and a default value is inherited.</li><li><code>l</code>: minimum log level of the logger. Log writes below this level are dropped. If missing, a default value is inherited.</li></ul><p>Typically, if log levels are not altered, a logger object only contains the <code>n</code> property. Loggers are compacted at creation to ensure a minimal footprint (they very rarely change state).</p><p>Each logger object has as its internal prototype <code>Duktape.Logger.prototype</code>. The prototype provides:</p><ul><li><code>n</code>: a default name (&#39;anon&#39;)</li><li><code>l</code>: a default log level (2, info level)</li><li>log writing methods for each level</li></ul><h2 id="lazy-formatting" tabindex="-1">Lazy formatting <a class="header-anchor" href="#lazy-formatting" aria-label="Permalink to &quot;Lazy formatting&quot;">​</a></h2><p>Lazy formatting is useful when formatting the log arguments is costly and the log line is normally filtered by the log level. This is often the case when debug logging complex values like deep serializations of internal state objects.</p><p>Lazy formatting is easily achievable by using the <code>toLogString()</code> method. The simplest but not very efficient approach is:</p><pre><code>function lazyJx1(obj) {
  return { toLogString: function() { return Duktape.enc(&#39;jx&#39;, obj); } };
}

logger.debug(&#39;complex object:&#39;, lazyJx1(obj));
</code></pre><p>One can use <code>bind()</code> for the same effect (in this particular case):</p><pre><code>function lazyJx2(obj) {
  return { toLogString: Duktape.bind(null, &#39;jx&#39;, obj) };
}

logger.debug(&#39;complex object:&#39;, lazyJx2(obj));
</code></pre><p>Creating a function instance per lazy-logged value is quite expensive. Because the <code>toLogString()</code> is called as a method, lazy values can inherit from a prototype which is reasonably efficient:</p><pre><code>function LazyValue(val) {
  this.v = val;
}
LazyValue.prototype.toLogString = function () {
  return Duktape.enc(&#39;jx&#39;, this.v);
}
function lazyJx3(val) {
  // Per lazy value creation, only creates an object with one property.
  return new LazyValue(val);
}

logger.debug(&#39;complex object:&#39;, lazyJx3(obj));
</code></pre><p>Lazy formatting can also be done inline, though not very readably:</p><pre><code>logger.debug(&#39;data:&#39;, { toLogString: function() { return Duktape.enc(&#39;jx&#39;, data); } });
</code></pre><h2 id="customizing-logging" tabindex="-1">Customizing logging <a class="header-anchor" href="#customizing-logging" aria-label="Permalink to &quot;Customizing logging&quot;">​</a></h2><p>Some options:</p><ul><li>Add a <code>toLogString()</code> method to the prototype of interesting objects to control how they are serialized into strings by the default formatter <code>Duktape.Logger.prototype.fmt()</code>. For instance, you can add the method to <code>Object.prototype</code> to provide better logging for all object values.</li><li>Replace <code>Duktape.Logger.prototype.fmt()</code> for custom formatting of object values.</li><li>Replace <code>Duktape.Logger.prototype.raw()</code> for redirecting formatted log lines to an alternate destination. Be careful to avoid unnecessary memory and string table churn.</li><li>Replace the frontend functions (<code>Duktape.Logger.prototype.info()</code> etc) for custom formatting of log lines. You may also choose not to call <code>Duktape.Logger.prototype.raw()</code> for emitting the formatted log line, but rather interface with your custom backend directly.</li><li>Replace the entire <code>Duktape.Logger</code> constructor and prototype object for full control over logging.</li><li>Of course, you can also use an external logging framework.</li></ul><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h2><p>The built-in logging mechanism has several limitations. Most of them are intentional to keep the logger footprint small:</p><ul><li>Currently a new logger is created regardless of whether or not a previous logger exists with the same name. Sometimes it might desirable to return the same logger instance in this case, so that e.g. the log level can be controlled by finding a logger and operating on it. You can implement this by overriding the constructor.</li><li>There is no way to modify the built-in line format except by overriding the frontend functions (<code>Logger.prototype.info()</code> etc). This is intentional, as having a fixed format makes it easier to log faster and reduce memory churn caused by logging.</li><li>There is no concept of a logging context for C code. Instead, all log writes go through a single logger instance. If multiple global objects exist in the Duktape heap, each global context (or more specifically <code>Duktape.Logger</code> instance) will have its own logger object. Logging from C is usually less of a priority so the logging C API is kept very minimal on purpose.</li></ul><h2 id="existing-frameworks-and-related-links" tabindex="-1">Existing frameworks and related links <a class="header-anchor" href="#existing-frameworks-and-related-links" aria-label="Permalink to &quot;Existing frameworks and related links&quot;">​</a></h2><ul><li><a href="http://ajaxpatterns.org/Javascript_Logging_Frameworks" target="_blank" rel="noreferrer">http://ajaxpatterns.org/Javascript_Logging_Frameworks</a></li><li><a href="http://getfirebug.com/logging" target="_blank" rel="noreferrer">http://getfirebug.com/logging</a></li><li><a href="http://log4javascript.org/docs/quickstart.html" target="_blank" rel="noreferrer">http://log4javascript.org/docs/quickstart.html</a></li><li><a href="http://log4js.berlios.de/" target="_blank" rel="noreferrer">http://log4js.berlios.de/</a></li><li><a href="http://benalman.com/projects/javascript-debug-console-log/" target="_blank" rel="noreferrer">http://benalman.com/projects/javascript-debug-console-log/</a></li></ul><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="format-all-value-types-in-a-useful-manner-by-default" tabindex="-1">Format all value types in a useful manner by default <a class="header-anchor" href="#format-all-value-types-in-a-useful-manner-by-default" aria-label="Permalink to &quot;Format all value types in a useful manner by default&quot;">​</a></h3><p>Like JX, the logger should write useful log entries for all available value types by default. Currently this is not the case for e.g. buffer values.</p><h3 id="reduce-memory-churn" tabindex="-1">Reduce memory churn <a class="header-anchor" href="#reduce-memory-churn" aria-label="Permalink to &quot;Reduce memory churn&quot;">​</a></h3><p>Memory churn can be reduced considerably by string coercing all primitive types (or at least undefined, null, boolean, integer numbers) without going through string interning.</p><h3 id="better-multiline-support" tabindex="-1">Better multiline support <a class="header-anchor" href="#better-multiline-support" aria-label="Permalink to &quot;Better multiline support&quot;">​</a></h3><p>Perhaps duplicate the prefix but perhaps change the final colon to indicate continuation, e.g.:</p><pre><code>&lt;timestamp&gt; INF myLogger: multi
&lt;timestamp&gt; INF myLogger| line
</code></pre><p>Or perhaps:</p><pre><code>&lt;timestamp&gt; INF myLogger: multi
                        | line
</code></pre><h3 id="ascii-sanitization" tabindex="-1">ASCII sanitization <a class="header-anchor" href="#ascii-sanitization" aria-label="Permalink to &quot;ASCII sanitization&quot;">​</a></h3><p>It would be nice if logger output would be guaranteed to be printable ASCII only. This needs handling either in the frontend functions (e.g. for strings) or the final writer function.</p><h3 id="buffer-formatting" tabindex="-1">Buffer formatting <a class="header-anchor" href="#buffer-formatting" aria-label="Permalink to &quot;Buffer formatting&quot;">​</a></h3><p>Buffer data should maybe be formatted in hex encoded form (like JX does). Since buffers are plain objects, they don&#39;t currently go through the formatter, but that would be easy to change.</p><hr><p>Include <code>__FILE__</code> and <code>__LINE__</code> automatically in C log writes somehow?</p>`,66)]))}const p=t(n,[["render",i]]);export{h as __pageData,p as default};
