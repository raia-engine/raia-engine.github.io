import{_ as a,c as t,a2 as n,o as r}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"Duktape 3.0 release notes","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/release-notes-v3-0.md","filePath":"resource/duktape/doc/release-notes-v3-0.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/release-notes-v3-0.md"};function o(s,e,d,l,c,p){return r(),t("div",null,e[0]||(e[0]=[n('<h1 id="duktape-3-0-release-notes" tabindex="-1">Duktape 3.0 release notes <a class="header-anchor" href="#duktape-3-0-release-notes" aria-label="Permalink to &quot;Duktape 3.0 release notes&quot;">​</a></h1><h2 id="release-overview" tabindex="-1">Release overview <a class="header-anchor" href="#release-overview" aria-label="Permalink to &quot;Release overview&quot;">​</a></h2><p>Main changes in this release (see RELEASES.rst for full details):</p><ul><li>Switch to WTF-8 internal string representation. Matching surrogate pairs, both inside ECMAScript strings and in CESU-8 format provided by native code, are automatically combined to non-BMP UTF-8 codepoints; unpaired surrogates remain in CESU-8 style (= WTF-8). Invalid WTF-8 byte sequences are replaced with U+FFFD replacements to guarantee interned strings are now always valid WTF-8. ECMAScript code will still see standard ECMAScript strings where surrogates are individual characters. However, native code now sees standard UTF-8 strings whenever possible (and WTF-8 otherwise), simplifying integration with other UTF-8 based APIs.</li><li>Switch to new internal object property table representation and new property handling code.</li><li>TBD.</li></ul><h2 id="upgrading-from-duktape-2-x" tabindex="-1">Upgrading from Duktape 2.x <a class="header-anchor" href="#upgrading-from-duktape-2-x" aria-label="Permalink to &quot;Upgrading from Duktape 2.x&quot;">​</a></h2><ul><li>If your application deals with UTF-8 and/or CESU-8 string representations, the WTF-8 string representation may change or eliminate some conversion needs.</li><li>Source variants have been removed from the distributable, with the <code>src/</code> directory containing combined sources with default options and <em>without</em> <code>#line</code> directives (previously <code>src-noline/</code>). You can recreate the removed variants using <code>tools/configure.py</code>.</li><li>TBD.</li></ul><h2 id="more-details-on-wtf-8-changes" tabindex="-1">More details on WTF-8 changes <a class="header-anchor" href="#more-details-on-wtf-8-changes" aria-label="Permalink to &quot;More details on WTF-8 changes&quot;">​</a></h2><ul><li>WTF-8 sanitization, i.e. combining of paired surrogates and using U+FFFD replacements for invalid sequences, is applied during the string intern check which ensures all string data created by any means goes through the sanitization.</li><li>WTF-8 sanitization uses U+FFFD replacements for invalid byte sequences. The replacement policy matches <a href="http://unicode.org/review/pr-121.html" target="_blank" rel="noreferrer">http://unicode.org/review/pr-121.html</a> (same as TextDecoder).</li><li>When native code pushes strings, non-BMP codepoints encoded in UTF-8 style (one combined codepoint) and CESU-8 style (surrogate pair encoded as two codepoints) now both result in UTF-8 style being used in the internal string representation. Previously one could push strings in either form and they would behave slightly differently for both native and ECMAScript code.</li><li>ECMAScript now always sees standard strings consisting of 16-bit codepoints, extended codepoint support previously available to ECMAScript code has been removed.</li><li>String.fromCharCode() now always uses standard ToUint16() coercion. The option <code>DUK_USE_NONSTD_STRING_FROMCHARCODE_32BIT</code> has been removed (it allowed non-standard ToUint32() codepoint coercion). The standard function String.fromCodePoint() already allows the creation of non-BMP characters which now appear as UTF-8 to native code.</li></ul>',8)]))}const g=a(i,[["render",o]]);export{u as __pageData,g as default};
