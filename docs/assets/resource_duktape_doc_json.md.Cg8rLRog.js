import{_ as a,c as t,a2 as o,o as i}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"JSON built-in","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/json.md","filePath":"resource/duktape/doc/json.md","lastUpdated":1732350347000}'),r={name:"resource/duktape/doc/json.md"};function n(s,e,l,c,d,u){return i(),t("div",null,e[0]||(e[0]=[o(`<h1 id="json-built-in" tabindex="-1">JSON built-in <a class="header-anchor" href="#json-built-in" aria-label="Permalink to &quot;JSON built-in&quot;">​</a></h1><p>This document describes the Duktape <code>JSON</code> built-in implementation which provides:</p><ul><li>The standard, very strict JSON encoding and decoding required by the ECMAScript standard.</li><li>An extended custom format (JX) which encodes all value types and is optimized for readability. The custom encodings parse back into proper values (except for function values). This format is most useful for dumping values, logging, and the like. The format is not JSON compatible but rather JSON-like.</li><li>An extended compatible format (JC) which also encodes all value types into standard JSON. A standard JSON parser can parse the result but special values need to be revived manually. The result is not as readable as JX, but can be parsed by other JSON implementations.</li></ul><p>There are two code paths for JSON:</p><ul><li>A compliant, fully featured slow path which is always present and handles all cases.</li><li>A JSON.stringify() fast path which can be optionally compiled in. The fast path can be over 10x faster for JSON serialization, and works for a majority of common cases where there are no side effects (such as <code>.toJSON()</code> calls) during the serialization process. An error in the fast path causes a fallback into the slow path. A similar fast path for parsing will probably be added in the future.</li></ul><h2 id="overview-of-json" tabindex="-1">Overview of JSON <a class="header-anchor" href="#overview-of-json" aria-label="Permalink to &quot;Overview of JSON&quot;">​</a></h2><p><a href="http://en.wikipedia.org/wiki/JSON" target="_blank" rel="noreferrer">JSON</a> (JavaScript Object Notation) is a format originally based on a subset of ECMAScript E3, but which is now used by multiple languages and implementations and defined in <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank" rel="noreferrer">RFC 4627</a>. The E5/E5.1 specification has its own more or less compatible definition of JSON. The syntax and processing requirements in Section 15.12 form the basis for implementing the JSON built-in. Note that unlike the RFC 4627 interpretation, E5/E5.1 JSON interpretation is very strict; E5.1 Section 15.12 states:</p><blockquote><p>Conforming implementations of JSON.parse and JSON.stringify must support the exact interchange format described in this specification without any deletions or extensions to the format. This differs from RFC 4627 which permits a JSON parser to accept non-JSON forms and extensions.</p></blockquote><p>JSON only supports nulls, booleans, numbers, strings, objects, and arrays. Non-finite numbers (i.e. NaN and +/- Infinity) are encoded as &quot;null&quot; values while &quot;undefined&quot; values and function objects are skipped entirely.</p><p>ECMAScript JSON only supports 16-bit Unicode codepoints because it operates on ECMAScript strings (which are sequences of 16-bit codepoints). Full transparency for all 16-bit codepoints is required; in particular, even invalid surrogate pairs must be supported. Because Duktape supports codepoints above the 16-bit BMP, support for these will necessarily be non-standard. Such codepoints are now encoded and decoded &quot;as is&quot;, so they pass through encoding and decoding without problems. There is currently no escape syntax for expressing them in escaped form.</p><p>Duktape also has custom types not supported by ECMAScript: buffers and pointers. These are now skipped when encoding (just like function objects). There is currently no syntax for expressing them for parsing.</p><p>The custom JX and JC formats provide support for encoding and decoding &quot;undefined&quot; values, function values, special numbers like NaN, buffer values, and pointer values. Separate API entrypoints are used for JX and JC because JSON.parse() and JSON.stringify() are intended to be strict interfaces.</p><p>See also:</p><ul><li><a href="http://json.org/" target="_blank" rel="noreferrer">http://json.org/</a></li><li><a href="http://bolinfest.com/essays/json.html" target="_blank" rel="noreferrer">http://bolinfest.com/essays/json.html</a></li></ul><h2 id="notes-on-stringify" tabindex="-1">Notes on stringify() <a class="header-anchor" href="#notes-on-stringify" aria-label="Permalink to &quot;Notes on stringify()&quot;">​</a></h2><h3 id="basic-approach-slow-path" tabindex="-1">Basic approach: slow path <a class="header-anchor" href="#basic-approach-slow-path" aria-label="Permalink to &quot;Basic approach: slow path&quot;">​</a></h3><p>Stringify uses a single context structure (<code>duk_json_enc_ctx</code>) whose pointer is passed around the helpers to minimize C call argument counts and also to minimize C stack frame sizes. The encoding context contains a <code>thr</code> pointer, flags, and various (borrowed) value stack references and indices.</p><p>Encoded JSON output is appended to a growing buffer which is converted to the final string at the end. This differs from the specification algorithm which basically concatenates strings in pieces. Unfortunately this concatenation process is out of order for encoding object key/value pairs: JO() will first call Str() and only then decide whether to serialize the property at all (so that key and colon are only emitted if the Str(value) call does not return undefined). Side effects prevent a two-pass &quot;dry run&quot; approach.</p><p>The current implementation avoids this problem by using buffer rewinding to &quot;undo&quot; emitted values which should have been omitted.</p><p>In addition to standard requirements, a C recursion limit is imposed to safeguard against overrunning the stack in stack limited environments.</p><h3 id="basic-approach-fast-path" tabindex="-1">Basic approach: fast path <a class="header-anchor" href="#basic-approach-fast-path" aria-label="Permalink to &quot;Basic approach: fast path&quot;">​</a></h3><p>The optional <code>JSON.stringify()</code> fast path works with the assumption that in most cases side effects won&#39;t occur during serialization so that it&#39;s safe to e.g. iterate over internal data structures directly rather than query for keys and values via actual property lookups. Because actual side effects are not easy to detect, the fast path simply bails out on operations which might potentially have a side effect, such as calling a user <code>.toJSON()</code> method.</p><p>Whenever the fast path code throws an error (for any reason) the slow path is attempted before giving up. This also means the fast path doesn&#39;t need to create useful error messages because they&#39;ll ultimately be ignored from the user&#39;s perspective.</p><p>The fast path can be over 10x faster than the slow path in some situations, so it&#39;s useful for applications which make heavy use of JSON.</p><h3 id="loop-detection" tabindex="-1">Loop detection <a class="header-anchor" href="#loop-detection" aria-label="Permalink to &quot;Loop detection&quot;">​</a></h3><p>The specification uses a stack for loop detection in the beginning of the JO() and JA() algorithms. If the value is already present, an error is thrown; else the value is added to the stack. At the end of JO() and JA() the stack is popped. Note that:</p><ul><li>The stack order does not matter; it is simply used to check whether a value is present anywhere in the stack.</li><li>Only objects and arrays (i.e., heap objects) are ever present in the stack. A single object/array can only be present at most once.</li><li>The maximum stack depth matches object recursion depth. Even for very large JSON documents the maximum stack depth is not necessarily very high.</li></ul><p>The current implementation uses a hybrid implementation for faster loop detection:</p><ul><li>For shallow depths a plain C array referencing objects being visited is used. (Current define is <code>DUK_JSON_ENC_LOOPARRAY</code>.)</li><li>For depths beyond the shallow limit a tracking object is used. The keys of the tracking object are heap pointers formatted with sprintf() <code>%p</code> formatter. Because heap objects have stable pointers in Duktape, this approach is reliable. The upside of this approach is that we don&#39;t need to maintain yet another growing data structure for the stack, and don&#39;t need to do linear stack scans to detect loops. The downside is relatively large memory footprint and lots of additional string table operations. However, these effects only come into play for very deep objects.</li></ul><p>There&#39;s much room for improvement in the loop detection:</p><ul><li>When using the JSON.stringify() fast path, it would be possible to skip loop detection altogether. For a looped object one would then eitehr hit the recursion limit (for deep nesting) or maximum output size limit, and fall back to the slow path which detected the loop and gave a proper error message. For almost all code the performance of JSON.stringify() for a looped object is not critical so hitting these limits instead of detecting the loop quickly should be an OK trade-off.</li></ul><h3 id="propertylist" tabindex="-1">PropertyList <a class="header-anchor" href="#propertylist" aria-label="Permalink to &quot;PropertyList&quot;">​</a></h3><p>When a PropertyList is used, the serialization becomes quite awkward, and requires a linear scan of the PropertyList over and over again. PropertyList is used in the JO() algorithm:</p><ul><li>If PropertyList is defined, K is set to PropertyList.</li><li>If PropertyList is undefined, K is set to a list of property names of the object&#39;s own enumerable properties, in the normal enumeration order.</li><li>The list K is iterated, and non-undefined values are serialized.</li></ul><p>When PropertyList is undefined, the algorithm is clear: simply enumerate the object in the normal way. When PropertyList is not undefined, even non-enumerable properties can be serialized, and serialization order is dictated by PropertyList.</p><p>It might be tempting to serialize the object by going through its properties and then checking against the PropertyList (which would be converted into a hash map for better performance). However, this would be incorrect, as the specification requires that the key serialization order be dictated by PropertyList, not the object&#39;s enumeration order.</p><p>Note that even if serialization could be done by iterating the object keys, it&#39;s not obvious which of the following would be faster:</p><ul><li>Iterate over object properties and compare them against PropertyList (assuming this would be allowed)</li><li>Iterate over the PropertyList, and checking the object for properties</li></ul><p>If the object has only a few properties but PropertyList is long, the former would be faster (if it were allowed); if the object has a lot of properties but PropertyList is short, the latter would be faster.</p><p>Further complications</p><ul><li><p>PropertyList may contain the same property name multiple times. The specification requires that this be detected and duplicate occurrences ignores. The current implementation doesn&#39;t do this:</p><pre><code>JSON.stringify({ foo:1, bar:2 }, [ &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;foo&#39; ]);
--&gt; {&quot;foo&quot;:1,&quot;bar&quot;:2,&quot;foo&quot;:1,&quot;foo&quot;:1}
</code></pre></li><li><p>PropertyList may be sparse which may also cause its natural enumeration order to differ from an increasing array index order, mandated by the E5.1 specification for PropertyList. Currently we just use the natural enumeration order which is correct for non-sparse arrays.</p></li></ul><h3 id="handling-codepoints-above-u-ffff" tabindex="-1">Handling codepoints above U+FFFF <a class="header-anchor" href="#handling-codepoints-above-u-ffff" aria-label="Permalink to &quot;Handling codepoints above U+FFFF&quot;">​</a></h3><p>Codepoints above U+FFFF don&#39;t occur in standard ECMAScript string values, so there is no mandatory behavior when they are encountered during JSON serialization. The current solution is to encode them into plain string data (this matches JC behavior):</p><pre><code>&quot;foo bar: U+12345678&quot;
</code></pre><h3 id="handling-invalid-utf-8-cesu-8-data" tabindex="-1">Handling invalid UTF-8/CESU-8 data <a class="header-anchor" href="#handling-invalid-utf-8-cesu-8-data" aria-label="Permalink to &quot;Handling invalid UTF-8/CESU-8 data&quot;">​</a></h3><p>Standard ECMAScript values are always valid CESU-8 data internally, so handling invalid UTF-8/CESU-8 data has no mandatory behavior. The current solution is:</p><ul><li>If UTF-8/CESU-8 decoding fails, treat the initial byte as a codepoint value directly (interpreting it as an 8-bit unsigned value) and advance by one byte in the input stream. The replacement codepoint is encoded into the output value.</li><li>The current UTF-8/CESU-8 decoding is not strict, so this is mainly triggered for invalid initial bytes (e.g. 0xFF) or when a codepoint has been truncated (end of buffer).</li></ul><p>This is by no means an optimal solution and produces quite interesting results at times.</p><h3 id="miscellaneous" tabindex="-1">Miscellaneous <a class="header-anchor" href="#miscellaneous" aria-label="Permalink to &quot;Miscellaneous&quot;">​</a></h3><ul><li>It would be nice to change the standard algorithm to be based around a &quot;serializeValue()&quot; primitive. However, the standard algorithm provides access to the &quot;holder&quot; of the value, especially in E5 Section 15.12.3, Str() algorithm, step 3.a: the holder is passed to the ReplacerFunction. This exposes the holder to user code.</li><li>Similarly, serialization of a value &#39;val&#39; begins from a dummy wrapper object: <code>{ &quot;&quot;: val }</code>. This seems to be quite awkward and unnecessary. However, the wrapper object is accessible to the ReplacerFunction, so it cannot be omitted, at least when a replacer function has been given.</li><li>String serialization should be fast for pure ASCII strings as they are very common. Unfortunately we may still need to escape characters in them, so there is no explicit fast path now. We could use ordinary character lookups during serialization (note that ASCII string lookups would not affect the stringcache). This would be quite slow, so we decode the extended UTF-8 directly instead, with a fast path for ASCII.</li><li>The implementation uses an &quot;unbalanced value stack&quot; here and there. In other words, the value stack at a certain point in code may contain a varying amount and type of elements, depending on which code path was taken to arrive there. This is useful in many cases, but care must be taken to use proper indices to manipulate the value stack, and to restore the value stack state when unwinding.</li></ul><h2 id="notes-on-parse" tabindex="-1">Notes on parse() <a class="header-anchor" href="#notes-on-parse" aria-label="Permalink to &quot;Notes on parse()&quot;">​</a></h2><h3 id="basic-approach" tabindex="-1">Basic approach <a class="header-anchor" href="#basic-approach" aria-label="Permalink to &quot;Basic approach&quot;">​</a></h3><p>Like stringify(), parse() uses a single context structure (<code>duk_json_dec_ctx</code>).</p><p>An important question in JSON parsing is how to implement the lexer component. One could reuse the ECMAScript lexer (with behavior flags); however, this is not trivial because the JSON productions, though close, contain many variances to similar ECMAScript productions (see below for discussion). The current approach is to use a custom JSON lexer. It would be nice if some shared code could be used in future versions.</p><p>Parsing is otherwise quite straightforward: parsed values are pushed to the value stack and added piece by piece into container objects (arrays and objects). String data is x-UTF-8-decoded on-the-fly, with ASCII codepoints avoiding an actual decode call (note that all JSON punctuators are ASCII characters). Non-ASCII characters will be decoded and re-encoded. Currently no byte/character lookahead is necessary.</p><p>Once basic parsing is complete, a possible recursive &quot;reviver&quot; walk is performed.</p><p>A C recursion limit is imposed for parse(), just like stringify().</p><h3 id="comparison-of-json-and-ecmascript-syntax" tabindex="-1">Comparison of JSON and ECMAScript syntax <a class="header-anchor" href="#comparison-of-json-and-ecmascript-syntax" aria-label="Permalink to &quot;Comparison of JSON and ECMAScript syntax&quot;">​</a></h3><h4 id="jsonwhitespace" tabindex="-1">JSONWhiteSpace <a class="header-anchor" href="#jsonwhitespace" aria-label="Permalink to &quot;JSONWhiteSpace&quot;">​</a></h4><p>JSONWhiteSpace does not have a direct ECMAScript syntax equivalent.</p><p>JSONWhiteSpace is defined as:</p><pre><code>JSONWhiteSpace::
    &lt;TAB&gt;
    &lt;CR&gt;
    &lt;LF&gt;
    &lt;SP&gt;
</code></pre><p>whereas ECMAScript WhiteSpace and LineTerminator are:</p><pre><code>WhiteSpace::
    &lt;TAB&gt;
    &lt;VT&gt;
    &lt;FF&gt;
    &lt;SP&gt;
    &lt;NBSP&gt;
    &lt;BOM&gt;
    &lt;USP&gt;

LineTerminator::
    &lt;LF&gt;
    &lt;CR&gt;
    &lt;LS&gt;
    &lt;PS&gt;
</code></pre><p>Because JSONWhiteSpace includes line terminators, the closest ECMAScript equivalent is WhiteSpace + LineTerminator. However, that includes several additional characters.</p><h4 id="jsonstring" tabindex="-1">JSONString <a class="header-anchor" href="#jsonstring" aria-label="Permalink to &quot;JSONString&quot;">​</a></h4><p>JSONString is defined as:</p><pre><code>JSONString::
    &quot; JSONStringCharacters_opt &quot;

JSONStringCharacters::
    JSONStringCharacter JSONStringCharacters_opt

JSONStringCharacter::
    SourceCharacter but not one of &quot; or \\ or U+0000 through U+001F
    \\ JSONEscapeSequence

JSONEscapeSequence ::
    JSONEscapeCharacter
    UnicodeEscapeSequence

JSONEscapeCharacter :: one of
    &quot; / \\ b f n r t
</code></pre><p>The closest equivalent is ECMAScript StringLiteral with only the double quote version accepted:</p><pre><code>StringLiteral::
    &quot; DoubleStringCharacters_opt &quot;
    &#39; SingleStringCharacters_opt &#39;

DoubleStringCharacters::
    DoubleStringCharacter DoubleStringCharacters_opt

DoubleStringCharacter::
    SourceCharacter but not one of &quot; or \\ or LineTerminator
    \\ EscapeSequence
    LineContinuation

SourceCharacter: any Unicode code unit
</code></pre><p>Other differences include:</p><ul><li>ECMAScript DoubleStringCharacter accepts source characters between U+0000 and U+001F (except U+000A and U+000D, which are part of LineTerminator). JSONStringCharacter does not.</li><li>ECMAScript DoubleStringCharacter accepts LineContinuation, JSONStringCharacter does not.</li><li>ECMAScript DoubleStringCharacter accepts and parses broken escapes as single-character identity escapes, e.g. the string &quot;\\u123&quot; is parsed as &quot;u123&quot;. This happens because EscapeSequence contains a NonEscapeCharacter production which acts as an &quot;escape hatch&quot; for such cases. JSONStringCharacter is strict and will cause a SyntaxError for such escapes.</li><li>ECMAScript EscapeSequence accepts single quote escape (&quot;\\&#39;&quot;), JSONEscapeSequence does not.</li><li>ECMAScript EscapeSequence accepts zero escape (&quot;\\0&quot;), JSONEscapeSequence does not.</li><li>ECMAScript EscapeSequence accepts hex escapes (&quot;\\xf7&quot;), JSONEscapeSequence does not.</li><li>JSONEscapeSquence accepts forward slash escape (&quot;\\/&quot;). ECMAScript EscapeSequence has no explicit support for it, but it is accepted through the NonEscapeCharacter production.</li></ul><p>Note that JSONEscapeSequence is a proper subset of EscapeSequence.</p><h4 id="jsonnumber" tabindex="-1">JSONNumber <a class="header-anchor" href="#jsonnumber" aria-label="Permalink to &quot;JSONNumber&quot;">​</a></h4><p>JSONNumber is defined as:</p><pre><code>JSONNumber::
    -_opt DecimalIntegerLiteral JSONFraction_opt ExponentPart_opt
</code></pre><p>ECMAScript NumericLiteral and DecimalLiteral:</p><pre><code>NumericLiteral::
    DecimalLiteral | HexIntegerLiteral

DecimalLiteral::
    DecimalIntegerLiteral . DecimalDigits_opt ExponentPart_opt
    . DecimalDigits ExponentPart_opt
    DecimalIntegerLiteral ExponentPart_opt

...
</code></pre><p>Another close match would be StrDecimalLiteral:</p><pre><code>StrDecimalLiteral::
    StrUnsignedDecimalLiteral
    + StrUnsignedDecimalLiteral
    - StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral::
    Infinity
    DecimalDigits . DecimalDigits_opt ExponentPart_opt
    . DecimalDigits ExponentPart_opt
</code></pre><p>Some differences between JSONNumber and DecimalLiteral:</p><ul><li>NumericLiteral allows either DecimalLiteral (which is closest to JSONNumber) and HexIntegerLiteral. JSON does not allow hex literals.</li><li>JSONNumber is a <em>almost</em> proper subset of DecimalLiteral: <ul><li>DecimalLiteral allows period without fractions (e.g. &quot;1.&quot; === &quot;1&quot;), JSONNumber does not.</li><li>DecimalLiteral allows a number to begin with a period without a leading zero (e.g. &quot;.123&quot;), JSONNumber does not.</li><li>DecimalLiteral does not allow leading zeros (although many implementations allow them and may parse them as octal; e.g. V8 will parse &quot;077&quot; as octal and &quot;099&quot; as decimal). JSONNumber does not allow octals, and given that JSON is a strict syntax in nature, parsing octals or leading zeroes should not be allowed.</li><li>However, JSONNumber allows a leading minus sign, DecimalLiteral does not. For ECMAScript code, the leading minus sign is an unary minus operator, and it not part of the literal.</li></ul></li><li>There are no NaN or infinity literals. There are no such literals for ECMAScript either but they become identifier references and <em>usually</em> evaluate to useful constants.</li></ul><h4 id="jsonnullliteral" tabindex="-1">JSONNullLiteral <a class="header-anchor" href="#jsonnullliteral" aria-label="Permalink to &quot;JSONNullLiteral&quot;">​</a></h4><p>Trivially the same as NullLiteral.</p><h4 id="jsonbooleanliteral" tabindex="-1">JSONBooleanLiteral <a class="header-anchor" href="#jsonbooleanliteral" aria-label="Permalink to &quot;JSONBooleanLiteral&quot;">​</a></h4><p>Trivially the same as BooleanLiteral.</p><h2 id="extended-custom-encoding-jx" tabindex="-1">Extended custom encoding (JX) <a class="header-anchor" href="#extended-custom-encoding-jx" aria-label="Permalink to &quot;Extended custom encoding (JX)&quot;">​</a></h2><p>The extended custom encoding format (JX, controlled by the define <code>DUK_USE_JX</code>) extends the JSON syntax in an incompatible way, with the goal of serializing as many values as faithfully and readably as possible, with as many values as possible parsing back into an accurate representation of the original value. All results are printable ASCII to be maximally useful in embedded environments.</p><h3 id="undefined" tabindex="-1">Undefined <a class="header-anchor" href="#undefined" aria-label="Permalink to &quot;Undefined&quot;">​</a></h3><p>The <code>undefined</code> value is encoded as:</p><pre><code>undefined
</code></pre><h3 id="string-values" tabindex="-1">String values <a class="header-anchor" href="#string-values" aria-label="Permalink to &quot;String values&quot;">​</a></h3><p>Unicode codepoints above U+FFFF are escaped with an escape format borrowed from Python:</p><pre><code>&quot;\\U12345678&quot;
</code></pre><p>For codepoints between U+0080 and U+00FF a short escape format is used:</p><pre><code>&quot;\\xfc&quot;
</code></pre><p>When encoding, the shortest escape format is used. When decoding input values, any escape formats are allowed, i.e. all of the following are equivalent:</p><pre><code>&quot;\\U000000fc&quot;
&quot;\\u00fc&quot;
&quot;\\xfc&quot;
</code></pre><h3 id="number-values" tabindex="-1">Number values <a class="header-anchor" href="#number-values" aria-label="Permalink to &quot;Number values&quot;">​</a></h3><p>Special numbers are serialized in their natural ECMAScript form:</p><pre><code>NaN
Infinity
-Infinity
</code></pre><h3 id="function-values" tabindex="-1">Function values <a class="header-anchor" href="#function-values" aria-label="Permalink to &quot;Function values&quot;">​</a></h3><p>Function values are serialized as:</p><pre><code>{_func:true}
</code></pre><p>Function values do not survive an encoding round trip. The decode result will be an object which has a <code>_func</code> key.</p><h3 id="buffer-values" tabindex="-1">Buffer values <a class="header-anchor" href="#buffer-values" aria-label="Permalink to &quot;Buffer values&quot;">​</a></h3><p>Plain buffer values and Buffer object values are serialized in hex form:</p><pre><code>|deadbeef|
</code></pre><h3 id="pointer-values" tabindex="-1">Pointer values <a class="header-anchor" href="#pointer-values" aria-label="Permalink to &quot;Pointer values&quot;">​</a></h3><p>Plain pointer values and Pointer object values are serialized in a platform specific form, using the format <code>(%p)</code>, e.g.:</p><pre><code>(0x1ff0e10)          // 32-bit Linux
(000FEFF8)           // 32-bit Windows
(000000000026A8A0)   // 64-bit Windows
</code></pre><p>A pointer value parses back correctly when serialized and parsed by the same program. Other than that there is no guarantee that a pointer value can be parsed back across different Duktape builds. Note that pointer format may differ between compilers even on the same platform.</p><p>If the pointer value doesn&#39;t parse back, with <code>sscanf()</code> and <code>%p</code> format applied to the value between the parentheses, the value is replaced by a NULL pointer during parsing. This is probably more useful than throwing an error.</p><p><code>NULL</code> pointers are serialized in a platform independent way as:</p><pre><code>(null)
</code></pre><h3 id="ascii-only-output" tabindex="-1">ASCII only output <a class="header-anchor" href="#ascii-only-output" aria-label="Permalink to &quot;ASCII only output&quot;">​</a></h3><p>The output for JX encoding is always ASCII only. The standard ECMAScript JSON encoding retains Unicode characters outside the ASCII range as is (deviating from this would be non-compliant) which is often awkward in embedded environments.</p><p>The codepoint U+007F, normally not escaped by ECMAScript JSON functions, is also escaped for better compatibility.</p><h3 id="avoiding-key-quotes" tabindex="-1">Avoiding key quotes <a class="header-anchor" href="#avoiding-key-quotes" aria-label="Permalink to &quot;Avoiding key quotes&quot;">​</a></h3><p>Key quotes are omitted for keys which are ASCII and match ECMAScript identifier requirements be encoded without quotes, e.g.:</p><pre><code>{ my_value: 123 }
</code></pre><p>When the key doesn&#39;t fit the requirements, the key is quoted as usual:</p><pre><code>{ &quot;my value&quot;: 123 }
</code></pre><p>The empty string is intentionally not encoded or accepted without quotes (although the encoding would be unambiguous):</p><pre><code>{ &quot;&quot;: 123 }
</code></pre><p>The ASCII identifier format (a subset of the ECMAScript identifier format which also allows non-ASCII characters) is:</p><pre><code>[a-zA-Z$_][0-9a-zA-Z$_]*
</code></pre><p>This matches almost all commonly used keys in data formats and such, improving readability a great deal.</p><p>When parsing, keys matching the identifier format are of course accepted both with and without quotes.</p><h2 id="compatible-custom-encoding-jc" tabindex="-1">Compatible custom encoding (JC) <a class="header-anchor" href="#compatible-custom-encoding-jc" aria-label="Permalink to &quot;Compatible custom encoding (JC)&quot;">​</a></h2><p>The compatible custom encoding format (JC, controlled by the define <code>DUK_USE_JC</code>) is intended to provide a JSON interface which is more useful than the standard ECMAScript one, while producing JSON values compatible with the ECMAScript and other JSON parsers.</p><p>As a general rule, all values which are not ordinarily handled by standard ECMAScript JSON are encoded as object values with a special &quot;marker&quot; key beginning with underscore. Such values decode back as objects and don&#39;t round trip in the strict sense, but are nevertheless detectable and even (manually) revivable to some extent.</p><h3 id="undefined-1" tabindex="-1">Undefined <a class="header-anchor" href="#undefined-1" aria-label="Permalink to &quot;Undefined&quot;">​</a></h3><p>The <code>undefined</code> value is encoded as:</p><pre><code>{&quot;_undef&quot;:true}
</code></pre><h3 id="string-values-1" tabindex="-1">String values <a class="header-anchor" href="#string-values-1" aria-label="Permalink to &quot;String values&quot;">​</a></h3><p>Unicode codepoints above U+FFFF are escaped into plain text as follows:</p><pre><code>&quot;U+12345678&quot;
</code></pre><p>This is not ideal, but retains at least some of the original information and is ECMAScript compatible.</p><p>BMP codepoints are encoded as in standard JSON.</p><h3 id="number-values-1" tabindex="-1">Number values <a class="header-anchor" href="#number-values-1" aria-label="Permalink to &quot;Number values&quot;">​</a></h3><p>Special numbers are serialized as follows:</p><pre><code>{&quot;_nan&quot;:true}
{&quot;_inf&quot;:true}
{&quot;_ninf&quot;:true}
</code></pre><h3 id="function-values-1" tabindex="-1">Function values <a class="header-anchor" href="#function-values-1" aria-label="Permalink to &quot;Function values&quot;">​</a></h3><p>Function values are serialized as:</p><pre><code>{&quot;_func&quot;:true}
</code></pre><p>Like other special values, function values do not survive an encoding round trip.</p><h3 id="buffer-values-1" tabindex="-1">Buffer values <a class="header-anchor" href="#buffer-values-1" aria-label="Permalink to &quot;Buffer values&quot;">​</a></h3><p>Plain buffer values and Buffer object values are serialized in hex form:</p><pre><code>{&quot;_buf&quot;:&quot;deadbeef&quot;}
</code></pre><h3 id="pointer-values-1" tabindex="-1">Pointer values <a class="header-anchor" href="#pointer-values-1" aria-label="Permalink to &quot;Pointer values&quot;">​</a></h3><p>Plain pointer values and Pointer object values are serialized in a platform specific form, using the format <code>%p</code>, but wrapped in a marker table:</p><pre><code>{&quot;_ptr&quot;:&quot;0x1ff0e10&quot;}
</code></pre><p><code>NULL</code> pointers are serialized in a platform independent way as:</p><pre><code>{&quot;_ptr&quot;:&quot;null&quot;}
</code></pre><p>Note that compared to JX, the difference is that there are no surrounding parentheses outside the pointer value.</p><h3 id="ascii-only-output-1" tabindex="-1">ASCII only output <a class="header-anchor" href="#ascii-only-output-1" aria-label="Permalink to &quot;ASCII only output&quot;">​</a></h3><p>Like JX, the output for JC encoding is always ASCII only, and the codepoint U+007F is also escaped.</p><h3 id="key-quoting" tabindex="-1">Key quoting <a class="header-anchor" href="#key-quoting" aria-label="Permalink to &quot;Key quoting&quot;">​</a></h3><p>Unlike JX, keys are always quoted to remain compatible with standard JSON.</p><h2 id="custom-formats-used-by-other-implementations" tabindex="-1">Custom formats used by other implementations <a class="header-anchor" href="#custom-formats-used-by-other-implementations" aria-label="Permalink to &quot;Custom formats used by other implementations&quot;">​</a></h2><p>(This is quite incomplete.)</p><h3 id="python" tabindex="-1">Python <a class="header-anchor" href="#python" aria-label="Permalink to &quot;Python&quot;">​</a></h3><p>Python uses the following NaN and infinity serializations (<a href="http://docs.python.org/2/library/json.html" target="_blank" rel="noreferrer">http://docs.python.org/2/library/json.html</a>):</p><pre><code>$ python
Python 2.7.3 (default, Aug  1 2012, 05:14:39) 
[GCC 4.6.3] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; import json
&gt;&gt;&gt; print(json.dumps({ &#39;k_nan&#39;: numpy.nan, &#39;k_posinf&#39;: numpy.inf, &#39;k_neginf&#39;: -numpy.inf }))
{&quot;k_posinf&quot;: Infinity, &quot;k_nan&quot;: NaN, &quot;k_neginf&quot;: -Infinity}
</code></pre><h3 id="proto-buffer-json-serialization" tabindex="-1">Proto buffer JSON serialization <a class="header-anchor" href="#proto-buffer-json-serialization" aria-label="Permalink to &quot;Proto buffer JSON serialization&quot;">​</a></h3><p>Protocol buffers have a JSON serialization; does not seem relevant:</p><ul><li><a href="http://code.google.com/p/protobuf-json/source/checkout" target="_blank" rel="noreferrer">http://code.google.com/p/protobuf-json/source/checkout</a></li></ul><h3 id="dojox-json-ref" tabindex="-1">Dojox/json/ref <a class="header-anchor" href="#dojox-json-ref" aria-label="Permalink to &quot;Dojox/json/ref&quot;">​</a></h3><p>Dojox/json/ref supports object graphs, and refers to objects using a marker object with a special key, <code>$ref</code>.</p><ul><li><a href="http://dojotoolkit.org/reference-guide/1.8/dojox/json/ref.html" target="_blank" rel="noreferrer">http://dojotoolkit.org/reference-guide/1.8/dojox/json/ref.html</a></li></ul><p>Using keys starting with <code>$</code> may be a good candidate for custom types, as it is rarely used for property names.</p><h3 id="aws-cloudformation" tabindex="-1">AWS CloudFormation <a class="header-anchor" href="#aws-cloudformation" aria-label="Permalink to &quot;AWS CloudFormation&quot;">​</a></h3><p>Base64 encoding through a &quot;function&quot; syntax:</p><ul><li><a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html" target="_blank" rel="noreferrer">http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html</a></li></ul><h2 id="rationale-for-custom-formats" tabindex="-1">Rationale for custom formats <a class="header-anchor" href="#rationale-for-custom-formats" aria-label="Permalink to &quot;Rationale for custom formats&quot;">​</a></h2><h3 id="security-and-eval" tabindex="-1">Security and eval() <a class="header-anchor" href="#security-and-eval" aria-label="Permalink to &quot;Security and eval()&quot;">​</a></h3><p>One apparent goal of JSON is to produce string representations which can be safely parsed with <code>eval()</code>. When using custom syntax this property may be lost. For instance, if one uses the custom Python encoding of using <code>NaN</code> to represent a NaN, this <code>eval()</code>s incorrectly if there is a conflicting definition for <code>NaN</code> in the current scope (note that e.g. &quot;NaN&quot; and &quot;undefined&quot; are <em>not</em> ECMAScript literals, but rather normal global identifiers).</p><h3 id="ascii-only-serialization" tabindex="-1">ASCII only serialization <a class="header-anchor" href="#ascii-only-serialization" aria-label="Permalink to &quot;ASCII only serialization&quot;">​</a></h3><p>ASCII only serialization is a useful feature in many embedded applications, as ASCII is a very compatible subset. Unfortunately there is no standard way of guaranteeing an ASCII-only result: the <code>Quote()</code> algorithm will encode all non-ASCII characters as-is.</p><p>Further, the standard ECMAScript JSON interface does not escape U+007F, which is usually considered a &quot;dangerous&quot; character.</p><h3 id="buffer-representation" tabindex="-1">Buffer representation <a class="header-anchor" href="#buffer-representation" aria-label="Permalink to &quot;Buffer representation&quot;">​</a></h3><p>Base64 would be a more compact and often used format for representing binary data. However, base64 data does not allow a programmer to easily parse the binary data (which often represents some structured data, such as a C struct).</p><h3 id="function-representation" tabindex="-1">Function representation <a class="header-anchor" href="#function-representation" aria-label="Permalink to &quot;Function representation&quot;">​</a></h3><p>It would be possible to serialize a function into actual ECMAScript function syntax. This has several problems. First, sometimes the function source may not be available; perhaps the build strips source code from function instances to save space, or perhaps the function is a native one. Second, the result is costly to parse back safely. Third, although seemingly compatible with <code>eval()</code>ing the result, the function will not retain its lexical environment and will thus not always work properly.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="hex-constants" tabindex="-1">Hex constants <a class="header-anchor" href="#hex-constants" aria-label="Permalink to &quot;Hex constants&quot;">​</a></h3><p>Parse hex constants in JX:</p><pre><code>{ foo: 0x1234 }
</code></pre><p>This is useful for e.g. config files containing binary flags, RGB color values, etc.</p><h3 id="comments" tabindex="-1">Comments <a class="header-anchor" href="#comments" aria-label="Permalink to &quot;Comments&quot;">​</a></h3><p>Allow <code>//</code> and/or <code>/* */</code> comment style. This is very useful for config files and such and allowed by several other JSON parsers.</p><h3 id="trailing-commas-in-objects-and-arrays" tabindex="-1">Trailing commas in objects and arrays <a class="header-anchor" href="#trailing-commas-in-objects-and-arrays" aria-label="Permalink to &quot;Trailing commas in objects and arrays&quot;">​</a></h3><p>Allow commas in objects and arrays. Again, useful for config files and such, and also supported by other JSON parsers.</p><h3 id="serialization-depth-limit" tabindex="-1">Serialization depth limit <a class="header-anchor" href="#serialization-depth-limit" aria-label="Permalink to &quot;Serialization depth limit&quot;">​</a></h3><p>Allow caller to impose a serialization depth limit. Attempt to go too deep into object structure needs some kind of marker in the output, e.g.:</p><pre><code>// JX
{ foo: { bar: { quux: ... } } }
{ foo: { bar: { quux: {_limit:true} } } }

// JC
{ foo: { bar: { quux: {&quot;_limit&quot;:true} } } }
</code></pre><h3 id="serialization-size-limit" tabindex="-1">Serialization size limit <a class="header-anchor" href="#serialization-size-limit" aria-label="Permalink to &quot;Serialization size limit&quot;">​</a></h3><p>Imposing a maximum byte size for serialization output would be useful when dealing with untrusted data.</p><h3 id="serializing-ancestors-and-or-non-enumerable-keys" tabindex="-1">Serializing ancestors and/or non-enumerable keys <a class="header-anchor" href="#serializing-ancestors-and-or-non-enumerable-keys" aria-label="Permalink to &quot;Serializing ancestors and/or non-enumerable keys&quot;">​</a></h3><p>JSON serialization currently only considers enumerable own properties. This is quite limiting for e.g. debugging.</p><h3 id="serializing-array-properties" tabindex="-1">Serializing array properties <a class="header-anchor" href="#serializing-array-properties" aria-label="Permalink to &quot;Serializing array properties&quot;">​</a></h3><p>JSON serializes only array elements, but the format could be easily extended to also serialize enumerable properties, e.g. as:</p><pre><code>[ &#39;foo&#39;, &#39;bar&#39;, name: &#39;todo list&#39; ]
</code></pre><h3 id="sorting-keys-for-canonical-encoding" tabindex="-1">Sorting keys for canonical encoding <a class="header-anchor" href="#sorting-keys-for-canonical-encoding" aria-label="Permalink to &quot;Sorting keys for canonical encoding&quot;">​</a></h3><p>If object keys could be sorted, the compact JSON output would be canonical. This would often be useful.</p><h3 id="circular-reference-support" tabindex="-1">Circular reference support <a class="header-anchor" href="#circular-reference-support" aria-label="Permalink to &quot;Circular reference support&quot;">​</a></h3><p>Something along the lines of:</p><ul><li><a href="http://dojotoolkit.org/reference-guide/1.8/dojox/json/ref.html" target="_blank" rel="noreferrer">http://dojotoolkit.org/reference-guide/1.8/dojox/json/ref.html</a></li><li><a href="http://dojotoolkit.org/api/1.5/dojox/json/ref" target="_blank" rel="noreferrer">http://dojotoolkit.org/api/1.5/dojox/json/ref</a></li></ul><p>Dojox/json/ref refers to objects using a marker object with a special key, <code>$ref</code>.</p><h3 id="better-control-over-separators" tabindex="-1">Better control over separators <a class="header-anchor" href="#better-control-over-separators" aria-label="Permalink to &quot;Better control over separators&quot;">​</a></h3><p>E.g. Python JSON API allows caller to set separators in more detail than in the ECMAScript JSON API which only allows setting the &quot;space&quot; string.</p><h3 id="regexp-json-serialization" tabindex="-1">RegExp JSON serialization <a class="header-anchor" href="#regexp-json-serialization" aria-label="Permalink to &quot;RegExp JSON serialization&quot;">​</a></h3><p>Currently RegExps serialize quite poorly:</p><pre><code>duk&gt; JSON.stringify(/foo/)
= {}
</code></pre><h3 id="automatic-revival-of-special-values-when-parsing-jc" tabindex="-1">Automatic revival of special values when parsing JC <a class="header-anchor" href="#automatic-revival-of-special-values-when-parsing-jc" aria-label="Permalink to &quot;Automatic revival of special values when parsing JC&quot;">​</a></h3><p>It would be nice to have an option for reviving special values parsed from JC data. With this, JC and JX formats would round trip equally well.</p><h3 id="expose-encode-decode-primitives-in-a-more-low-level-manner" tabindex="-1">Expose encode/decode primitives in a more low level manner <a class="header-anchor" href="#expose-encode-decode-primitives-in-a-more-low-level-manner" aria-label="Permalink to &quot;Expose encode/decode primitives in a more low level manner&quot;">​</a></h3><p>Allow more direct access to encoding/decoding flags and provide more extensibility with an argument convention better than the one used in ECMAScript JSON API.</p><p>For instance, arguments could be given in a table:</p><pre><code>Duktape.jsonDec(myValue, {
  allowHex: true
});
</code></pre><p>However, passing flags and arguments in objects has a large footprint.</p><h3 id="alternative-to-undefined" tabindex="-1">Alternative to &quot;undefined&quot; <a class="header-anchor" href="#alternative-to-undefined" aria-label="Permalink to &quot;Alternative to \\&quot;undefined\\&quot;&quot;">​</a></h3><p>Because &quot;undefined&quot; is not an actual keyword, it may be bound to an arbitrary value and is thus unsafe to eval. An alternative to &quot;undefined&quot; is &quot;void 0&quot; which always evaluates to undefined, but is a bit cryptic.</p>`,224)]))}const f=a(r,[["render",n]]);export{h as __pageData,f as default};
