import{_ as t,c as i,a2 as o,o as a}from"./chunks/framework.DzmM640o.js";const h=JSON.parse('{"title":"Moving objects to code section","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/objects-in-code-section.md","filePath":"resource/duktape/doc/objects-in-code-section.md","lastUpdated":1732350347000}'),s={name:"resource/duktape/doc/objects-in-code-section.md"};function n(r,e,l,c,d,u){return a(),i("div",null,e[0]||(e[0]=[o('<h1 id="moving-objects-to-code-section" tabindex="-1">Moving objects to code section <a class="header-anchor" href="#moving-objects-to-code-section" aria-label="Permalink to &quot;Moving objects to code section&quot;">​</a></h1><p>For low memory targets it&#39;s be very useful to be able to relocate built-in strings, built-in objects, and even user strings/objects into the code section to avoid RAM usage.</p><p>This document provides some design notes on the issues involved.</p><h2 id="misc-notes" tabindex="-1">Misc notes <a class="header-anchor" href="#misc-notes" aria-label="Permalink to &quot;Misc notes&quot;">​</a></h2><ul><li>Built-ins in code section will be read only, but need to share the same structure as their RAM counterparts (for the most part) to avoid complicating internals too much. Any attempt to write over the structs (flags, refcount, heap next/prev link pointers, etc) may be a segfault, depending on the platform.</li><li>Because internal structures like <code>duk_heaphdr</code>, <code>duk_hstring</code>, and <code>duk_hobject</code> are normally writable, static ROM initializers (which are <code>const</code>) must be eventually cast into non-const pointers. This causes harmless warnings and/or requires a cast workaround to silence the warnings.</li><li>If objects are moved into the code section, their property tables will become fixed. The objects will be implicitly non-extensible, so it&#39;d make sense to mark them as non-extensible explicitly.</li><li>Somewhat unintuitively the properties of non-writable ROM objects need to be &quot;writable&quot; from the ECMAScript attributes perspective to ensure it&#39;s possible to create objects inheriting from the ROM objects and establish overriding properties on the objects created.</li><li>From a mark-and-sweep perspective the built-ins form an island: there can be references to the built-ins from outside, but the built-ins cannot reference values outside. One implication of this is that when mark-and-sweep encounters a read-only built-in, it can stop marking and doesn&#39;t need to recurse further because no heap allocated objects can be reached via the built-ins.</li><li>While most built-ins can be read-only, a lot of user code will expect to see a writable global object. A memory conservative approach for this is to use an empty global object which inherits its (unchanged) properties from a ROM-based global object ancestor.</li><li>Pointer compression of ROM pointers is non-trivial because ROM pointers are outside Duktape heap and because ROM pointers must also be compressed at compile time to create proper static initializers.</li></ul><h2 id="object-structure-fields" tabindex="-1">Object structure fields <a class="header-anchor" href="#object-structure-fields" aria-label="Permalink to &quot;Object structure fields&quot;">​</a></h2><h3 id="duk-heaphdr" tabindex="-1">duk_heaphdr <a class="header-anchor" href="#duk-heaphdr" aria-label="Permalink to &quot;duk_heaphdr&quot;">​</a></h3><ul><li>Can&#39;t update flags. <ul><li>Mark-and-sweep: cannot mark object reachable, temproot, etc. Built-in strings/objects must not be marked &quot;visited&quot;.</li><li>No finalizer support: cannot mark finalizable, finalized. Also no need for finalization because ROM objects don&#39;t need to be freed.</li></ul></li><li>Can&#39;t update refcount. <ul><li>Refcount macros: must check and avoid writing refcount; increases code footprint because affects every INCREF/DECREF. If user code is compiled without refcounts this impact is avoided.</li></ul></li><li>Can&#39;t use prev/next pointers. <ul><li>Objects cannot be queued to e.g. refzero or finalization lists.</li><li>No refcount handling, no refzero queuing, no finalization queueing.</li><li>Pointers are set to NULL.</li></ul></li></ul><h3 id="duk-hstring" tabindex="-1">duk_hstring <a class="header-anchor" href="#duk-hstring" aria-label="Permalink to &quot;duk_hstring&quot;">​</a></h3><ul><li>String hash will be fixed at dist time. <ul><li>Can&#39;t incorporate a dynamic seed into the string hash. The string hash seed must be dropped or fixed at dist time.</li><li>Multiple hash variants must be precomputed.</li></ul></li><li>Strings can be added to the string table, but this would be counterproductive (and unnecessary). <ul><li>Strings don&#39;t have a prev/next pointer at all, string table refers to them from outside.</li><li>But adding built-in strings to the string table would consume ~2-4 bytes per string.</li></ul></li><li>If <code>duk_hstring</code> objects are in code section, their pointers will be outside of Duktape heap. <ul><li>Current solution is for ROM pointers to be compressed specially, see discussion below.</li></ul></li><li>With Duktape 2.1 <code>duk_hstring</code> values have a <code>h_next</code> link pointer for a revised string table structure. <ul><li>This link pointer is unused for ROM strings. It can be used for string data if the structure that follows is empty (assumes no arridx, and no clen field).</li></ul></li></ul><h3 id="duk-hobject" tabindex="-1">duk_hobject <a class="header-anchor" href="#duk-hobject" aria-label="Permalink to &quot;duk_hobject&quot;">​</a></h3><ul><li>Many built-in objects are actually native functions, so the relevant structure is often <code>duk_hnatfunc</code>.</li><li>Heap header will have more bits in use, but no effect otherwise.</li><li>Property table pointer &#39;p&#39; is pointer compressed and assumed to be in Duktape heap at the moment. <ul><li>Solved using ROM pointer compression.</li></ul></li><li>Internal prototype pointer &#39;prototype&#39; is pointer compressed and assumed to be in Duktape heap at the moment. <ul><li>Solved using ROM pointer compression.</li></ul></li><li>Entry, array, and hash sizes are not an issue.</li><li>If hash part is present (for large objects), need to duplicate hash probing in dist code. For lowmem environments hash part is usually disabled, so this should not be necessary in practice.</li></ul><h3 id="duk-hobject-properties-allocation" tabindex="-1">duk_hobject properties allocation <a class="header-anchor" href="#duk-hobject-properties-allocation" aria-label="Permalink to &quot;duk_hobject properties allocation&quot;">​</a></h3><ul><li>There are three layouts: static initializers generated by configure tooling must duplicate each and choose active layout at compile time.</li><li>Property key pointer is <em>not</em> compressed at the moment.</li><li>Property value format depends on packing. To avoid union initializers may need separate <code>duk_tval_string</code>, <code>duk_tval_boolean</code>, etc struct definitions. <ul><li>A lot of variants will be needed for packed and unpacked <code>duk_tval</code>, endianness variants for packed <code>duk_tval</code>, etc.</li><li>Union initializers would be available assuming C99 which might be reasonable for ROM object support.</li></ul></li><li>Property values may contain heap pointers; these are not compressed so this should not be an issue even if pointers are for built-ins moved to code section (objects or strings).</li><li>Property values may be in circular references, so built-in objects may need forward declarations before their actual definition.</li><li>Properties can be accessors; <code>duk_propvalue</code> is a union. Probably best to duplicate into <code>duk_propvalue_dataprop</code> and <code>duk_propvalue_accessorprop</code> so that non-union initializers can be used (which is more portable).</li></ul><h3 id="duk-hnatfunc" tabindex="-1">duk_hnatfunc <a class="header-anchor" href="#duk-hnatfunc" aria-label="Permalink to &quot;duk_hnatfunc&quot;">​</a></h3><p>Same issues as <code>duk_hobject</code> plus the following:</p><ul><li>Function pointer should have no issues.</li><li>Nargs and magic should have no issues.</li></ul><h3 id="duk-hcompfunc" tabindex="-1">duk_hcompfunc <a class="header-anchor" href="#duk-hcompfunc" aria-label="Permalink to &quot;duk_hcompfunc&quot;">​</a></h3><p>Same issues as <code>duk_hobject</code> plus the following:</p><ul><li>Bytecode constants table may refer to ROM builtins, should not be a difficult issue.</li><li>Bytecode needs to be precompiled, which is mainly a tooling issue.</li></ul><h2 id="user-strings-and-objects" tabindex="-1">User strings and objects <a class="header-anchor" href="#user-strings-and-objects" aria-label="Permalink to &quot;User strings and objects&quot;">​</a></h2><p>The initializers for built-in strings and objects are rather arcane:</p><ul><li>To avoid union initializers a lot of concrete initializers where union(s) are replace with specific values are needed. These seem impossible to automate cleanly with e.g. macros.</li><li>At least strings and property tables have variable size initializers. Property tables further have multiple initializer variants depending on chosen object memory layout.</li></ul><p>The best approach for supporting user strings and objects so far is to include them in the dist (genbuiltins) processing:</p><ul><li>User build script runs the dist process, giving YAML metadata file(s) to provide information about user strings and/or objects.</li><li>The user strings and objects are merged with the active built-in strings and objects and then processed normally: all layout variants are generated, arcane initializers are generated etc.</li></ul><p>The downside of this that a fresh dist is required as part of the user build, but this will probably become the normal process for low memory targets anyway to support proper optional built-ins.</p><h2 id="practical-issues" tabindex="-1">Practical issues <a class="header-anchor" href="#practical-issues" aria-label="Permalink to &quot;Practical issues&quot;">​</a></h2><h3 id="avoiding-writes-on-read-only-objects" tabindex="-1">Avoiding writes on read-only objects <a class="header-anchor" href="#avoiding-writes-on-read-only-objects" aria-label="Permalink to &quot;Avoiding writes on read-only objects&quot;">​</a></h3><ul><li>Refcount operations</li><li>Setting/clearing heaphdr or object/string flags</li><li>Reallocating object <code>props</code> allocation (e.g. compact)</li><li>Inserting, deleting, and modifying properties</li><li>Compact, seal, freeze</li><li><code>setPrototypeOf</code>: from ECMAScript code this is prevented because the ROM built-ins are not extensible and setPrototypeOf() fails if the target is not extensible.</li><li><code>duk_set_prototype</code>: from C code allowed for any object, must reject this for read-only objects explicitly.</li></ul><h3 id="dynamic-initializations" tabindex="-1">Dynamic initializations <a class="header-anchor" href="#dynamic-initializations" aria-label="Permalink to &quot;Dynamic initializations&quot;">​</a></h3><ul><li><code>Duktape.modLoaded</code> is established using an initialization JS script. This won&#39;t work with a read-only Duktape; modLoaded has to be part of init data.</li><li><code>Duktape.errCreate</code> and <code>Duktape.errThrow</code> must be established when creating the ROM built-ins as they cannot be set at runtime.</li><li><code>Date.prototype.toGMTString</code> must be the <em>same object reference</em> as <code>Date.prototype.toUTCString</code>. For RAM built-ins this was handled by omitting <code>toGMTString</code> from the init data and inserting it during init. For ROM built-ins both have to be present from the beginning, but must point to the same object.</li></ul><h3 id="compile-time-pointer-compression" tabindex="-1">Compile time pointer compression <a class="header-anchor" href="#compile-time-pointer-compression" aria-label="Permalink to &quot;Compile time pointer compression&quot;">​</a></h3><p>If ROM strings/objects are enabled and pointer compression is used, Duktape must be able to compress and decompress ROM pointers pointing to strings and objects using the user-supplied compression macros. This poses a few issues:</p><ul><li>ROM pointers are outside the Duktape heap which must be accounted for in the compression/decompression macros. A simple approach is to dedicate a certain compressed pointer value range for ROM pointers.</li><li>Compressed ROM pointers are needed to express the static ROM initializers so ROM pointers must compress to values <em>known at compile time</em>. There are at least two basic approaches to this: <ul><li>Require user code to provide a pointer compression macro which supports ROM pointers and can be computed at compile time (which is critical so that the string/object initializer can go into the read only section). This can get very messy.</li><li>Collect a list of ROM pointers in need of compression during genbuiltins (the list itself also going to ROM). Expose this list to the user provided compression macros which can then determine if a certain pointer is a ROM pointer, and use the list index to compute a compressed pointer. For example, if the range <code>[0xf800,0xffff]</code> is dedicated to compressed ROM pointers, the first ROM pointer in the list would compress to 0xf800 + 0 = 0xf800, the second to 0xf800 + 1 = 0xf801, etc. Pointer decompression would similarly recognize that range and use the ROM pointer list to decompress the pointer. Finally, genbuiltins can also compress pointers to that range, assuming it knows the base value (0xf800 here).</li></ul></li></ul><p>For now the approach is based on that ROM pointer table; the integration with user code is not (yet) very clean, see:</p><ul><li><code>examples/cmdline/duk_cmdline_lowmem.c</code></li></ul>',36)]))}const b=t(s,[["render",n]]);export{h as __pageData,b as default};
