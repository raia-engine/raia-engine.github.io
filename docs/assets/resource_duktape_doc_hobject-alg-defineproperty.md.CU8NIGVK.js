import{_ as o,c,a2 as d,o as t}from"./chunks/framework.DPuwY6B9.js";const f=JSON.parse('{"title":"Exposed Object.defineProperty()","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-defineproperty.md","filePath":"resource/duktape/doc/hobject-alg-defineproperty.md","lastUpdated":1732350347000}'),r={name:"resource/duktape/doc/hobject-alg-defineproperty.md"};function a(i,e,n,s,l,h){return t(),c("div",null,e[0]||(e[0]=[d(`<h1 id="exposed-object-defineproperty" tabindex="-1">Exposed Object.defineProperty() <a class="header-anchor" href="#exposed-object-defineproperty" aria-label="Permalink to &quot;Exposed Object.defineProperty()&quot;">​</a></h1><h2 id="original-algorithm" tabindex="-1">Original algorithm <a class="header-anchor" href="#original-algorithm" aria-label="Permalink to &quot;Original algorithm&quot;">​</a></h2><p>The algorithm is specified in E5 Section 15.2.3.6:</p><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>name</code> be <code>ToString(P)</code>. (Note: this may have side effects.)</li><li>Let <code>desc</code> be the result of calling <code>ToPropertyDescriptor</code> with <code>Attributes</code> as the argument.</li><li>Call the <code>[[DefineOwnProperty]]</code> internal method of <code>O</code> with arguments <code>name</code>, <code>desc</code>, and <code>true</code>. (Note: the last argument, <code>true</code>, is the <code>Throw</code> flag.)</li><li>Return <code>O</code>.</li></ol><p>The algorithm returns the object, which allows chaining; for instance:</p><pre><code>var o = {};
Object.defineProperty(o, &#39;foo&#39;,
  { value: &#39;bar&#39; }
).seal();
</code></pre><p><code>ToPropertyDescriptor()</code> is a helper called only from <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code>. It converts a property descriptor expressed as an ECMAScript object into a &quot;specification descriptor&quot;, doing boolean coercions and cross checking the descriptor. For instance, <code>ToPropertyDescriptor()</code> will reject any property descriptor which contains fields indicating it is both a data property descriptor and an accessor property descriptor. Example from Node / V8:</p><pre><code>&gt; var o = {};
&gt; Object.defineProperty(o, &#39;foo&#39;,
...   { value: &#39;bar&#39;, set: function() {} });
TypeError: Invalid property.  A property cannot both
have accessors and be writable or have a value, #&lt;Object&gt;
</code></pre><p>The result of the property descriptor conversion is an &quot;internal descriptor&quot;. Note that unlike when dealing with existing object properties, this descriptor may not be fully populated, i.e. may be missing fields. From an implementation perspective this means that the descriptor needs to be represented differently. The current implementation doesn&#39;t have an explicit representation for the &quot;internal descriptor&quot; which exists for the duration of <code>Object.defineProperty()</code>; the descriptor is represented by a bunch of local variables indicating the presence and coerced values of the descriptor fields (for instance: <code>has_writable</code> and <code>is_writable</code> are separate variables).</p><p>The <code>ToPropertyDescriptor()</code> algorithm is reformulated in the restatements section.</p><p>Other notes:</p><ul><li>The key is coerced to a string leniently while the object is just checked and never coerced.</li><li><code>[[DefineOwnProperty]]</code> is always called with <code>Throw</code> set to <code>true</code>, so the implementation doesn&#39;t need to expose a &quot;throw flag&quot;.</li></ul><h2 id="first-draft" tabindex="-1">First draft <a class="header-anchor" href="#first-draft" aria-label="Permalink to &quot;First draft&quot;">​</a></h2><p>Starting from the original algorithm and inlining both <code>ToPropertyDescriptor()</code> and the <code>[[DefineOwnProperty]]</code> algorithm with exotic behaviors, we get:</p><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>name</code> be <code>ToString(P)</code>. (Note: this may have side effects.)</li><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>desc</code> be a new, empty Property Descriptor.</li><li>If <code>O.[[HasProperty]](&quot;enumerable&quot;)</code> === <code>true</code>, then set <code>desc.[[Enumerable]]</code> to <code>ToBoolean(O.[[Get]](&quot;enumerable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;configurable&quot;)</code> === <code>true</code>, then set <code>desc.[[Configurable]]</code> to <code>ToBoolean(O.[[Get]](&quot;configurable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;value&quot;)</code> === <code>true</code>, then set <code>desc.[[Value]]</code> to <code>O.[[Get]](&quot;value&quot;)</code>.</li><li>If <code>O.[[HasProperty]](&quot;writable&quot;)</code> === <code>true</code>, then set <code>desc.[[Writable]]</code> to <code>ToBoolean(O.[[Get]](&quot;writable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;get&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Get]]</code> to <code>O.[[Get]](&quot;get&quot;)</code>. b. If <code>desc.[[Get]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Get]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If <code>O.[[HasProperty]](&quot;set&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Set]]</code> to <code>O.[[Get]](&quot;set&quot;)</code>. b. If <code>desc.[[Set]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Set]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If either <code>desc.[[Get]]</code> or <code>desc.[[Set]]</code> are present, then: a. If either <code>desc.[[Value]]</code> or <code>desc.[[Writable]]</code> are present, then throw a <code>TypeError</code> exception.</li><li>Let <code>Throw</code> be <code>true</code>.</li><li>Set <code>pendingWriteProtect</code> to <code>false</code>.</li><li>If <code>O</code> is not an <code>Array</code> object, goto SKIPARRAY.</li><li>Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured.</li><li>Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.)</li><li>If <code>P</code> is <code>&quot;length&quot;</code>, then a. If the <code>[[Value]]</code> field of <code>Desc</code> is absent, then goto SKIPARRAY. b. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. c. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, goto REJECTRANGE. d. Set <code>Desc.[[Value]]</code> to <code>newLen</code>. e. If <code>newLen</code> &gt;= <code>oldLen</code>, then goto SKIPARRAY. f. Goto REJECT if <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. g. If <code>Desc.[[Writable]]</code> has the value <code>false</code>: 1. Need to defer setting the <code>[[Writable]]</code> attribute to <code>false</code> in case any elements cannot be deleted. 2. Set <code>pendingWriteProtect</code> to <code>true</code>. 3. Set <code>Desc.[[Writable]]</code> to <code>true</code>. h. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li>Else if <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>index</code> be <code>ToUint32(P)</code>. b. Goto REJECT if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. c. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li><strong>SKIPARRAY</strong>: Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code>: a. If <code>extensible</code> is <code>false</code>, then goto REJECT. b. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. d. Goto SUCCESS.</li><li>Goto SUCCESS, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12). (This also covers the case where every field in <code>Desc</code> is absent.)</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Goto REJECT, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. d. Goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. Goto REJECT, If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, and the <code>[[Value]]</code> field of <code>Desc</code> is present, and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Goto REJECT, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li><strong>VALIDATED:</strong> For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li><strong>SUCCESS:</strong> If <code>O</code> is an <code>Array</code> object: a. If <code>P</code> is <code>&quot;length&quot;</code>, and <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. If <code>pendingWriteProtect</code> is <code>true</code>, update the property (<code>&quot;length&quot;</code>) to have <code>[[Writable]] = false</code>. 4. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. b. If <code>P</code> is an array index and <code>index</code> &gt;= <code>oldLen</code>: 1. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds, because we&#39;ve checked in the pre-step that the <code>&quot;length&quot;</code> is writable, and since <code>P</code> is an array index property, the length must still be writable here.</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. If <code>IsAccessorDescriptor(Desc)</code> is <code>true</code>, then: a. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code>, and <code>false</code> as the arguments. (This removes the magic binding for <code>P</code>.) 2. Else (<code>Desc</code> may be generic or data descriptor): a. If <code>Desc.[[Value]]</code> is present, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>Desc.[[Value]]</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.) b. If <code>Desc.[[Writable]]</code> is present and its value is <code>false</code>, then: 1. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code> and <code>false</code> as arguments. (This removes the magic binding for <code>P</code>, and must happen after a possible update of the variable value.)</li><li>Return <code>O</code>.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return <code>false</code>.</li><li><strong>REJECTRANGE</strong>: Throw a <code>RangeError</code> exception. Note that this is unconditional (thrown even if <code>Throw</code> is <code>false</code>).</li></ol><p>Notes:</p><ul><li>Step 3 is redundant (it comes from <code>ToPropertyDescriptor()</code> because of step 1.</li><li>Since <code>Throw</code> is always <code>true</code>, step 12 can be removed and step 32 changed to throw <code>TypeError</code> unconditionally. Note that <code>Throw</code> is also given as a parameter in step 30.b.2.1 as an argument for an internal <code>[[Put]]</code> to the parameter map. This actually has no effect on behavior (the internal setter will be called, and the <code>Throw</code> flag is not visible to the setter).</li></ul><h2 id="some-cleanup" tabindex="-1">Some cleanup <a class="header-anchor" href="#some-cleanup" aria-label="Permalink to &quot;Some cleanup&quot;">​</a></h2><ol><li>If <code>Type(O)</code> is not <code>Object</code> throw a <code>TypeError</code> exception.</li><li>Let <code>name</code> be <code>ToString(P)</code>. (Note: this may have side effects.)</li><li>Let <code>desc</code> be a new, empty Property Descriptor.</li><li>If <code>O.[[HasProperty]](&quot;enumerable&quot;)</code> === <code>true</code>, then set <code>desc.[[Enumerable]]</code> to <code>ToBoolean(O.[[Get]](&quot;enumerable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;configurable&quot;)</code> === <code>true</code>, then set <code>desc.[[Configurable]]</code> to <code>ToBoolean(O.[[Get]](&quot;configurable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;value&quot;)</code> === <code>true</code>, then set <code>desc.[[Value]]</code> to <code>O.[[Get]](&quot;value&quot;)</code>.</li><li>If <code>O.[[HasProperty]](&quot;writable&quot;)</code> === <code>true</code>, then set <code>desc.[[Writable]]</code> to <code>ToBoolean(O.[[Get]](&quot;writable&quot;))</code>.</li><li>If <code>O.[[HasProperty]](&quot;get&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Get]]</code> to <code>O.[[Get]](&quot;get&quot;)</code>. b. If <code>desc.[[Get]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Get]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If <code>O.[[HasProperty]](&quot;set&quot;)</code> === <code>true</code>, then: a. Set <code>desc.[[Set]]</code> to <code>O.[[Get]](&quot;set&quot;)</code>. b. If <code>desc.[[Set]]</code> !== <code>undefined</code> and <code>IsCallable(desc.[[Set]])</code> === <code>false</code>, then throw a <code>TypeError</code> exception.</li><li>If either <code>desc.[[Get]]</code> or <code>desc.[[Set]]</code> are present, then: a. If either <code>desc.[[Value]]</code> or <code>desc.[[Writable]]</code> are present, then throw a <code>TypeError</code> exception.</li><li>Set <code>pendingWriteProtect</code> to <code>false</code>.</li><li>If <code>O</code> is not an <code>Array</code> object, goto SKIPARRAY.</li><li>Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured.</li><li>Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.)</li><li>If <code>P</code> is <code>&quot;length&quot;</code>, then a. If the <code>[[Value]]</code> field of <code>Desc</code> is absent, then goto SKIPARRAY. b. Let <code>newLen</code> be <code>ToUint32(Desc.[[Value]])</code>. c. If <code>newLen</code> is not equal to <code>ToNumber(Desc.[[Value]])</code>, goto REJECTRANGE. d. Set <code>Desc.[[Value]]</code> to <code>newLen</code>. e. If <code>newLen</code> &gt;= <code>oldLen</code>, then goto SKIPARRAY. f. Goto REJECT if <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. g. If <code>Desc.[[Writable]]</code> has the value <code>false</code>: 1. Need to defer setting the <code>[[Writable]]</code> attribute to <code>false</code> in case any elements cannot be deleted. 2. Set <code>pendingWriteProtect</code> to <code>true</code>. 3. Set <code>Desc.[[Writable]]</code> to <code>true</code>. h. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li>Else if <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>index</code> be <code>ToUint32(P)</code>. b. Goto REJECT if <code>index</code> &gt;= <code>oldLen</code> and <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. c. Goto SKIPARRAY. (Rest of the processing happens in the post-step.)</li><li><strong>SKIPARRAY</strong>: Let <code>current</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> with property name <code>P</code>.</li><li>Let <code>extensible</code> be the value of the <code>[[Extensible]]</code> internal property of <code>O</code>.</li><li>If <code>current</code> is <code>undefined</code>: a. If <code>extensible</code> is <code>false</code>, then goto REJECT. b. If <code>IsGenericDescriptor(Desc)</code> or <code>IsDataDescriptor(Desc)</code> is <code>true</code>, then 1. Create an own data property named <code>P</code> of object <code>O</code> whose <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. c. Else, <code>Desc</code> must be an accessor Property Descriptor so, 1. Create an own accessor property named <code>P</code> of object <code>O</code> whose <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attribute values are described by <code>Desc</code>. If the value of an attribute field of <code>Desc</code> is absent, the attribute of the newly created property is set to its default value. d. Goto SUCCESS.</li><li>Goto SUCCESS, if every field in <code>Desc</code> also occurs in <code>current</code> and the value of every field in <code>Desc</code> is the same value as the corresponding field in <code>current</code> when compared using the <code>SameValue</code> algorithm (E5 Section 9.12). (This also covers the case where every field in <code>Desc</code> is absent.)</li><li>If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code> then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>Desc</code> is true. b. Goto REJECT, if the <code>[[Enumerable]]</code> field of <code>Desc</code> is present and the <code>[[Enumerable]]</code> fields of <code>current</code> and <code>Desc</code> are the Boolean negation of each other.</li><li>If <code>IsGenericDescriptor(Desc)</code> is <code>true</code>, then goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> have different results, then a. Goto REJECT, if the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>. b. If <code>IsDataDescriptor(current)</code> is true, then 1. Convert the property named <code>P</code> of object <code>O</code> from a data property to an accessor property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. c. Else, 1. Convert the property named <code>P</code> of object <code>O</code> from an accessor property to a data property. Preserve the existing values of the converted property&#39;s <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes and set the rest of the property&#39;s attributes to their default values. d. Goto VALIDATED.</li><li>Else, if <code>IsDataDescriptor(current)</code> and <code>IsDataDescriptor(Desc)</code> are both true, then a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code> and the <code>[[Writable]]</code> field of <code>Desc</code> is <code>true</code>. 2. Goto REJECT, If the <code>[[Writable]]</code> field of <code>current</code> is <code>false</code>, and the <code>[[Value]]</code> field of <code>Desc</code> is present, and <code>SameValue(Desc.[[Value]], current.[[Value]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li>Else, <code>IsAccessorDescriptor(current)</code> and <code>IsAccessorDescriptor(Desc)</code> are both <code>true</code> so, a. If the <code>[[Configurable]]</code> field of <code>current</code> is <code>false</code>, then 1. Goto REJECT, if the <code>[[Set]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Set]], current.[[Set]])</code> is <code>false</code>. 2. Goto REJECT, if the <code>[[Get]]</code> field of <code>Desc</code> is present and <code>SameValue(Desc.[[Get]], current.[[Get]])</code> is <code>false</code>. b. Goto VALIDATED.</li><li><strong>VALIDATED:</strong> For each attribute field of <code>Desc</code> that is present, set the correspondingly named attribute of the property named <code>P</code> of object <code>O</code> to the value of the field.</li><li><strong>SUCCESS:</strong> If <code>O</code> is an <code>Array</code> object: a. If <code>P</code> is <code>&quot;length&quot;</code>, and <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. If <code>pendingWriteProtect</code> is <code>true</code>, update the property (<code>&quot;length&quot;</code>) to have <code>[[Writable]] = false</code>. 4. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. b. If <code>P</code> is an array index and <code>index</code> &gt;= <code>oldLen</code>: 1. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds, because we&#39;ve checked in the pre-step that the <code>&quot;length&quot;</code> is writable, and since <code>P</code> is an array index property, the length must still be writable here.</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. If <code>IsAccessorDescriptor(Desc)</code> is <code>true</code>, then: a. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code>, and <code>false</code> as the arguments. (This removes the magic binding for <code>P</code>.) 2. Else (<code>Desc</code> may be generic or data descriptor): a. If <code>Desc.[[Value]]</code> is present, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>Desc.[[Value]]</code>, and <code>true</code> as the arguments. (This updates the bound variable value. Note that the <code>Throw</code> flag is irrelevant, <code>true</code> used now.) b. If <code>Desc.[[Writable]]</code> is present and its value is <code>false</code>, then: 1. Call the <code>[[Delete]]</code> internal method of <code>map</code> passing <code>P</code> and <code>false</code> as arguments. (This removes the magic binding for <code>P</code>, and must happen after a possible update of the variable value.)</li><li>Return <code>O</code>.</li><li><strong>REJECT</strong>: Throw a <code>TypeError</code> exception.</li><li><strong>REJECTRANGE</strong>: Throw a <code>RangeError</code> exception.</li></ol>`,19)]))}const p=o(r,[["render",a]]);export{f as __pageData,p as default};
