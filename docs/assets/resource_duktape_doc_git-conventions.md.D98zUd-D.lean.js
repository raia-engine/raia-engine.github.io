import{_ as a,c as t,a2 as r,o}from"./chunks/framework.CKGreiRV.js";const u=JSON.parse('{"title":"Git conventions","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/git-conventions.md","filePath":"resource/duktape/doc/git-conventions.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/git-conventions.md"};function n(s,e,l,c,h,d){return o(),t("div",null,e[0]||(e[0]=[r(`<h1 id="git-conventions" tabindex="-1">Git conventions <a class="header-anchor" href="#git-conventions" aria-label="Permalink to &quot;Git conventions&quot;">​</a></h1><h2 id="repositories" tabindex="-1">Repositories <a class="header-anchor" href="#repositories" aria-label="Permalink to &quot;Repositories&quot;">​</a></h2><p>The main development repository is hosted on GitHub:</p><ul><li><a href="https://github.com/svaarala/duktape" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape</a></li></ul><p>The duktape.org website is also part of the repository. Up to Duktape 0.12.0 the release binaries were also stored in the Duktape repo. For Duktape 1.0.0 and after the convention is changed to use external binaries; see the Releases section below. The upside of keeping the website in the same repo is that old documentation matching the current checkout is always available.</p><p>There&#39;s a separate repo for release binaries, so that binaries are reliably available but don&#39;t bloat the main repository:</p><ul><li><a href="https://github.com/svaarala/duktape-releases" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape-releases</a></li></ul><p>This repo also provides unpacked release files as tags for convenience.</p><h2 id="issue-tracking" tabindex="-1">Issue tracking <a class="header-anchor" href="#issue-tracking" aria-label="Permalink to &quot;Issue tracking&quot;">​</a></h2><p>Issues are tracked in GitHub, i.e. outside the repository itself.</p><h2 id="releases" tabindex="-1">Releases <a class="header-anchor" href="#releases" aria-label="Permalink to &quot;Releases&quot;">​</a></h2><p>Release versioning follows semantic versioning; for details, see:</p><ul><li><a href="http://duktape.org/guide.html#versioning" target="_blank" rel="noreferrer">http://duktape.org/guide.html#versioning</a></li></ul><p>Release artifacts:</p><ul><li><p>A tag is created for the release (e.g. <code>v1.0.4</code>) in the main repo.</p></li><li><p>A GitHub release is also created for convenience with the end user tar.xz attached to the release:</p><ul><li><a href="https://github.com/blog/1547-release-your-software" target="_blank" rel="noreferrer">https://github.com/blog/1547-release-your-software</a></li></ul><p>The release title should be the same as the release description in the tag.</p></li><li><p>The release tar.xz is added to the duktape-releases repo:</p><ul><li><a href="https://github.com/svaarala/duktape-releases" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape-releases</a></li></ul></li><li><p>The unpacked tar.xz is also added as a tag (on an independent branch) on the duktape-releases repo for convenience. The tag is named <code>vN.N.N</code>. The independent branch used to create the tag is not kept. See <code>release-checklist.rst</code> for detailed commands.</p><ul><li><a href="http://stackoverflow.com/questions/15034390/how-to-create-a-new-and-empty-root-branch" target="_blank" rel="noreferrer">http://stackoverflow.com/questions/15034390/how-to-create-a-new-and-empty-root-branch</a></li><li><a href="http://stackoverflow.com/questions/9034540/how-to-create-a-git-branch-that-is-independent-of-the-master-branch" target="_blank" rel="noreferrer">http://stackoverflow.com/questions/9034540/how-to-create-a-git-branch-that-is-independent-of-the-master-branch</a></li></ul></li><li><p>The releases are also available from <a href="http://duktape.org/" target="_blank" rel="noreferrer">http://duktape.org/</a>.</p></li></ul><h2 id="branch-and-tag-naming" tabindex="-1">Branch and tag naming <a class="header-anchor" href="#branch-and-tag-naming" aria-label="Permalink to &quot;Branch and tag naming&quot;">​</a></h2><p>Development branches:</p><ul><li><code>master</code>: Churn branch with active development, kept close to release quality at all times; unstable features are developed in feature branches.</li><li><code>frob-xyz-tweaks</code>, <code>add-missing-docs</code>, etc.: Relatively short lived branches for developing a particular feature; may be rebased, commits may be squashed, etc. Merged into <code>master</code> when code works, documentation has been updated, etc., and then deleted. There is no fixed branch naming but avoid <code>fix-</code> and <code>bug-</code> prefixes.</li><li><code>fix-xxx</code>: Short lived bug fix branch, otherwise similar to a feature branch. The branch name should begin with <code>fix-</code> to differentiate it from feature development.</li></ul><p>Maintenance branches:</p><ul><li><code>vN.N-maintenance</code>: Maintenance branch for a release, which is used to backport fixes. For example, <code>v1.0-maintenance</code> would be used to release all <code>v1.0.N</code> releases. A maintenance branch is branched off master just before an initial zero patch level release. Release prepping should be done in master so that there&#39;s no need to backport release notes and such.</li><li><code>vN-maintenance</code>: Maintenance branch for a certain major version (e.g. 1.x) which is created when master moves on for development of the next major version.</li></ul><p>Release tags:</p><ul><li><code>vN.N.N</code>: Release tags. All releases are created from a maintenance branch, even the zero patch level version.</li></ul><p>Other conventions:</p><ul><li><p>Rejected branches which may be needed later are tagged so that they don&#39;t clutter up the branch list. Use an annotated tag:</p><pre><code>$ git tag -a -m &quot;archive rejected xyz&quot; -s archive/rejected-xyz xyz-feature
$ git branch -D xyz-feature
</code></pre></li></ul><h2 id="merging" tabindex="-1">Merging <a class="header-anchor" href="#merging" aria-label="Permalink to &quot;Merging&quot;">​</a></h2><p>All features and fixes should be developed in separate branches and merged to master.</p><p>Before merging:</p><ul><li>Ensure test cases pass and broken test cases are fixed to match possible new output.</li><li>Ensure documentation is up-to-date, including both internal and external documentation.</li></ul><p>Branches should be merged with <code>--no-ff</code> to avoid fast forward merges:</p><pre><code>$ git checkout -b frob-xyz-tweaks
# develop...
$ git checkout master
$ git merge --no-ff frob-xyz-tweaks
$ git branch -d frob-xyz-tweaks
</code></pre><h2 id="making-fixes-to-maintenance-branches" tabindex="-1">Making fixes to maintenance branches <a class="header-anchor" href="#making-fixes-to-maintenance-branches" aria-label="Permalink to &quot;Making fixes to maintenance branches&quot;">​</a></h2><ul><li><p>Make fix to master first through a fix branch. This includes code changes, testcase changes, release note update.</p></li><li><p>Check out maintenance branch (e.g. <code>v1.0-maintenance</code>), and git cherry pick fix commits from master. Cherry pick code changes and testcase changes where appropriate (to allow the fix to be tested). <strong>Don&#39;t</strong> update release note in the branch: release notes are only kept up-to-date in master.</p><p>If a lot of commits need to be cherry picked, create a branch and merge to maintenance branch.</p></li><li><p>Git cherry picking:</p><ul><li><a href="http://sleeplessgeek.blogspot.fi/2011/03/using-git-cherry-pick.html" target="_blank" rel="noreferrer">http://sleeplessgeek.blogspot.fi/2011/03/using-git-cherry-pick.html</a></li></ul></li><li><p>Basically:</p><pre><code>$ git cherry-pick &lt;commit&gt;
</code></pre></li></ul><h2 id="commit-messages" tabindex="-1">Commit messages <a class="header-anchor" href="#commit-messages" aria-label="Permalink to &quot;Commit messages&quot;">​</a></h2><p>Merges to master branch must have clean commit messages. Merge commit should retain the default merge heading which should be followed by a descriptive paragraph similar to what the release note updates are. This makes the merge commits useful for getting an overview of what changes have been made and why.</p><p>Commit messages should follow these guidelines:</p><ul><li>Capitalized title line at most 50 characters long, no trailing period. This works best with GitHub and is also a common convention.</li><li>Beneath that use normal sentence structure, bullet lists etc. are OK. No particular format for this part now.</li><li>GitHub compatible messages are nice: <ul><li><a href="https://github.com/blog/926-shiny-new-commit-styles" target="_blank" rel="noreferrer">https://github.com/blog/926-shiny-new-commit-styles</a></li><li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="noreferrer">http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a></li></ul></li></ul>`,36)]))}const m=a(i,[["render",n]]);export{u as __pageData,m as default};
