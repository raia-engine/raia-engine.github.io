import{_ as o,c as t,a2 as c,o as n}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"INSTOF: exposed object class membership check (\\"instanceof\\" operator)","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-instof.md","filePath":"resource/duktape/doc/hobject-alg-instof.md","lastUpdated":1732350347000}'),a={name:"resource/duktape/doc/hobject-alg-instof.md"};function d(r,e,i,l,s,p){return n(),t("div",null,e[0]||(e[0]=[c(`<h1 id="instof-exposed-object-class-membership-check-instanceof-operator" tabindex="-1">INSTOF: exposed object class membership check (&quot;instanceof&quot; operator) <a class="header-anchor" href="#instof-exposed-object-class-membership-check-instanceof-operator" aria-label="Permalink to &quot;INSTOF: exposed object class membership check (\\&quot;instanceof\\&quot; operator)&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>Object class membership check is done using the <code>instanceof</code> operator in ECMAScript code, e.g.:</p><pre><code>print(x instanceof Array);
</code></pre><p>The language semantics of &quot;class membership&quot; are not as clear cut in ECMAScript as in some other languages. But essentially, the <code>instanceof</code> expression above checks whether <code>Array.prototype</code> occurs in the internal prototype chain of <code>x</code>).</p><p>This involves:</p><ul><li>An expression for the left-hand-side</li><li>An expression for the right-hand-side</li><li><code>instanceof</code> semantics (E5 Section 11.8.6)</li><li>A call to <code>[[HasInstance]]</code></li></ul><h2 id="first-draft" tabindex="-1">First draft <a class="header-anchor" href="#first-draft" aria-label="Permalink to &quot;First draft&quot;">​</a></h2><p>The <code>instanceof</code> operator is the only &quot;caller&quot; for <code>[[HasInstance]]</code> and has the following steps (for evaluating RelationalExpression <strong>instanceof</strong> ShiftExpression):</p><ol><li>Let <code>lref</code> be the result of evaluating RelationalExpression.</li><li>Let <code>lval</code> be <code>GetValue(lref)</code>.</li><li>Let <code>rref</code> be the result of evaluating ShiftExpression.</li><li>Let <code>rval</code> be <code>GetValue(rref)</code>.</li><li>If <code>Type(rval)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>If <code>rval</code> does not have a <code>[[HasInstance]]</code> internal method, throw a <code>TypeError</code> exception.</li><li>Return the result of calling the <code>[[HasInstance]]</code> internal method of <code>rval</code> with argument <code>lval</code>.</li></ol><p>For implementing <code>instanceof</code>, steps 1-4 can be assumed to be handled by the compiler and map to a certain bytecode sequence. Steps 5-7 are the relevant part.</p><p>The following algorithm integrates steps 5-7 from above with the combined <code>[[HasInstance]]</code> algorithm (<code>lval</code> is renamed to <code>V</code> and <code>rval</code> to <code>F</code>):</p><ol><li>If <code>Type(F)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>If <code>F</code> does not have a <code>[[HasInstance]]</code> internal method, throw a <code>TypeError</code> exception.</li><li>While <code>F</code> is a bound function: a. Set <code>F</code> to the value of <code>F</code>&#39;s <code>[[TargetFunction]]</code> internal property. b. If <code>F</code> has no <code>[[HasInstance]]</code> internal method, throw a <code>TypeError</code> exception. (Note: <code>F</code> can be another bound function, so we loop until we find the non-bound actual function.)</li><li>If <code>V</code> is not an object, return <code>false</code>.</li><li>Let <code>O</code> be the result of calling the <code>[[Get]]</code> internal method of <code>F</code> with property name <code>&quot;prototype&quot;</code>. (Note: this is the external prototype, not the internal one.)</li><li>If <code>Type(O)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>Repeat a. Let <code>V</code> be the value of the <code>[[Prototype]]</code> internal property of <code>V</code>. b. If <code>V</code> is <code>null</code>, return <code>false</code>. c. If <code>O</code> and <code>V</code> refer to the same object, return <code>true</code>.</li></ol><p>Notes:</p><ul><li>The initial <code>rval</code> may be something other than a callable function, so it needs an explicit check, whereas the <code>[[TargetFunction]]</code> internal property can only exist with a valid callable object value (E5 Section 15.3.4.5, step 2 checks for this).</li><li>Step 3.b seems to be unnecessary: <code>Function.prototype.bind()</code> will not create a bound function whose target function is not callable, so they should always have a <code>[[HasInstance]]</code> internal method. If this is just to add some internal robustness, why not also check that the target function is an object?</li><li>In step 7 we assume that the internal prototype is always an object or <code>null</code>. If the internal implementation does not constrain this fully, it makes sense to check this explicitly. The current implementation uses an <code>duk_hobject</code> pointer for the internal prototype, so the prototype is effectively constrained to be either object or <code>null</code>.</li><li>The loop in step 7 assumes that there are no prototype loops. An explicit sanity check should be inserted.</li></ul><h2 id="cleanup" tabindex="-1">Cleanup <a class="header-anchor" href="#cleanup" aria-label="Permalink to &quot;Cleanup&quot;">​</a></h2><p>Steps 1-3 can be combined to a simpler loop with a bit more paranoid checks:</p><ol><li>Repeat a. If <code>Type(F)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception. b. If <code>F</code> does not have a <code>[[HasInstance]]</code> internal method, throw a <code>TypeError</code> exception. c. If <code>F</code> is a normal (non-bound) function, break repeat loop. d. If <code>F</code> is <em>not</em> a bound function, throw a <code>TypeError</code> exception. (Note: this should never happen, but is nice to check.) e. Set <code>F</code> to the value of <code>F</code>&#39;s <code>[[TargetFunction]]</code> internal property and repeat from a). (Note: <code>F</code> may be another bound function when exiting this step, so we must repeat until the final, non-bound function is found.)</li><li>If <code>V</code> is not an object, return <code>false</code>.</li><li>Let <code>O</code> be the result of calling the <code>[[Get]]</code> internal method of <code>F</code> with property name <code>&quot;prototype&quot;</code>. (Note: this is the external prototype, not the internal one.)</li><li>If <code>Type(O)</code> is not <code>Object</code>, throw a <code>TypeError</code> exception.</li><li>Repeat a. Let <code>V</code> be the value of the <code>[[Prototype]]</code> internal property of <code>V</code>. b. If <code>V</code> is <code>null</code>, return <code>false</code>. c. If <code>O</code> and <code>V</code> refer to the same object, return <code>true</code>.</li></ol>`,18)]))}const f=o(a,[["render",d]]);export{u as __pageData,f as default};
