import{_ as o,c as t,a2 as a,o as r}from"./chunks/framework.CKGreiRV.js";const h=JSON.parse('{"title":"Modules","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/modules.md","filePath":"resource/duktape/doc/modules.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/modules.md"};function n(l,e,d,s,u,c){return r(),t("div",null,e[0]||(e[0]=[a(`<h1 id="modules" tabindex="-1">Modules <a class="header-anchor" href="#modules" aria-label="Permalink to &quot;Modules&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>This document discusses the barebone CommonJS-based module framework built into Duktape 1.x (moved into an optional extra in Duktape 2.x):</p><ul><li>ECMAScript modules are defined using the CommonJS module format: <ul><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noreferrer">http://wiki.commonjs.org/wiki/Modules/1.1.1</a></li><li>Duktape supports also <code>module.exports</code> and a few Duktape specific properties (<code>module.filename</code> and <code>module.name</code>)</li></ul></li><li>The user must provide a <em>module search function</em> which locates a module corresponding to a resolved module ID, and can register module symbols directly and/or return module source code as a string. To remain portable and unaware of file systems and such, Duktape does not provide a default module search function.</li><li>C modules, static or DLL-based, can be implemented on top of the module search function by user code. There is no built-in C module support in the main Duktape library to avoid portability issues for exotic platforms. However, there is a recommended convention which works on most platforms and allows both static and DLL loading, see <code>c-module-convention.rst</code>.</li></ul><h2 id="using-modules-from-ecmascript-code-require" tabindex="-1">Using modules from ECMAScript code (require) <a class="header-anchor" href="#using-modules-from-ecmascript-code-require" aria-label="Permalink to &quot;Using modules from ECMAScript code (require)&quot;">​</a></h2><p>Duktape provides a global <code>require()</code> function which allows a module to be loaded based on a module identifier:</p><pre><code>var lib = require(&#39;package/lib&#39;)
</code></pre><p>The module identifier may contain forward slashes to provide some hierarchy. There are both absolute and relative identifiers:</p><pre><code>// absolute identifier, resolves to &#39;a/b&#39; everywhere
var mod = require(&#39;a/b&#39;);

// relative identifier, resolves to &#39;package/c&#39; inside package/lib
var mod = require(&#39;./c&#39;);

// relative identifier, resolves to &#39;foo/xyz&#39; inside foo/bar/quux
var mod = require(&#39;../xyz&#39;);
</code></pre><p>Relative paths are resolved starting from the absolute root of the current module, i.e. the module calling <code>require()</code>, see separate section on the resolution algorithm.</p><p>A module with a certain resolved identifier is loaded only once per a global environment: <code>Duktape.modLoaded</code> keeps track of modules which are fully or partially loaded, mapping a resolved identifier to the module&#39;s <code>module</code> table. If a required module has already been (fully or partially) loaded, <code>require()</code> will simply return <code>module.exports</code>. (But note that if a module is still being loaded and assigns to <code>module.exports</code>, the return value might be different for a later <code>require()</code> call.)</p><p>If a module has not yet been registered to <code>Duktape.modLoaded</code>, Duktape registers an initial <code>module</code> table to <code>Duktape.modLoaded</code>. It then calls <code>Duktape.modSearch()</code>, a module search function which must be provided by the user (there is no default):</p><pre><code>Duktape.modSearch = function (id, require, exports, module) {
  // ...
};
</code></pre><p>The identifier given to the <code>modSearch()</code> function is a fully resolved, absolute identifier.</p><p>If the search function cannot locate a module based on its identifier, it is expected to throw an error. If a module is found, the search function can register symbols directly to &#39;exports&#39; (this is used to implement C modules), and can also return a string to be used as the module ECMAScript source code:</p><pre><code>/* An actual implementation would usually scan and return module sources
 * e.g. from the filesystem or a compressed source pack.  This example
 * illustrates the return value options.
 */

Duktape.modSearch = function (id, require, exports, module) {
  if (id === &#39;foo&#39;) {
    /* &#39;foo&#39; is a native module, register symbols to &#39;exports&#39; in a
     * platform specific way.
     */
    return;  // undefined: no ECMAScript source
  }
  if (id === &#39;bar&#39;) {
    /* &#39;bar&#39; is a pure ECMAScript module. */
    return &#39;exports.hello = function () { print(&quot;Hello world from bar!&quot;); };&#39;;
  }
  if (id === &#39;quux&#39;) {
    /* &#39;quux&#39; is a mixed C/ECMAScript module.  C code provides the
     * exports.rawFunc() binding while ECMAScript code implements
     * a safe variant on top of that.
     */
    return &#39;exports.func = function () {\\n&#39; +
           &#39;    try { exports.rawFunc(); } catch (e) { print(e); }\\n&#39; +
           &#39;};\\n&#39;;
  }

  /* If a module is not found, an error must be thrown. */
  throw new Error(&#39;cannot find module: &#39; + id);
};
</code></pre><p>The <code>module</code> value is registered to <code>Duktape.modLoaded</code> before the module search function is called (this was changed in Duktape 1.3), so that circular requires are properly supported for both ECMAScript and C modules.</p><p>The user <code>Duktape.modSearch()</code> function encapsulates functionality such as module search paths and file I/O. This is a nice division of labor as it encapsulates practically all of the platform dependent parts of module loading, while keeping the user callback unaware of almost every other aspect of module loading. Using stub module search functions is also easy, which is good for testing.</p><p>ECMAScript modules follow the CommonJS format, e.g. <code>package/lib</code> could be represented by the source file:</p><pre><code>exports.add = function (a, b) {
  return a + b;
};
</code></pre><p>Replacing <code>module.exports</code> is also supported as of Duktape 1.3. Although <code>module.exports</code> is not part of CommonJS, it&#39;s widely supported by other module frameworks, and allows code like:</p><pre><code>module.exports = function adder(a, b) {
  return a + b;
};
</code></pre><p>CommonJS instructs that modules should be evaluated with certain bindings in force. Duktape currently implements the CommonJS requirements by simply wrapping the module code inside some footer/header code:</p><pre><code>(function (require, exports, module) {
  /* module code here */
})
</code></pre><p>So the example module would become:</p><pre><code>(function (require, exports, module) {
  exports.add = function (a, b) {
    return a + b;
  };
  // return value is ignored
})
</code></pre><p>When evaluated, the expression results in a function object (denoted <code>F</code>) which is then called (more or less) like:</p><pre><code>var exports = {};
var module = {
  exports: exports,   /* initial value, may be replaced by user */
  id: &#39;package/lib&#39;
};
F.call(exports,                 /* exports also used as &#39;this&#39; binding */
       require,                 /* require method */
       exports,                 /* exports */
       module);                 /* module */
</code></pre><p>A few notes:</p><ul><li>The return value of this call is ignored.</li><li>If either modSearch() or the module code throws an error, the module is de-registered from <code>Duktape.modLoaded</code> and the error is then re-thrown (this was changed in Duktape 1.3 to match the behavior of e.g. Node.js).</li><li>The first argument is a new function object whose underlying native function is the same as the global <code>require()</code> function. This fresh function is needed to facilitate resolution of relative module identifiers: relative identifers are resolved relative to the current module. The resolved absolute identifier of the current module is tracked in <code>require.id</code>. Native code can then pick up the resolution path from the current function object.</li><li>The third argument provides the module with its own, resolved identifier. The value in <code>module.id</code> is guaranteed to be in absolute form, and resolve to the module itself if required from any other module.</li></ul><h2 id="module-caching-when-module-loading-fails" tabindex="-1">Module caching when module loading fails <a class="header-anchor" href="#module-caching-when-module-loading-fails" aria-label="Permalink to &quot;Module caching when module loading fails&quot;">​</a></h2><p>The &quot;module&quot; table of a module is registered to <code>Duktape.modLoaded</code> just before calling either modSearch() or the wrapped module function. This registration must be done before running the module function because there may be circular requires which require that cache entry to be present.</p><p>But what should be done with the modLoaded entry if the module function throws an error? CommonJS doesn&#39;t specify what to do in this situation. Duktape 1.2 would keep the partial module in modLoaded, so that if you tried to reload the module, the partial module would be returned directly.</p><p>Since Duktape 1.3 the modLoaded entry will be removed on module load error so that it&#39;s possible to try to load the module again. This matches Node.js behavior. See the test case:</p><ul><li><code>test-commonjs-module-load-error.js</code></li></ul><h2 id="commonjs-module-identifier-resolution" tabindex="-1">CommonJS module identifier resolution <a class="header-anchor" href="#commonjs-module-identifier-resolution" aria-label="Permalink to &quot;CommonJS module identifier resolution&quot;">​</a></h2><p>CommonJS specifies that identifier terms must be &quot;camelCase&quot;:</p><ul><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1#Module_Identifiers" target="_blank" rel="noreferrer">http://wiki.commonjs.org/wiki/Modules/1.1#Module_Identifiers</a></li></ul><p>Some interpret this to mean that e.g. a dash character is not allowed. Such an interpretation seems counterproductive because e.g. filenames often contain dashes, underscores, etc. Duktape allows terms to contain any characters (including non-ASCII and white space) except that:</p><ul><li>A term must not begin with a period (<code>.</code>) to simplify resolution. Such terms are rejected.</li><li>A term cannot contain a forward slash, which (of course) gets interpreted as a separator.</li><li>A term cannot contain a U+0000 character. Such terms are currently not rejected. Instead, they terminate the resolution as if the requested identifier had ended.</li></ul><p>If user code wishes to impose further limits, the module search function can check a resolved identifier and throw an error if it is not of a desirable form.</p><h2 id="logger-names-and-tracebacks" tabindex="-1">Logger names and tracebacks <a class="header-anchor" href="#logger-names-and-tracebacks" aria-label="Permalink to &quot;Logger names and tracebacks&quot;">​</a></h2><p>Logger name defaulting uses the calling function&#39;s <code>fileName</code> property. The <code>fileName</code> of the internal module wrapper function is set to the resolved module identifier to make the logger default name come out right. Application code can control logger name by overwriting <code>module.filename</code> in modSearch().</p><p>Tracebacks show both <code>name</code> and <code>fileName</code> of the internal wrapper function. Application code can control these by overwriting <code>module.filename</code> and/or <code>module.name</code>.</p><h2 id="module-exports" tabindex="-1">module.exports <a class="header-anchor" href="#module-exports" aria-label="Permalink to &quot;module.exports&quot;">​</a></h2><p>NodeJS allows the default <code>exports</code> value to be changed by the module being loaded; it can even be replaced e.g. by a function (it&#39;s normally an object value). To change the value, the module must assign to <code>module.exports</code> which initially has the same value as <code>exports</code>:</p><ul><li><a href="http://timnew.github.io/blog/2012/04/20/exports_vs_module_exports_in_node_js/" target="_blank" rel="noreferrer">http://timnew.github.io/blog/2012/04/20/exports_vs_module_exports_in_node_js/</a></li></ul><p>Duktape supports <code>module.exports</code> since Duktape 1.3, see:</p><ul><li><code>test-commonjs-module-exports-repl.js</code></li></ul><h2 id="module-filename-and-module-name" tabindex="-1">module.filename and module.name <a class="header-anchor" href="#module-filename-and-module-name" aria-label="Permalink to &quot;module.filename and module.name&quot;">​</a></h2><p>The <code>module.filename</code> and <code>module.name</code> properties are Duktape specific but also supported by e.g. Node.js. They allow modSearch() to control the <code>.fileName</code> and <code>.name</code> properties of the module wrapper function used to implement module loading. This is useful because they appear in e.g. tracebacks for errors created from the module. See discussion in: <a href="https://github.com/svaarala/duktape/pull/639" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/pull/639</a>.</p><p>The properties are missing by default. If modSearch() doesn&#39;t set them, the module wrapper function .fileName defaults to the full resolved module ID (e.g. <code>foo/bar</code>) and .name defaults to the last component of the resolved module ID (e.g. <code>bar</code>).</p><p>The capitalization of <code>module.filename</code> is chosen to match Node.js (see <a href="https://nodejs.org/api/modules.html#modules_module_filename" target="_blank" rel="noreferrer">https://nodejs.org/api/modules.html#modules_module_filename</a>); the form <code>.fileName</code> is used elsewhere in Duktape. See discussion in: <a href="https://github.com/svaarala/duktape/pull/660" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/pull/660</a>.</p><h2 id="c-modules-and-dlls" tabindex="-1">C modules and DLLs <a class="header-anchor" href="#c-modules-and-dlls" aria-label="Permalink to &quot;C modules and DLLs&quot;">​</a></h2><h3 id="recommended-convention" tabindex="-1">Recommended convention <a class="header-anchor" href="#recommended-convention" aria-label="Permalink to &quot;Recommended convention&quot;">​</a></h3><p><code>c-module-convention.rst</code> describes a recommended convention for defining an init function for a C module. The convention allows a C module to be initialized manually when using static linking, or as part of loading the module from a DLL.</p><p>The recommendation is in no way mandatory and you can easily write a module loader with your own conventions (see below). However, modules following the recommended convention will be easier to share between projects.</p><h3 id="implementing-a-c-module-dll-loader" tabindex="-1">Implementing a C module / DLL loader <a class="header-anchor" href="#implementing-a-c-module-dll-loader" aria-label="Permalink to &quot;Implementing a C module / DLL loader&quot;">​</a></h3><p>The user provided module search function can be used to implement DLL support. Simply load the DLL based on the module identifier, and call some kind of init function in the DLL to register module symbols into the &#39;exports&#39; table given to the module loader.</p><p>Mixed C/ECMAScript modules are also possible by first registering symbols provided by C code into the &#39;exports&#39; table, and then returning the ECMAScript part of the module. The ECMAScript part can access the symbols provided by C code through the shared &#39;exports&#39; table.</p><p>As of Duktape 1.3, the <code>module</code> table is registered to <code>Duktape.modLoaded</code> before the module search function is called, so that circular requires are now supported for C modules too.</p><p>Limitations:</p><ul><li>There is no automatic mechanism to know when a DLL can be unloaded from memory. Tracking the reachability of the exports table of the module (e.g. through a finalizer) is <strong>not</strong> enough because other modules can copy references to individual exported values.</li></ul><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><h3 id="module-frameworks" tabindex="-1">Module frameworks <a class="header-anchor" href="#module-frameworks" aria-label="Permalink to &quot;Module frameworks&quot;">​</a></h3><p>ECMAScript has not traditionally had a module mechanism. In browser environments a web page can load multiple script files in a specific order, each of them introducing more global symbols. This is not very elegant because the order of loading must be correct in case any code runs during loading. Several module mechanisms have since been created for the browser environment to make writing modular ECMAScript easier. Similar needs also exist in non-browser environments and several mechanisms have been defined.</p><p>References summarizing several module frameworks:</p><ul><li><a href="http://addyosmani.com/writing-modular-js/" target="_blank" rel="noreferrer">http://addyosmani.com/writing-modular-js/</a></li><li><a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="noreferrer">http://wiki.commonjs.org/wiki/Modules</a></li></ul><p>Module loading APIs or &quot;formats&quot;:</p><ul><li>Asynchronous Module Definition (AMD) API: <ul><li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noreferrer">https://github.com/amdjs/amdjs-api/wiki/AMD</a></li></ul></li><li>CommonJS: <ul><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noreferrer">http://wiki.commonjs.org/wiki/Modules/1.1.1</a></li><li><a href="https://github.com/joyent/node/blob/master/lib/module.js" target="_blank" rel="noreferrer">https://github.com/joyent/node/blob/master/lib/module.js</a></li><li><a href="https://github.com/commonjs/commonjs/tree/master/tests/modules" target="_blank" rel="noreferrer">https://github.com/commonjs/commonjs/tree/master/tests/modules</a></li><li><a href="http://requirejs.org/docs/commonjs.html" target="_blank" rel="noreferrer">http://requirejs.org/docs/commonjs.html</a></li><li><a href="http://dailyjs.com/2010/10/18/modules/" target="_blank" rel="noreferrer">http://dailyjs.com/2010/10/18/modules/</a></li></ul></li><li>NodeJS, more or less CommonJS: <ul><li><a href="http://nodejs.org/docs/v0.11.13/api/modules.html" target="_blank" rel="noreferrer">http://nodejs.org/docs/v0.11.13/api/modules.html</a></li><li><a href="https://nodejs.org/api/modules.html" target="_blank" rel="noreferrer">https://nodejs.org/api/modules.html</a></li></ul></li><li>ES2015: <ul><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules" target="_blank" rel="noreferrer">http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules</a></li></ul></li></ul><p>AMD is optimized for the web client side, and requires callback based asynchronous module loading. This model is not very convenient for server side programming, or fully fledged application programming which is more natural with Duktape.</p><p>CommonJS module format is a server side module mechanism which seems most appropriate to be the default Duktape mechanism.</p><h2 id="some-nodejs-tests" tabindex="-1">Some NodeJS tests <a class="header-anchor" href="#some-nodejs-tests" aria-label="Permalink to &quot;Some NodeJS tests&quot;">​</a></h2><p>This section illustrates some NodeJS module loader features, as it&#39;s nice to align with NodeJS behavior when possible.</p><h3 id="assignments" tabindex="-1">Assignments <a class="header-anchor" href="#assignments" aria-label="Permalink to &quot;Assignments&quot;">​</a></h3><p>Test module:</p><pre><code>// test.js
var foo = 123;     // not visible outside
bar = 234;         // assigned to global object
this.quux = 345;   // exported from module
exports.baz = 456; // exported from module
</code></pre><p>Test code:</p><pre><code>&gt; var t = require(&#39;./test&#39;);
undefined
&gt; console.log(JSON.stringify(t));
{&quot;quux&quot;:345,&quot;baz&quot;:456}
undefined
&gt; console.log(bar);
234
</code></pre><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="ability-to-load-modules-from-c-code" tabindex="-1">Ability to load modules from C code <a class="header-anchor" href="#ability-to-load-modules-from-c-code" aria-label="Permalink to &quot;Ability to load modules from C code&quot;">​</a></h3><p>For instance, implement something like:</p><pre><code>// Pushes the &#39;exports&#39; table of &#39;foo/bar&#39; module to the stack.
duk_require_module(ctx, &quot;foo/bar&quot;);
</code></pre><p>This is not a high priority thing as one can simply:</p><pre><code>duk_eval_string(ctx, &quot;require(&#39;foo/bar&#39;)&quot;);
</code></pre><p>Eval invokes the compiler which is not ideal, but modules are usually imported during initialization so this should rarely matter.</p><h3 id="better-c-module-support" tabindex="-1">Better C module support <a class="header-anchor" href="#better-c-module-support" aria-label="Permalink to &quot;Better C module support&quot;">​</a></h3><ul><li>Provide a default DLL loading helper for at least POSIX and Windows.</li></ul><h3 id="module-unloading-support" tabindex="-1">Module unloading support <a class="header-anchor" href="#module-unloading-support" aria-label="Permalink to &quot;Module unloading support&quot;">​</a></h3><p>Currently modules cannot be unloaded: once loaded, they&#39;re registered to <code>Duktape.modLoaded</code> permanently, which keeps the exported object permanently reachable (unless removed manually). Adding a finalizer to the exports table is not a solution: another module might hold a reference to a specific symbol within the module but not the exports table itself, e.g.:</p><pre><code>var helloFunc = require(&#39;hello&#39;).func;
</code></pre><p>Collecting a module exports table and executing some unload code is not trivial. Just removing an unused exports object probably requires weak reference support.</p><h3 id="isolating-a-module-from-the-global-object" tabindex="-1">Isolating a module from the global object <a class="header-anchor" href="#isolating-a-module-from-the-global-object" aria-label="Permalink to &quot;Isolating a module from the global object&quot;">​</a></h3><p>Currently <code>this</code> is bound to <code>exports</code> so writes through <code>this</code> do not pollute globals. Variable and function declarations also currently go to the module wrapper function and do not pollute globals. However, plain assignments do write to globals, and reads not matching identifiers declared in scope are read from globals:</p><pre><code>fooBar = 123;  // if &#39;fooBar&#39; not in scope, write to global
print(barFoo); // if &#39;barFoo&#39; not in scope, read from global
</code></pre><h3 id="lua-like-module-loader" tabindex="-1">Lua-like module loader <a class="header-anchor" href="#lua-like-module-loader" aria-label="Permalink to &quot;Lua-like module loader&quot;">​</a></h3><p>The lowest level module mechanism could also be similar to what Lua does. A module would be cached as in CommonJS so that it would only be loaded once per global context. Modules could be loaded with a user callback which takes a module ID and returns the loaded module object (same as the <code>exports</code>) value to be registered into the module cache.</p><p>The upside of this approach is flexibility: most of the CommonJS module mechanism can be implemented on top of this.</p><p>One downside is that the module loading mechanism would not be a common one and most users would need to implement or borrow a standard module loader. Another downside is that a Lua-like mechanism doesn&#39;t deal with circular module loading while the CommonJS one does (to some extent).</p>`,99)]))}const p=o(i,[["render",n]]);export{h as __pageData,p as default};
