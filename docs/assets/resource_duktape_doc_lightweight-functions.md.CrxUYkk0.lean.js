import{_ as t,c as i,a2 as o,o as a}from"./chunks/framework.DPuwY6B9.js";const p=JSON.parse('{"title":"Lightweight function value","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/lightweight-functions.md","filePath":"resource/duktape/doc/lightweight-functions.md","lastUpdated":null}'),n={name:"resource/duktape/doc/lightweight-functions.md"};function r(l,e,c,s,u,h){return a(),i("div",null,e[0]||(e[0]=[o(`<h1 id="lightweight-function-value" tabindex="-1">Lightweight function value <a class="header-anchor" href="#lightweight-function-value" aria-label="Permalink to &quot;Lightweight function value&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>A lightweight function (or a &quot;lightfunc&quot;) is a plain duk_tval value type which refers to a Duktape/C function without needing a representative ECMAScript Function object. The duk_tval tagged type encapsulates a reference to the native function, as well as a small set of control bits, without needing any heap allocations. This is useful in especially low memory environments, where the memory footprint of typical Duktape/C bindings can be reduced.</p><p>A lightfunc has a separate API type (<code>DUK_TYPE_LIGHTFUNC</code>) so it is a clearly distinguished type for C code. However, for ECMAScript code a lightfunc behaves as closely as possible like an ordinary Function instance. Various techniques (such as virtual properties) are used to achieve this goal as well as possible.</p><h2 id="memory-representation" tabindex="-1">Memory representation <a class="header-anchor" href="#memory-representation" aria-label="Permalink to &quot;Memory representation&quot;">​</a></h2><p>The 8-byte representation for a lightfunc is:</p><pre><code>16 bits  16 bits      32 bits
+--------+--------+----------------+
| 0xfff5 | flags  | function ptr   |
+--------+--------+----------------+
</code></pre><p>The flags field is further split into:</p><pre><code>8 bits       4 bits   4 bits
+----------------+--------+--------+
| magic          | length | nargs  |
+----------------+--------+--------+

magic: signed 8-bit value
length: 0 to 15
nargs: 0 to 14, 15 indicates DUK_VARARGS
</code></pre><h2 id="using-lightfuncs" tabindex="-1">Using lightfuncs <a class="header-anchor" href="#using-lightfuncs" aria-label="Permalink to &quot;Using lightfuncs&quot;">​</a></h2><h3 id="duk-push-c-lightfunc" tabindex="-1">duk_push_c_lightfunc() <a class="header-anchor" href="#duk-push-c-lightfunc" aria-label="Permalink to &quot;duk_push_c_lightfunc()&quot;">​</a></h3><p>You can make your own function bindings lightfuncs by simply pushing lightfunction values with <code>duk_push_c_lightfunc()</code>. Lightfunc limits:</p><ul><li>Number of stack arguments must be 0 to 14 or varargs.</li><li>Virtual &quot;length&quot; property can be given separately and must be between 0 and 15.</li><li>Magic must be between -128 to 127 (-0x80 to 0x7f).</li></ul><h3 id="duk-use-lightfunc-builtins" tabindex="-1">DUK_USE_LIGHTFUNC_BUILTINS <a class="header-anchor" href="#duk-use-lightfunc-builtins" aria-label="Permalink to &quot;DUK_USE_LIGHTFUNC_BUILTINS&quot;">​</a></h3><p>The config option <code>DUK_USE_LIGHTFUNC_BUILTINS</code> converts most built-in functions forcibly into lightweight functions, reducing memory usage on low memory platforms by around 14 kB.</p><h2 id="behavior-notes" tabindex="-1">Behavior notes <a class="header-anchor" href="#behavior-notes" aria-label="Permalink to &quot;Behavior notes&quot;">​</a></h2><h3 id="testcases" tabindex="-1">Testcases <a class="header-anchor" href="#testcases" aria-label="Permalink to &quot;Testcases&quot;">​</a></h3><p>A lot of detailed behavior is described in testcases:</p><ul><li><code>test-dev-lightfunc*.js</code></li><li><code>test-dev-lightfunc*.c</code></li></ul><h3 id="virtual-properties" tabindex="-1">Virtual properties <a class="header-anchor" href="#virtual-properties" aria-label="Permalink to &quot;Virtual properties&quot;">​</a></h3><p>A lightfunc has the following virtual properties:</p><ul><li><code>name</code>: fixed format of <code>lightfunc_&lt;ptr&gt;_&lt;flags&gt;</code> where <code>&lt;ptr&gt;</code> is a platform dependent rendering of a function pointer, and <code>&lt;flags&gt;</code> is a 16-bit internal flags field encoded as-is.</li><li><code>length</code>: number between 0 and 15, encoded as 4 bits into the internal flags field.</li></ul><h3 id="lightfunc-cannot-have-a-prototype-property" tabindex="-1">Lightfunc cannot have a &quot;prototype&quot; property <a class="header-anchor" href="#lightfunc-cannot-have-a-prototype-property" aria-label="Permalink to &quot;Lightfunc cannot have a \\&quot;prototype\\&quot; property&quot;">​</a></h3><p>A lightfunc can be used as a constructor function, and is in fact always constructable. However, lightfuncs cannot have a &quot;prototype&quot; property, so when called as a constructor, the automatically created default instance object inherits from <code>Object.prototype</code>.</p><p>You can still construct objects that inherit from a custom prototype, but you need to create and return that value explicitly in the constructor, so that it replaces the automatic default instance.</p><h3 id="lightfunc-cannot-be-a-setter-getter" tabindex="-1">Lightfunc cannot be a setter/getter <a class="header-anchor" href="#lightfunc-cannot-be-a-setter-getter" aria-label="Permalink to &quot;Lightfunc cannot be a setter/getter&quot;">​</a></h3><p>A property value slot can either hold a <code>duk_tval</code> or two <code>duk_hobject *</code> pointers for the setter/getter of an accessor (in 32-bit environments both take 8 bytes). The setter/getter slot cannot hold two lightfunc references (which would take 16 bytes).</p><p>As a result, lightfuncs cannot be used as setter/getter values. If you give a lightfunc as a setter/getter reference, it will be silently coerced into a normal function object: the setter/getter will work, but a normal function object will be created (consuming memory).</p><h3 id="lightfunc-cannot-have-a-finalizer" tabindex="-1">Lightfunc cannot have a finalizer <a class="header-anchor" href="#lightfunc-cannot-have-a-finalizer" aria-label="Permalink to &quot;Lightfunc cannot have a finalizer&quot;">​</a></h3><p>Lightfuncs cannot have a finalizer because they are primitive values. As such they don&#39;t have a reference count field nor do they participate in garbage collection like actual objects.</p><p>Hypothetically, even if lightfuncs were garbage collected somehow, they don&#39;t have space for a virtual <code>_Finalizer</code> property. It would be possible to set a finalizer on <code>Function.prototype</code> though and let that finalize the lightfuncs. But because lightfuncs are not really objects, it&#39;s not clear when the finalizer should be called (e.g. every time a lightfunc <code>duk_tval</code> is DECREF&#39;d?).</p><h2 id="implementation-notes" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h2><h3 id="some-changes-needed" tabindex="-1">Some changes needed <a class="header-anchor" href="#some-changes-needed" aria-label="Permalink to &quot;Some changes needed&quot;">​</a></h3><p>This list is not exhaustive:</p><ul><li>Add a new tagged type, DUK_TAG_LIGHTFUNC, which points to a Duktape/C function. <ul><li>A lightweight function can be a constructor, but will never have an automatic prototype object (a property slot would be needed to store it). A lightweight constructor function can create a replacement object from scratch and discard the automatically created instance object.</li></ul></li><li>The representation depends on the <code>duk_tval</code> layout: <ul><li>For 8-byte packed type: 32-bit function pointer (pointing to the Duktape/C function) and 16 bits for function metadata.</li><li>For unpacked type: function pointer and 16 bits options field.</li></ul></li><li>The 16-bit metadata field is divided into the following sub-fields: <ul><li>8-bit magic value: important to be able to represent built-ins as lightfuncs (they use magic value extensively)</li><li>4-bit <code>nargs</code> (with 15 indicating varargs)</li><li>4-bit <code>length</code> property value</li></ul></li><li>Regarding ECMAScript semantics, the lightweight function type should behave like a Function object as much as possible. <ul><li>This means, for example, that operators and built-in functions which strictly require an object argument must handle lightweight function values specially.</li><li>Some property algorithms can be implemented by first checking for lightfunc virtual properties, and if no virtual property matches, replacing the original argument with <code>Function.prototype</code>. This doesn&#39;t always work, however. For instance, if getters/setters can be invoked, the <code>this</code> binding must bind to the original lightfunc, not <code>Function prototype</code>.</li></ul></li><li>All call sites in code which expect an object need to be considered. <ul><li>For example, if a call site uses <code>duk_require_hobject()</code> it needs to be changed to allow an object or a lightfunc. There&#39;s a specific helper to implement minimal lightfunc support to such call sites by coercing lightfuncs to full Function objects: <code>duk_require_hobject_promote_lfunc()</code>.</li></ul></li><li>Add support in call handling for calling a lightfunc: <ul><li>Bound function handling</li><li>Magic and <code>nargs</code></li></ul></li><li>Add support in traceback handling: <ul><li>Function name</li></ul></li><li>Add virtual object properties so that lightweight functions will appear like ordinary Function objects to some extent</li><li>Add reasonable behavior for all coercion operations, e.g. ToObject() should probably coerce a lightfunc into a normal Function with the same internal parameters (such as nargs and magic).</li><li>Add an option to change built-in functions into lightweight functions instead of Function objects. This should not be active by default, because this change makes the built-ins strictly non-compliant. However, this is quite useful in RAM constrained environments.</li><li>Extend the public API to allow the user to push lightweight function pointers in addition to ordinary ones. <ul><li>For now there is no module registration helper which supports lightweight functions.</li></ul></li><li>Fix operators requiring a function value: <ul><li><code>in</code></li><li><code>instanceof</code></li></ul></li><li>JSON/JX/JC support for lightfuncs</li></ul><h3 id="automatic-conversion-of-built-ins-to-lightfuncs" tabindex="-1">Automatic conversion of built-ins to lightfuncs <a class="header-anchor" href="#automatic-conversion-of-built-ins-to-lightfuncs" aria-label="Permalink to &quot;Automatic conversion of built-ins to lightfuncs&quot;">​</a></h3><p>Most built-ins can be converted into lightweight functions because they don&#39;t have a <code>.prototype</code> property which would prevent such a conversion. The built-ins do have a <code>.length</code> property which doesn&#39;t always match the actual argument count, but both <code>nargs</code> and <code>length</code> are stored in the lightfunc value to allow these functions to be represented as lightfuncs.</p><p>The top level constructors (like <code>Number</code>) cannot be converted to lightfuncs because they have property values (e.g. <code>Number.POSITIVE_INFINITY</code>) which require a property table.</p><p>Built-in methods use &quot;magic&quot; values extensively, and the 8-bit magic is sufficient for everything except the Date built-in. The Date built-in magic value was changed to be an index to a table of actual magic values to work around this limit.</p><p>As a result, almost all built-in methods (except eval, yield, resume, and require) are now converted to lightfuncs.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="more-call-sites-with-direct-support-of-lightfuncs" tabindex="-1">More call sites with direct support of lightfuncs <a class="header-anchor" href="#more-call-sites-with-direct-support-of-lightfuncs" aria-label="Permalink to &quot;More call sites with direct support of lightfuncs&quot;">​</a></h3><p>Add support for direct lightfunc support in places where object coercion (e.g. <code>duk_require_hobject_promote_lfunc()</code>) is used. Such coercion has a memory churn impact so it&#39;s preferable to avoid it when it matters. The best places to improve on are those seen in practical code.</p><p>For example, currently enumerating a lightfunc goes through coercion which is not ideal.</p><h3 id="improved-jx-jc-support" tabindex="-1">Improved JX/JC support <a class="header-anchor" href="#improved-jx-jc-support" aria-label="Permalink to &quot;Improved JX/JC support&quot;">​</a></h3><p>Should lightfuncs be visible in a special way in JX/JC encoding? For instance:</p><pre><code>{_func:true}    ecma function
{_cfunc:true}   C function
{_lfunc:true}   lightweight C function
</code></pre><p>On the other hand C/ECMAScript functions are not distinguished in JX/JC now.</p><h3 id="tolightfunc" tabindex="-1">ToLightFunc() <a class="header-anchor" href="#tolightfunc" aria-label="Permalink to &quot;ToLightFunc()&quot;">​</a></h3><p>There&#39;s currently no way to coerce an ordinary native Function into a lightfunc. Lightfuncs can only be created through the Duktape API. If such a coercion was added, it would need to check compatibility for the coercion, at least magic and nargs must match for even the basic calling convention guarantees to work.</p><h3 id="better-virtual-names-for-forced-built-in-lightfuncs" tabindex="-1">Better virtual names for forced built-in lightfuncs <a class="header-anchor" href="#better-virtual-names-for-forced-built-in-lightfuncs" aria-label="Permalink to &quot;Better virtual names for forced built-in lightfuncs&quot;">​</a></h3><p>By matching Duktape/C function pointer and magic value, proper virtual names could be given to built-in lightfuncs. The function name table goes into code memory (e.g. flash) which is often less restricted than RAM.</p><p>A similar approach would be to allow user code to provide a hook which could try to provide a name for a lightfunc when given its function pointer and the 16-bit flags field. User code could then consult symbol tables or similar to provide better names.</p><h3 id="improve-the-duktape-c-api" tabindex="-1">Improve the Duktape C API <a class="header-anchor" href="#improve-the-duktape-c-api" aria-label="Permalink to &quot;Improve the Duktape C API&quot;">​</a></h3><p>Right now there is just one call to push a lightfunc on the stack. The magic value of the lightfunc can be read. However, the magic value, nargs or length of a lightfunc cannot be modified. User can construct a new lightfunc from scratch, but won&#39;t be able to read e.g. the &quot;nargs&quot; value of a lightfunc on the stack.</p><p>API questions:</p><ul><li>Add a push variant which has no &#39;length&#39; or &#39;magic&#39;, so that it matches duk_push_c_function()?</li><li>Add necessary API calls to read and write &#39;length&#39;, &#39;magic&#39;, and &#39;nargs&#39; of a lightfunc.</li></ul><p>API additions are not necessarily preferable if there is not concrete need for them.</p><h3 id="symbol-file-for-lightweight-functions" tabindex="-1">Symbol file for lightweight functions <a class="header-anchor" href="#symbol-file-for-lightweight-functions" aria-label="Permalink to &quot;Symbol file for lightweight functions&quot;">​</a></h3><ul><li>Address/offset + 16-bit flags (or just magic), allows reconstruction of lightfunc name</li><li>Build could provide some symbol information that could be read into a debugger environment to improve traceback verbosity</li></ul><h3 id="improve-defineproperty-behavior" tabindex="-1">Improve defineProperty() behavior <a class="header-anchor" href="#improve-defineproperty-behavior" aria-label="Permalink to &quot;Improve defineProperty() behavior&quot;">​</a></h3><p>Object.defineProperty() could throw a TypeError (&quot;not extensible&quot;) when a new property is created into a lightfunc. Currently this succeeds but of course new properties cannot actually be created into a lightfunc.</p><h3 id="improve-toobject-coercion" tabindex="-1">Improve ToObject() coercion <a class="header-anchor" href="#improve-toobject-coercion" aria-label="Permalink to &quot;Improve ToObject() coercion&quot;">​</a></h3><p>Current ToObject() coercion has two logical but confusing issues:</p><ul><li><p>The result is extensible while the input lightfunc is not. This is useful because it&#39;s quite likely the user wants to extend the resulting function if the lightfunc is explicitly object coerced. It also matches the standard ECMAScript behavior for strings: <code>new String(&#39;foo&#39;)</code> returns an extensible String object.</p><p>Another alternative would be to make the result non-extensible.</p></li><li><p>The &#39;name&#39; property of the coercion result is the lightfunc name, which is a bit confusing because the object is no longer a lightfunc.</p><p>Another alternative would be to make the &#39;name&#39; differ from the lightfunc name. However, this would be confusing in a different way.</p></li></ul>`,65)]))}const f=t(n,[["render",r]]);export{p as __pageData,f as default};
