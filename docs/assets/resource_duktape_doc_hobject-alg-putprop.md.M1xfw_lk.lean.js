import{_ as o,c as t,a2 as c,o as d}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"PUTPROP: exposed property put algorithm","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/hobject-alg-putprop.md","filePath":"resource/duktape/doc/hobject-alg-putprop.md","lastUpdated":1732350347000}'),r={name:"resource/duktape/doc/hobject-alg-putprop.md"};function a(i,e,n,s,l,h){return d(),t("div",null,e[0]||(e[0]=[c(`<h1 id="putprop-exposed-property-put-algorithm" tabindex="-1">PUTPROP: exposed property put algorithm <a class="header-anchor" href="#putprop-exposed-property-put-algorithm" aria-label="Permalink to &quot;PUTPROP: exposed property put algorithm&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>Properties are written in ECMAScript code in many contexts, e.g.:</p><pre><code>foo.bar = &quot;quux&quot;;
</code></pre><p>A property put expression in ECMAScript code involves:</p><ul><li>A property accessor reference (E5 Section 11.2.1)</li><li>A <code>PutValue()</code> call (E5 Section 8.7.2)</li><li>A <code>[[Put]]</code> call (or a <code>PutValue()</code> specific variant)</li></ul><p>The property accessor coercions are the same as for <code>GetValue</code>:</p><ul><li>The base reference is checked with <code>CheckObjectCoercible()</code></li><li>The property name is coerced to a string</li></ul><p>The <code>PutValue()</code> call is simple:</p><ul><li>If the base reference is primitive, it is coerced to an object, and a exotic variant of <code>[[Put]]</code> is used.</li><li>Otherwise, standard <code>[[Put]]</code> is used.</li></ul><p>The variant <code>[[Put]]</code> for a primitive base value differs from the standard <code>[[Put]]</code> as follows:</p><ul><li>If the coerced temporary object has a matching own data property, the put is explicitly rejected (steps 3-4 of the variant algorithm), regardless of the property attributes (especially, writability). Compare this to the standard <code>[[Put]]</code> behavior in E5 Section 8.12.5, steps 2-3 which simply attempts to update the data property, provided that the property is writable.</li><li>If the property is found (either in the temporary object or its ancestors) and is a setter, the setter call <code>this</code> binding is the primitive value, not the coerced value. (An own accessor property should never be found in practice, as the only possible coerced object types as <code>Boolean</code>, <code>Number</code>, and <code>String</code>.)</li></ul><p>Like <code>GetValue()</code>, we could skip creation of the coerced object, but don&#39;t take advantage of this now.</p><p>Note: if the base reference is a primitive value, the coerced object is temporary and never exposed to user code. Some implementations (like V8) omit a property write entirely if the base value is primitive. This can be observed by lack of side effects, e.g. no setter call occurs when it should:</p><pre><code>// add test getter
Object.defineProperty(String.prototype, &#39;test&#39;, {
  get: function() { print(typeof this); },
  set: function(x) { print(typeof this); },
});

&quot;foo&quot;.test = &quot;bar&quot;;    // prints &#39;string&#39;
</code></pre><p>V8 will print nothing, while Rhino and Smjs print &#39;object&#39; (which is also not correct).</p><h2 id="first-draft" tabindex="-1">First draft <a class="header-anchor" href="#first-draft" aria-label="Permalink to &quot;First draft&quot;">​</a></h2><p>The relevant part begins after that in steps 5-8, which first perform some coercions and then create a property accessor. The accessor is then acted upon by <code>PutValue()</code>, and ultimately <code>[[Put]]</code> or its variant.</p><p>Combining all of these, we get the first draft (for base value <code>O</code> and property name value <code>P</code>):</p><ol><li>Let <code>orig</code> be <code>O</code>. (Remember the uncoerced original for a possible setter call.)</li><li>Call <code>CheckObjectCoercible</code> with <code>O</code> as argument. In practice: if <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (Note: this is unconditional.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li>If <code>O</code> is not an object, let <code>coerced</code> be <code>true</code>, else let <code>coerced</code> be <code>false</code>.</li><li>Let <code>O</code> be <code>ToObject(O)</code>. (This is side effect free.)</li><li>Let <code>curr</code> be <code>O</code>.</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>coerced</code> is <code>true</code>, Reject. d. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. e. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> f. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. g. Return.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>coerced</code> is <code>true</code>, Reject. b. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, Reject. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 3. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> 4. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. c. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 2. Let <code>valueDesc</code> be <code>{ [[Value]]: V }</code>. 3. Call <code>O.[[DefineOwnProperty]](P, valueDesc, Throw)</code>.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>orig</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: the difference to a basic <code>[[Put]]</code> is that the setter <code>this</code> binding is the original, uncoerced object.)</li><li>Return.</li></ol><p>Notes:</p><ul><li><p>Steps 2-3 come from the property accessor evaluation rules in E5 Section 11.2.1. In particular, <code>CheckObjectCoercible()</code> is called before the key is coerced to a string. Since the key string coercion may have side effects, the order of evaluation matters.</p><p>Note that <code>ToObject()</code> has no side effects (this can be seen from a case by case inspection), so steps 3 and 4-5 can be reversed.</p></li><li><p>Step 10.b uses the original object (not the coerced object) as the setter <code>this</code> binding (E5 Section 8.7.2, step 6 of the variant <code>[[Put]]</code> algorithm).</p></li><li><p>Steps 8.c and 9.a reject attempt to update or create a data property on a temporary object (E5 Section 8.7.2, steps 4 and 7 of the variant <code>[[Put]]</code> algorithm). Note that the &quot;coerced&quot; check is not actually needed to guard step 9.c (step 4 of the variant <code>[[Put]]</code>) because the only coerced object with own properties is the <code>String</code> object, and all its own properties are non-writable and thus caught by step 9.c.1 anyway. This might of course change in a future version, or be untrue for some out-of-spec coercion behavior for custom types. The pre-check <em>is</em> needed to avoid creating a new property on the temporary object, though.</p></li><li><p>An explicit <code>coerced</code> flag is not needed: we can simply check whether or not <code>orig</code> is an object.</p></li><li><p>Since <code>curr</code> is used for prototype chain walking, we don&#39;t need to store <code>orig</code> (<code>O</code> can be used for that instead).</p></li></ul><h2 id="cleaning-up" tabindex="-1">Cleaning up <a class="header-anchor" href="#cleaning-up" aria-label="Permalink to &quot;Cleaning up&quot;">​</a></h2><ol><li>Call <code>CheckObjectCoercible</code> with <code>O</code> as argument. In practice: if <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (Note: this is unconditional.)</li><li>Let <code>curr</code> be <code>ToObject(O)</code>. (This is side effect free.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>O</code> is not an object (was coerced), Reject. d. If <code>O.[[Extensible]]</code> is <code>false</code>, Reject. e. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> f. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. g. Return.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>O</code> is not an object (was coerced), Reject. b. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, Reject. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 3. Let <code>newDesc</code> be a property descriptor with values: - <code>[[Value]]: V</code> - <code>[[Writable]]: true</code> - <code>[[Enumerable]]: true</code> - <code>[[Configurable]]: true}</code> 4. Call <code>O.[[DefineOwnProperty]](P, newDesc, Throw)</code>. c. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, Reject. 2. Let <code>valueDesc</code> be <code>{ [[Value]]: V }</code>. 3. Call <code>O.[[DefineOwnProperty]](P, valueDesc, Throw)</code>.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, Reject. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: the difference to a basic <code>[[Put]]</code> is that the setter <code>this</code> binding is the original, uncoerced object.)</li><li>Return.</li></ol><h2 id="inlining-defineownproperty-calls" tabindex="-1">Inlining DefineOwnProperty calls <a class="header-anchor" href="#inlining-defineownproperty-calls" aria-label="Permalink to &quot;Inlining DefineOwnProperty calls&quot;">​</a></h2><p>The <code>[[Put]]</code> uses two different calls to <code>[[DefineOwnProperty]]</code>: one to update an existing property <code>[[Value]]</code> and another to create a brand new data property. These can be inlined into the algorithm as follows (see the section on preliminary algorithm work).</p><p>Before inlining, the cases for &quot;update old property&quot; and &quot;create new property&quot; are isolated into goto labels (as there are two places where a new property is created). The <code>[[DefineOwnProperty]]</code> calls with exotic behaviors inlined are then substituted. &quot;Reject&quot; is also made an explicit label.</p><p>The resulting algorithm is:</p><ol><li>Call <code>CheckObjectCoercible</code> with <code>O</code> as argument. In practice: if <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (Note: this is unconditional.)</li><li>Let <code>curr</code> be <code>ToObject(O)</code>. (This is side effect free.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>O</code> is not an object (was coerced), goto REJECT. d. If <code>O.[[Extensible]]</code> is <code>false</code>, goto REJECT. e. Goto NEWPROP.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>O</code> is not an object (was coerced), goto REJECT. b. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, goto REJECT. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 3. Goto NEWPROP. c. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 2. Goto UPDATEPROP.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, goto REJECT. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: the difference to a basic <code>[[Put]]</code> is that the setter <code>this</code> binding is the original, uncoerced object.) c. Return.</li><li><strong>UPDATEPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for existing property.) If <code>O</code> is an <code>Array</code> object, and <code>P</code> is <code>&quot;length&quot;</code>, then: a. Let <code>newLen</code> be <code>ToUint32(V)</code>. b. If <code>newLen</code> is not equal to <code>ToNumber(V)</code>, goto REJECTRANGE. c. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a <code>length</code> data property that cannot be deleted or reconfigured. d. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) e. If <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. 4. Return. f. Update the property (<code>&quot;length&quot;</code>) value to <code>newLen</code>. g. Return.</li><li>Set the <code>[[Value]]</code> attribute of the property named <code>P</code> of object <code>O</code> to <code>V</code>. (Since it is side effect free to update the value with the same value, no check for that case is needed.)</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>V</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</li><li>Return.</li><li><strong>NEWPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for new property.) If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. If <code>index</code> &gt;= <code>oldLen</code>: 1. Goto REJECT <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. 2. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds.</li><li>Create an own data property named <code>P</code> of object <code>O</code> whose attributes are: <ul><li><code>[[Value]]: V</code></li><li><code>[[Writable]]: true</code></li><li><code>[[Enumerable]]: true</code></li><li><code>[[Configurable]]: true</code></li></ul></li><li>Return.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return.</li><li><strong>REJECTRANGE</strong>: Throw a <code>RangeError</code> exception. (This is unconditional.)</li></ol><p>Notes:</p><ul><li>In step 8, we don&#39;t need to check for array index updates: the property already exists, so array <code>length</code> will not need an update.</li><li>In step 8, the original <code>[[DefineOwnProperty]]</code> exotic behavior is split into a pre-step and a post-step because the <code>&quot;length&quot;</code> write may fail. However, because we&#39;ve inlined <code>[[CanPut]]</code>, we know that the write will succeed, so both the pre- and post-behaviors can be handled in step 8 internally.</li><li>In step 8, we don&#39;t need to check for arguments exotic behavior, as only number-like indices have magic bindings (not <code>&quot;length&quot;</code>).</li><li>In steps 12-14, we don&#39;t need to check for arguments exotic behavior: any &quot;magically bound&quot; property must always be present in the arguments object. If a bound property is deleted, the binding is also deleted from the argument parameter map.</li><li>In step 12, we don&#39;t need to check for <code>length</code> exotic behavior: the <code>length</code> property always exists for arrays so we cannot get here with arrays.</li></ul><h2 id="avoiding-temporary-objects" tabindex="-1">Avoiding temporary objects <a class="header-anchor" href="#avoiding-temporary-objects" aria-label="Permalink to &quot;Avoiding temporary objects&quot;">​</a></h2><p>As for <code>GetValue()</code> the only cases where temporary objects are created are for <code>Boolean</code>, <code>Number</code>, and <code>String</code>. The <code>PutValue()</code> algorithm rejects a property write on a temporary object if a new data property were to be created or an existing one updated.</p><p>For the possible coerced values, the own properties are:</p><ul><li><code>Boolean</code>: none</li><li><code>Number</code>: none</li><li><code>String</code>: <code>&quot;length&quot;</code> and index properties for string characters</li></ul><p>These can be checked explicitly when coercing (and reject the attempt before going forwards). However, <code>PutValue()</code> <em>does</em> allow a property write if an ancestor contains a setter which &quot;captures&quot; the write so that the temporary object would not be written to. Although the built-in prototype chains do not contain such setters, they can be added by user code at run time, so they do need to be checked for.</p><p>Avoiding temporaries altogether:</p><ol><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part; the throw is unconditional.) b. If <code>O</code> is a boolean: set <code>curr</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>curr</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 2. If <code>P</code> is <code>length</code>, goto REJECT. 3. If <code>P</code> is a valid array index within the string length, goto REJECT. 4. Set <code>curr</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 5. Goto NEXT. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: set <code>curr</code> to <code>O</code>. f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>O</code> is not an object (was coerced), goto REJECT. d. If <code>O.[[Extensible]]</code> is <code>false</code>, goto REJECT. e. Goto NEWPROP.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>O</code> is not an object (was coerced), goto REJECT. b. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, goto REJECT. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 3. Goto NEWPROP. c. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 2. Goto UPDATEPROP.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, goto REJECT. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: the difference to a basic <code>[[Put]]</code> is that the setter <code>this</code> binding is the original, uncoerced object.) c. Return.</li><li><strong>UPDATEPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for existing property.) If <code>O</code> is an <code>Array</code> object, and <code>P</code> is <code>&quot;length&quot;</code>, then: a. Let <code>newLen</code> be <code>ToUint32(V)</code>. b. If <code>newLen</code> is not equal to <code>ToNumber(V)</code>, goto REJECTRANGE. c. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a <code>length</code> data property that cannot be deleted or reconfigured. d. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) e. If <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. 4. Return. f. Update the property (<code>&quot;length&quot;</code>) value to <code>newLen</code>. g. Return.</li><li>Set the <code>[[Value]]</code> attribute of the property named <code>P</code> of object <code>O</code> to <code>V</code>. (Since it is side effect free to update the value with the same value, no check for that case is needed.)</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>V</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</li><li>Return.</li><li><strong>NEWPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for new property.) If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. If <code>index</code> &gt;= <code>oldLen</code>: 1. Goto REJECT <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. 2. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>index + 1</code>. This always succeeds.</li><li>Create an own data property named <code>P</code> of object <code>O</code> whose attributes are: <ul><li><code>[[Value]]: V</code></li><li><code>[[Writable]]: true</code></li><li><code>[[Enumerable]]: true</code></li><li><code>[[Configurable]]: true</code></li></ul></li><li>Return.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return.</li></ol><p>Notes:</p><ul><li>Step 7: if array exotic behavior exists, we can return right after processing the <code>length</code> update; in particular, step 9 is not necessary as an object cannot be simultaneously an array and an arguments object.</li><li>Step 11.d.2 (updating <code>length</code>) is a bit dangerous because it happens before step 12. Step 12 may fail due to an out-of-memory or other internal condition, which leaves the <code>length</code> updated but the element missing.</li></ul><h2 id="minor-improvements" tabindex="-1">Minor improvements <a class="header-anchor" href="#minor-improvements" aria-label="Permalink to &quot;Minor improvements&quot;">​</a></h2><p>Addressing the array <code>length</code> issue:</p><ol><li>Check and/or coerce <code>O</code> as follows: a. If <code>O</code> is <code>null</code> or <code>undefined</code>, throw a <code>TypeError</code>. (This is the <code>CheckObjectCoercible</code> part; the throw is unconditional.) b. If <code>O</code> is a boolean: set <code>curr</code> to the built-in <code>Boolean</code> prototype object (skip creation of temporary) c. Else if <code>O</code> is a number: set <code>curr</code> to the built-in <code>Number</code> prototype object (skip creation of temporary) d. Else if <code>O</code> is a string: 1. Set <code>P</code> to <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.) 2. If <code>P</code> is <code>length</code>, goto REJECT. 3. If <code>P</code> is a valid array index within the string length, goto REJECT. 4. Set <code>curr</code> to the built-in <code>String</code> prototype object (skip creation of temporary) 5. Goto NEXT. (Avoid double coercion of <code>P</code>.) e. Else if <code>O</code> is an object: set <code>curr</code> to <code>O</code>. f. Else, Throw a <code>TypeError</code>. (Note that this case should not happen, as steps a-e are exhaustive. However, this step is useful as a fallback, and for handling any internal types.)</li><li>Let <code>P</code> be <code>ToString(P)</code>. (This may have side effects if <code>P</code> is an object.)</li><li><strong>NEXT:</strong> Let <code>desc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>curr</code> with property name <code>P</code>.</li><li>If <code>desc</code> is <code>undefined</code>: a. Let <code>curr</code> be the value of the <code>[[Prototype]]</code> internal property of <code>curr</code>. b. If <code>curr</code> is not <code>null</code>, goto NEXT. c. If <code>O</code> is not an object (was coerced), goto REJECT. d. If <code>O.[[Extensible]]</code> is <code>false</code>, goto REJECT. e. Goto NEWPROP.</li><li>If <code>IsDataDescriptor(desc)</code>: a. If <code>O</code> is not an object (was coerced), goto REJECT. b. If <code>curr</code> != <code>O</code> (property is an inherited data property): (Note: assumes there are no prototype loops.) 1. If <code>O.[[Extensible]</code> is <code>false</code>, goto REJECT. 2. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 3. Goto NEWPROP. c. Else (property is an own data property): 1. If <code>desc.[[Writable]]</code> is <code>false</code>, goto REJECT. 2. Goto UPDATEPROP.</li><li>Else (property is an accessor): a. If <code>desc.[[Set]]</code> is <code>undefined</code>, goto REJECT. b. Call the <code>[[Call]]</code> internal method of <code>desc.[[Set]]</code> providing <code>O</code> as the <code>this</code> value and providing <code>V</code> as the sole argument. (Note: the difference to a basic <code>[[Put]]</code> is that the setter <code>this</code> binding is the original, uncoerced object.) c. Return.</li><li><strong>UPDATEPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for existing property.) If <code>O</code> is an <code>Array</code> object, and <code>P</code> is <code>&quot;length&quot;</code>, then: a. Let <code>newLen</code> be <code>ToUint32(V)</code>. b. If <code>newLen</code> is not equal to <code>ToNumber(V)</code>, goto REJECTRANGE. c. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a <code>length</code> data property that cannot be deleted or reconfigured. d. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) e. If <code>newLen</code> &lt; <code>oldLen</code>, then: 1. Let <code>shortenSucceeded</code>, <code>finalLen</code> be the result of calling the internal helper <code>ShortenArray()</code> with <code>oldLen</code> and <code>newLen</code>. 2. Update the property (<code>&quot;length&quot;</code>) value to <code>finalLen</code>. 3. Goto REJECT, if <code>shortenSucceeded</code> is <code>false</code>. 4. Return. f. Update the property (<code>&quot;length&quot;</code>) value to <code>newLen</code>. g. Return.</li><li>Set the <code>[[Value]]</code> attribute of the property named <code>P</code> of object <code>O</code> to <code>V</code>. (Since it is side effect free to update the value with the same value, no check for that case is needed.)</li><li>If <code>O</code> is an arguments object which has a <code>[[ParameterMap]]</code> internal property: a. Let <code>map</code> be the value of the <code>[[ParameterMap]]</code> internal property of the arguments object. b. If the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>map</code> passing <code>P</code> as the argument is not <code>undefined</code>, then: 1. Call the <code>[[Put]]</code> internal method of <code>map</code> passing <code>P</code>, <code>V</code>, and <code>Throw</code> as the arguments. (This updates the bound variable value.)</li><li>Return.</li><li><strong>NEWPROP:</strong> (Inlined <code>[[DefineOwnProperty]]</code> call for new property.) Let <code>pendingLength</code> be 0 (zero).</li><li>If <code>O</code> is an <code>Array</code> object and <code>P</code> is an array index (E5 Section 15.4), then: a. Let <code>oldLenDesc</code> be the result of calling the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> passing <code>&quot;length&quot;</code> as the argument. The result will never be <code>undefined</code> or an accessor descriptor because <code>Array</code> objects are created with a length data property that cannot be deleted or reconfigured. b. Let <code>oldLen</code> be <code>oldLenDesc.[[Value]]</code>. (Note that <code>oldLen</code> is guaranteed to be a unsigned 32-bit integer.) c. Let <code>index</code> be <code>ToUint32(P)</code>. d. If <code>index</code> &gt;= <code>oldLen</code>: 1. Goto REJECT <code>oldLenDesc.[[Writable]]</code> is <code>false</code>. 2. Let <code>pendingLength</code> be <code>index + 1</code> (always non-zero).</li><li>Create an own data property named <code>P</code> of object <code>O</code> whose attributes are: <ul><li><code>[[Value]]: V</code></li><li><code>[[Writable]]: true</code></li><li><code>[[Enumerable]]: true</code></li><li><code>[[Configurable]]: true</code></li></ul></li><li>If <code>pendingLength</code> &gt; <code>0</code>: a. Update the <code>&quot;length&quot;</code> property of <code>O</code> to the value <code>pendingLength</code>. This always succeeds. (Note: this can only happen for an <code>Array</code> object, and the <code>length</code> property must exist and has already been checked to be writable.)</li><li>Return.</li><li><strong>REJECT</strong>: If <code>Throw</code> is <code>true</code>, then throw a <code>TypeError</code> exception, otherwise return.</li></ol><h2 id="fast-path-for-array-indices" tabindex="-1">Fast path for array indices <a class="header-anchor" href="#fast-path-for-array-indices" aria-label="Permalink to &quot;Fast path for array indices&quot;">​</a></h2><p>There is currently no fast path for array indices in the implementation.</p><p>This is primarily because to implement <code>[[Put]</code> properly, the prototype chain needs to be walked when creating new properties, as an ancestor property may prevent or capture the write. The current implementation cannot walk the prototype chain without coercing the key to a string first. A fast path could be easily added for writing to existing array entries, though, but it&#39;s probably better to solve the problem a bit more comprehensively.</p><h2 id="implementation-notes" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h2><ul><li>Property writes may fail for out of memory or other internal reasons. In such cases the algorithm should just throw an error and avoid making any updates to the object state. This is easy for normal properties, but there are some subtle issues when dealing with exotic behaviors which link multiple properties together and should be updated either atomically or in some consistent manner. In particular: <ul><li>For NEWPROP, if the property written is an array index which updates array <code>length</code>, the property write should be performed first. If the property write succeeds <code>length</code> should be updated (and should never fail):</li></ul></li></ul><h2 id="final-version" tabindex="-1">Final version <a class="header-anchor" href="#final-version" aria-label="Permalink to &quot;Final version&quot;">​</a></h2><p>(See above.)</p>`,50)]))}const f=o(r,[["render",a]]);export{u as __pageData,f as default};
