import{_ as o,c as t,a2 as a,o as n}from"./chunks/framework.CKGreiRV.js";const p=JSON.parse('{"title":"Duktape C module convention","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/c-module-convention.md","filePath":"resource/duktape/doc/c-module-convention.md","lastUpdated":1732350347000}'),i={name:"resource/duktape/doc/c-module-convention.md"};function l(d,e,r,u,c,s){return n(),t("div",null,e[0]||(e[0]=[a(`<h1 id="duktape-c-module-convention" tabindex="-1">Duktape C module convention <a class="header-anchor" href="#duktape-c-module-convention" aria-label="Permalink to &quot;Duktape C module convention&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>This document provides a recommended convention for writing an init function for a C module. The convention allows modules to be used with both static linking and DLL loading, and either as part of Duktape&#39;s CommonJS module loading or outside of it.</p><p>The convention is in no way mandatory and it&#39;s perfectly fine to use a different module loader convention for your project. However, modules following this convention will be easier to share between projects.</p><h2 id="module-init-function" tabindex="-1">Module init function <a class="header-anchor" href="#module-init-function" aria-label="Permalink to &quot;Module init function&quot;">​</a></h2><p>The init function for a module <code>my_module</code> should have the following form:</p><pre><code>duk_ret_t dukopen_my_module(duk_context *ctx) {
    /* Initialize module in whatever way is most appropriate.
     * Called as a Duktape/C function.
     *
     * Push the module result (e.g. an object with exported symbols or
     * a function) on top of the value stack and return 1 to indicate
     * there&#39;s a return value.  Temporary values can be left below
     * the return value like in normal Duktape/C functions.
     */

    duk_push_object(ctx);  /* module result */

    duk_put_function_list(ctx, -1, my_module_funcs);

    duk_push_int(ctx, 42);
    duk_put_prop_string(ctx, -2, &quot;meaningOfLife&quot;);

    return 1;  /* return module value */
}
</code></pre><p>The init function is called as a Duktape/C function. When initializing the module manually, you should use:</p><pre><code>duk_push_c_function(ctx, dukopen_my_module, 0 /*nargs*/);
duk_call(ctx, 0);  /* or duk_pcall() if you want to catch errors */

/* Stack top contains module value */
</code></pre><p>A DLL loader should use the same convention to call the init function after figuring out the init function name and locating it from the DLL symbol table.</p><h2 id="dll-name" tabindex="-1">DLL name <a class="header-anchor" href="#dll-name" aria-label="Permalink to &quot;DLL name&quot;">​</a></h2><p>When a C module is compiled into a DLL, the DLL filename should include the module name (<code>my_module</code> in the running example) with any platform specific prefix and suffix. For example:</p><pre><code>my_module.so   # Linux
my_module.dll  # Windows
</code></pre><p>A DLL loader should assume that the init function name is <code>dukopen_</code> followed by the module name part extracted from the DLL filename (here, <code>dukopen_my_module()</code>).</p><h2 id="module-name" tabindex="-1">Module name <a class="header-anchor" href="#module-name" aria-label="Permalink to &quot;Module name&quot;">​</a></h2><p>To avoid case conversion and special character issues, module names should have the form:</p><pre><code>[a-zA-Z_][0-9a-zA-Z_-]*
</code></pre><p>This should minimize platform issues.</p><h2 id="mixed-ecmascript-c-modules" tabindex="-1">Mixed ECMAScript / C modules <a class="header-anchor" href="#mixed-ecmascript-c-modules" aria-label="Permalink to &quot;Mixed ECMAScript / C modules&quot;">​</a></h2><p>When a module is being initialized by a CommonJS aware module loader, the loader can support mixed modules containing both C and ECMAScript code. For example:</p><pre><code>my_module.so   # C module
my_module.js   # ECMAScript module (CommonJS)
</code></pre><p>To support mixed modules, a Duktape 1.x <code>modSearch()</code> function should:</p><ul><li>First load the C module normally, yielding a return value RET.</li><li>If RET is an object, copy the own properties of RET into the <code>exports</code> value created by Duktape. It should then return the source code of the ECMAScript module; when executed, further symbols get added to the same <code>exports</code> value.</li><li>If RET is not an object, ignore it and load the ECMAScript module normally. (Alternatively, write RET to a fixed export name to make it accessible, e.g. <code>exports.value</code>.)</li></ul><p>The algorithm for Duktape 2.0 is still under design, but at a high level:</p><ul><li>First load the C module normally, yielding a return value RET.</li><li>If RET is an object, use it to initialize the CommonJS <code>exports</code> value before loading the ECMAScript module. The ECMAScript module can then use whatever symbols the C modules registered, and add further symbols to the same <code>exports</code> value.</li><li>If RET is not an object, ignore it and load the ECMAScript module normally. (Alternatively, expose RET with a fixed name, e.g. initialize <code>exports</code> as <code>{ value: RET }</code>.)</li></ul><p>Since Duktape 1.3 the <code>modSearch()</code> function can overwrite <code>module.exports</code> which allows you to implement the Duktape 2.0 approach in Duktape 1.x too.</p><h2 id="duktape-1-x-commonjs-notes" tabindex="-1">Duktape 1.x CommonJS notes <a class="header-anchor" href="#duktape-1-x-commonjs-notes" aria-label="Permalink to &quot;Duktape 1.x CommonJS notes&quot;">​</a></h2><h3 id="duktape-1-3-and-above" tabindex="-1">Duktape 1.3 and above <a class="header-anchor" href="#duktape-1-3-and-above" aria-label="Permalink to &quot;Duktape 1.3 and above&quot;">​</a></h3><p>In Duktape 1.3 you can replace <code>module.exports</code> with the object returned by the native module initialization function. That value then becomes the result of the original <code>require()</code> call.</p><p>For an example, see: <a href="https://github.com/svaarala/duktape/blob/master/tests/api/test-dev-cmodule-guide.c" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/blob/master/tests/api/test-dev-cmodule-guide.c</a>.</p><h3 id="prior-to-duktape-1-3" tabindex="-1">Prior to Duktape 1.3 <a class="header-anchor" href="#prior-to-duktape-1-3" aria-label="Permalink to &quot;Prior to Duktape 1.3&quot;">​</a></h3><p>Prior to Duktape 1.3 the module <code>exports</code> value is always an object created by Duktape, and cannot be replaced by modSearch(). modSearch() can only add symbols to the pre-created object. This has two implications for implementing modSearch():</p><ul><li>When a C module returns an object, the symbols from the object must be copied to the pre-created <code>exports</code> value manually by the modSearch() function.</li><li>When a C module returns a non-object, there are several alternatives: <ul><li>The modSearch() function can ignore the module value. This will make the module value inaccessible (unless the C module init function registered symbols directly to the global object or similar).</li><li>The modSearch() function can copy the module value into a fixed name in the <code>exports</code> table. Suggested name is <code>exports.value</code>.</li></ul></li></ul><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h2><ul><li>The convention may not work on all platforms where Duktape itself ports to. For instance, a platform might have no DLL support or have filename restrictions that don&#39;t allow DLLs to be named as specified above.</li><li>The convention is not &quot;CommonJS native&quot;: a C module doesn&#39;t get an exports table and cannot load sub-modules (at least relative to its own CommonJS identifier). This trade-off is intentional to keep the C module convention as simple as possible.</li><li>CommonJS module loading prior to Duktape 1.3 doesn&#39;t support modules with a non-object return value (i.e. all modules return an <code>exports</code> table). This module convention is not limited to object return values so that non-object modules can be supported in Duktape 1.3 and above.</li></ul>`,35)]))}const h=o(i,[["render",l]]);export{p as __pageData,h as default};
