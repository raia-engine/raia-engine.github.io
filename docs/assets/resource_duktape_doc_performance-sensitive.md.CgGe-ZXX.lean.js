import{_ as o,c as i,a2 as t,o as a}from"./chunks/framework.DPuwY6B9.js";const f=JSON.parse('{"title":"Performance sensitive environments","description":"","frontmatter":{},"headers":[],"relativePath":"resource/duktape/doc/performance-sensitive.md","filePath":"resource/duktape/doc/performance-sensitive.md","lastUpdated":null}'),r={name:"resource/duktape/doc/performance-sensitive.md"};function n(s,e,l,c,d,p){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="performance-sensitive-environments" tabindex="-1">Performance sensitive environments <a class="header-anchor" href="#performance-sensitive-environments" aria-label="Permalink to &quot;Performance sensitive environments&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>This document describes suggested feature options for optimizing Duktape performance for performance sensitive environments.</p><p>The following genconfig option file template enables most performance related options: <code>config/examples/performance_sensitive.yaml</code>.</p><h2 id="compiler-optimization-level" tabindex="-1">Compiler optimization level <a class="header-anchor" href="#compiler-optimization-level" aria-label="Permalink to &quot;Compiler optimization level&quot;">​</a></h2><p>Size optimization using <code>-Os</code> is a good default when performance is not critical. However, it&#39;s not ideal when performance matters for several reasons:</p><ul><li><p>Although <code>-Os</code> optimized code performs reasonably well, even <code>-O2</code> will yield significantly better results.</p></li><li><p>Code performance with <code>-Os</code> can vary a great deal even when source code changes are innocent. It&#39;s not uncommon for some performance test result to change +/- 10-30% with unrelated changes. Presumably this is caused by changes in code alignment etc.</p><p>Because of this, <code>-Os</code> is definitely a bad idea for measuring performance.</p></li><li><p>Overall suggestion is to use <code>-O2</code> and try <code>-O3</code> if the end result is better. Note that <code>-O3</code> is not always better because the code is larger and may not fit in caches as well as with <code>-O2</code>.</p></li></ul><h2 id="profile-guided-optimization-pgo" tabindex="-1">Profile guided optimization (PGO) <a class="header-anchor" href="#profile-guided-optimization-pgo" aria-label="Permalink to &quot;Profile guided optimization (PGO)&quot;">​</a></h2><p>Duktape source files contain some performance attributes like forced inline forced noinline, and hot/cold attributes.</p><p>A better alternative is to use profile guided optimization (PGO) which is highly recommended for performance sensitive environments. For example, GCC -O2 with PGO can be around 20% faster than GCC -O2 without PGO.</p><p>See for example the following:</p><ul><li><a href="http://stackoverflow.com/questions/13881292/gcc-profile-guided-optimization-pgo" target="_blank" rel="noreferrer">http://stackoverflow.com/questions/13881292/gcc-profile-guided-optimization-pgo</a></li><li><a href="https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx" target="_blank" rel="noreferrer">https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx</a></li></ul><p>With GCC PGO is relatively simple:</p><ul><li>Use <code>-fprofile-generate</code> to compile Duktape and your application.</li><li>Execute the result with representative (this is important) source files.</li><li>Use <code>-fprofile-use</code> to recompile Duktape and your application.</li></ul><h2 id="suggested-feature-options" tabindex="-1">Suggested feature options <a class="header-anchor" href="#suggested-feature-options" aria-label="Permalink to &quot;Suggested feature options&quot;">​</a></h2><ul><li><p>On some platforms <code>setjmp/longjmp</code> store the signal mask and may be much slower than alternative like <code>_setjmp/_longjmp</code> or <code>sigsetjmp/siglongjmp</code>:</p><ul><li>Check the current provider from <code>duk_config.h</code> or <code>config/platforms/</code> header snippets.</li><li>Edit <code>DUK_SETJMP</code>, <code>DUK_LONGJMP</code>, and <code>DUK_JMPBUF_TYPE</code> to change the setjmp provider.</li><li>On some platforms (e.g. macOS/iOS) Duktape will automatically use <code>_setjmp()</code>.</li></ul></li><li><p>Consider enabling &quot;fastints&quot;:</p><ul><li><code>#define DUK_USE_FASTINT</code></li></ul><p>Fastints are often useful on platforms with soft floats, but they can also speed up execution on some hard float platforms (even on x64). The benefit (or penalty) depends on the kind of ECMAScript code executed, e.g. code heavy on integer loops benefits.</p></li><li><p>Enable specific fast paths:</p><ul><li><code>#define DUK_USE_JSON_STRINGIFY_FASTPATH</code></li><li><code>#define DUK_USE_JSON_QUOTESTRING_FASTPATH</code></li><li><code>#define DUK_USE_JSON_DECSTRING_FASTPATH</code></li><li><code>#define DUK_USE_JSON_DECNUMBER_FASTPATH</code></li><li><code>#define DUK_USE_JSON_EATWHITE_FASTPATH</code></li></ul></li><li><p>If you don&#39;t need debugging support or execution timeout support, ensure the following are <strong>not enabled</strong>:</p><ul><li><code>#define DUK_USE_INTERRUPT_COUNTER</code></li><li><code>#define DUK_USE_DEBUGGER_SUPPORT</code></li></ul><p>Especially interrupt counter option will have a measurable performance impact because it includes code executed for every bytecode instruction dispatch.</p></li><li><p>Disable safety check for value stack resizing so that if calling code fails to <code>duk_check_stack()</code> value stack, the result is memory unsafe behavior rather than an explicit error, but stack operations are faster:</p><ul><li><code>#undef DUK_USE_VALSTACK_UNSAFE</code></li></ul></li></ul>',16)]))}const m=o(r,[["render",n]]);export{f as __pageData,m as default};
