import{_ as a,c as i,a2 as e,o as n}from"./chunks/framework.DPuwY6B9.js";const c=JSON.parse('{"title":"文字列バッファライブラリ","description":"","frontmatter":{},"headers":[],"relativePath":"resource/luajit/string_buffers.md","filePath":"resource/luajit/string_buffers.md","lastUpdated":1729914702000}'),t={name:"resource/luajit/string_buffers.md"};function l(p,s,h,d,k,r){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="文字列バッファライブラリ" tabindex="-1">文字列バッファライブラリ <a class="header-anchor" href="#文字列バッファライブラリ" aria-label="Permalink to &quot;文字列バッファライブラリ&quot;">​</a></h1><p>文字列バッファライブラリは、文字列のようなデータの高性能な操作を可能にします。</p><p>Luaの文字列が定数であるのに対し、文字列バッファは8ビット（バイナリ透過的な）文字の可変シーケンスです。データは文字列バッファに格納、フォーマット、エンコードされ、後で変換、抽出、デコードされます。</p><p>便利な文字列バッファAPIは、多くの中間文字列を作成することを要求する通常の文字列操作タスクを簡素化します。文字列バッファは冗長なメモリコピー、オブジェクト生成、文字列インターニング、ガーベージコレクションのオーバーヘッドを排除することでパフォーマンスを向上させます。FFIライブラリと併用することで、ゼロコピー操作を可能にします。</p><p>文字列バッファライブラリには、Luaオブジェクトのための高性能なシリアライザも含まれています。</p><h2 id="文字列バッファライブラリの使用" tabindex="-1">文字列バッファライブラリの使用 <a class="header-anchor" href="#文字列バッファライブラリの使用" aria-label="Permalink to &quot;文字列バッファライブラリの使用&quot;">​</a></h2><p>文字列バッファライブラリはLuaJITにデフォルトで組み込まれていますが、デフォルトで読み込まれるわけではありません。その関数が必要なLuaファイルの先頭に次のコードを追加します：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;string.buffer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>このページに示されている構文の慣習では、bufferはバッファライブラリを指し、bufは個々のバッファオブジェクトを指します。</p><p>Lua関数呼び出し（例: buffer.new()、ドット付き）とLuaメソッド呼び出し（例: buf:reset()、コロン付き）の違いに注意してください。</p><h3 id="バッファオブジェクト" tabindex="-1">バッファオブジェクト <a class="header-anchor" href="#バッファオブジェクト" aria-label="Permalink to &quot;バッファオブジェクト&quot;">​</a></h3><p>バッファオブジェクトは、ガーベージコレクションされるLuaオブジェクトです。buffer.new()で作成された後、多くの操作に再利用することができ（そしてすべきです）。バッファオブジェクトへの最後の参照がなくなると、最終的にガーベージコレクタによって割り当てられたバッファスペースと共に解放されます。</p><p>バッファはFIFO（先入れ先出し）データ構造のように動作します。データはバッファの末尾に追加（書き込み）され、バッファの前から消費（読み取り）されます。これらの操作は自由に混在させることができます。</p><p>文字が格納されるバッファスペースは自動的に管理され、必要に応じて拡大し、既に消費されたスペースはリサイクルされます。より詳細な制御が必要な場合は、<code>buffer.new(size)</code>や<code>buf:free()</code>を使用します。</p><p>単一のバッファの最大サイズは、Lua文字列の最大サイズと同じで、約2ギガバイト未満です。巨大なデータサイズには、文字列もバッファも適切なデータ構造ではありません。オペレーティングシステムの仮想メモリ制限までメモリやファイルを直接マッピングするためにFFIライブラリを使用してください。</p><h3 id="バッファメソッドの概要" tabindex="-1">バッファメソッドの概要 <a class="header-anchor" href="#バッファメソッドの概要" aria-label="Permalink to &quot;バッファメソッドの概要&quot;">​</a></h3><ul><li><code>buf:put*()</code>系のメソッドは、バッファの末尾に文字を追加（書き込み）します。</li><li><code>buf:get*()</code>系のメソッドは、バッファの前から文字を消費（読み取り）します。</li><li><code>buf:tostring()</code>のような他のメソッドはバッファの内容を読み取るだけで、バッファを変更しません。</li><li><code>buf:set()</code>メソッドは、文字列またはFFI cdataオブジェクトをバッファとしてゼロコピーで消費することを可能にします。</li><li>FFI固有のメソッドはゼロコピーの読み書きスタイルの操作を許可するか、バッファの内容をその場で変更します。FFIの注意点も確認してください。</li><li>特定のものを返す必要のないメソッドは便宜上バッファオブジェクト自体を返します。これにより、メソッドチェーンが可能になります。例：<code>buf:reset():encode(obj)</code>や<code>buf:skip(len):get()</code></li></ul><h2 id="バッファの作成と管理" tabindex="-1">バッファの作成と管理 <a class="header-anchor" href="#バッファの作成と管理" aria-label="Permalink to &quot;バッファの作成と管理&quot;">​</a></h2><h3 id="local-buf-buffer-new-size-options" tabindex="-1"><code>local buf = buffer.new([size [,options]])</code> <a class="header-anchor" href="#local-buf-buffer-new-size-options" aria-label="Permalink to &quot;\`local buf = buffer.new([size [,options]])\`&quot;">​</a></h3><h3 id="local-buf-buffer-new-options" tabindex="-1"><code>local buf = buffer.new([options])</code> <a class="header-anchor" href="#local-buf-buffer-new-options" aria-label="Permalink to &quot;\`local buf = buffer.new([options])\`&quot;">​</a></h3><p>新しいバッファオブジェクトを作成します。</p><p>任意のサイズ引数は、最小の初期バッファサイズを保証します。これは、必要なバッファサイズが事前にわかっている場合の最適化です。いずれにせよ、バッファスペースは必要に応じて拡大します。</p><p>任意のオプションテーブルは、様々なシリアライゼーションオプションを設定します。</p><h3 id="buf-buf-reset" tabindex="-1"><code>buf = buf:reset()</code> <a class="header-anchor" href="#buf-buf-reset" aria-label="Permalink to &quot;\`buf = buf:reset()\`&quot;">​</a></h3><p>バッファをリセット（空に）します。割り当てられたバッファスペースは解放されず、再利用されるかもしれません。</p><h3 id="buf-buf-free" tabindex="-1"><code>buf = buf:free()</code> <a class="header-anchor" href="#buf-buf-free" aria-label="Permalink to &quot;\`buf = buf:free()\`&quot;">​</a></h3><p>バッファオブジェクトのバッファスペースは解放されます。オブジェクト自体はそのままで、空で再利用可能です。</p><div class="info custom-block"><p class="custom-block-title">注意</p><p>通常、このメソッドを使用する必要はありません。バッファオブジェクトが収集されると、ガーベージコレクタが自動的にバッファスペースを解放します。関連するメモリを直ちに解放する必要がある場合にこのメソッドを使用してください。</p></div><h2 id="バッファライター" tabindex="-1">バッファライター <a class="header-anchor" href="#バッファライター" aria-label="Permalink to &quot;バッファライター&quot;">​</a></h2><h3 id="buf-buf-put-str-num-obj" tabindex="-1"><code>buf = buf:put([str|num|obj] [,…])</code> <a class="header-anchor" href="#buf-buf-put-str-num-obj" aria-label="Permalink to &quot;\`buf = buf:put([str|num|obj] [,…])\`&quot;">​</a></h3><p>文字列<code>str</code>、数値<code>num</code>、または<code>__tostring</code>メタメソッドを持つ任意のオブジェクト<code>obj</code>をバッファに追加します。複数の引数は指定された順序で追加されます。</p><p>バッファをバッファに追加することは可能であり、内部的には短絡されますが、それでもコピーが発生します。バッファの書き込みを組み合わせて単一のバッファを使用する方が良いでしょう。</p><h3 id="buf-buf-putf-format" tabindex="-1"><code>buf = buf:putf(format, …)</code> <a class="header-anchor" href="#buf-buf-putf-format" aria-label="Permalink to &quot;\`buf = buf:putf(format, …)\`&quot;">​</a></h3><p>フォーマットされた引数をバッファに追加します。フォーマット文字列は<code>string.format()</code>と同じオプションをサポートします。</p><h3 id="buf-buf-putcdata-cdata-len-ffi" tabindex="-1"><code>buf = buf:putcdata(cdata, len) FFI</code> <a class="header-anchor" href="#buf-buf-putcdata-cdata-len-ffi" aria-label="Permalink to &quot;\`buf = buf:putcdata(cdata, len) FFI\`&quot;">​</a></h3><p>FFI cdataオブジェクトによって指されるメモリから指定された<code>len</code>バイト数をバッファに追加します。オブジェクトは（定数）ポインタに変換可能である必要があります。</p><h3 id="buf-buf-set-str" tabindex="-1"><code>buf = buf:set(str)</code> <a class="header-anchor" href="#buf-buf-set-str" aria-label="Permalink to &quot;\`buf = buf:set(str)\`&quot;">​</a></h3><h3 id="buf-buf-set-cdata-len-ffi" tabindex="-1"><code>buf = buf:set(cdata, len) FFI</code> <a class="header-anchor" href="#buf-buf-set-cdata-len-ffi" aria-label="Permalink to &quot;\`buf = buf:set(cdata, len) FFI\`&quot;">​</a></h3><p>このメソッドは、文字列またはFFI cdataオブジェクトをバッファとしてゼロコピーで消費することを可能にします。渡された文字列<code>str</code>またはFFI cdataオブジェクトへの参照がバッファに格納されます。元々割り当てられていたバッファスペースは解放されます。これは<code>buf:put*()</code>メソッドとは異なり、追加操作ではありません。</p><p>このメソッドを呼び出した後、バッファは<code>buf:free():put(str)</code>または<code>buf:free():put(cdata, len)</code>が呼び出されたかのように振る舞います。しかし、バッファが消費されるだけであれば、データは参照されるだけでコピーされません。</p><p>後にバッファに書き込みが行われる場合、参照されたデータはコピーされ、オブジェクト参照は削除されます（書き込み時コピーのセマンティクス）。</p><p>格納された参照はガーベージコレクタのためのアンカーであり、元々渡された文字列やFFI cdataオブジェクトを生存させ続けます。</p><h3 id="ptr-len-buf-reserve-size-ffi" tabindex="-1"><code>ptr, len = buf:reserve(size)</code> FFI <a class="header-anchor" href="#ptr-len-buf-reserve-size-ffi" aria-label="Permalink to &quot;\`ptr, len = buf:reserve(size)\` FFI&quot;">​</a></h3><h3 id="buf-buf-commit-used-ffi" tabindex="-1"><code>buf = buf:commit(used)</code> FFI <a class="header-anchor" href="#buf-buf-commit-used-ffi" aria-label="Permalink to &quot;\`buf = buf:commit(used)\` FFI&quot;">​</a></h3><p><code>reserve</code>メソッドは、バッファ内に少なくともsizeバイトの書き込みスペースを予約します。このスペースを指すuint8_t * FFI cdataポインタ<code>ptr</code>を返します。</p><p>利用可能な長さはバイト単位で<code>len</code>に返されます。これは少なくともsizeバイトですが、効率的なバッファ成長を容易にするためにより多くなることがあります。追加スペースを利用することも、<code>len</code>を無視してsizeバイトだけを使用することもできます。</p><p><code>commit</code>メソッドは、以前に返された書き込みスペースの使用済みバイトをバッファデータに追加します。</p><p>このメソッドの組み合わせは、Cの読み込みスタイルAPIをゼロコピーで使用することを可能にします：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MIN_SIZE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 65536</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">repeat</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr, len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MIN_SIZE)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, ptr, len)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> then</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> break</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> -- EOF.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> then</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;read error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">until</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre></div><p>予約された書き込みスペースは初期化されていません。<code>commit</code>メソッドを呼び出す前に、少なくとも使用されたバイト数を書き込む必要があります。バッファに何も追加されない場合（例えば、エラーが発生した場合）は、<code>commit</code>メソッドを呼び出す必要はありません。</p><h2 id="バッファリーダー" tabindex="-1">バッファリーダー <a class="header-anchor" href="#バッファリーダー" aria-label="Permalink to &quot;バッファリーダー&quot;">​</a></h2><h3 id="len-buf" tabindex="-1"><code>len = #buf</code> <a class="header-anchor" href="#len-buf" aria-label="Permalink to &quot;\`len = #buf\`&quot;">​</a></h3><p>バッファデータの現在の長さをバイト単位で返します。</p><h3 id="res-str-num-buf-str-num-buf" tabindex="-1"><code>res = str|num|buf .. str|num|buf […]</code> <a class="header-anchor" href="#res-str-num-buf-str-num-buf" aria-label="Permalink to &quot;\`res = str|num|buf .. str|num|buf […]\`&quot;">​</a></h3><p>Luaの連結演算子<code>..</code>は、文字列や数値と同様に、バッファも受け入れます。これは常に文字列を返し、バッファは返しません。</p><p>ただし、これは便宜上サポートされていますが、バッファを使用する主な理由の1つである文字列の割り当てを避けることを妨げます。<code>buf:put()</code>や<code>buf:get()</code>で書き直してください。</p><p><code>__concat</code>メタメソッドを持つ関連しないオブジェクトとこれを混在させると機能しない可能性があります。これらはおそらく文字列だけを期待しているでしょう。</p><h3 id="buf-buf-skip-len" tabindex="-1"><code>buf = buf:skip(len)</code> <a class="header-anchor" href="#buf-buf-skip-len" aria-label="Permalink to &quot;\`buf = buf:skip(len)\`&quot;">​</a></h3><p>バッファの現在のデータ長までの<code>len</code>バイトをスキップ（消費）します。</p><h3 id="str-buf-get-len-nil" tabindex="-1"><code>str, … = buf:get([len|nil] [,…])</code> <a class="header-anchor" href="#str-buf-get-len-nil" aria-label="Permalink to &quot;\`str, … = buf:get([len|nil] [,…])\`&quot;">​</a></h3><p>バッファデータを消費して、1つまたは複数の文字列を返します。引数なしで呼び出された場合、バッファデータ全体が消費されます。数値で呼び出された場合、最大<code>len</code>バイトが消費されます。<code>nil</code>引数は残りのバッファスペースを消費します（これは最後の引数としてのみ意味があります）。複数の引数は、与えられた順序でバッファデータを消費します。</p><div class="info custom-block"><p class="custom-block-title">注意</p><p>ゼロの長さ、または残りのバッファデータがない場合は、<code>nil</code>ではなく空の文字列を返します。</p></div><h3 id="str-buf-tostring" tabindex="-1"><code>str = buf:tostring()</code> <a class="header-anchor" href="#str-buf-tostring" aria-label="Permalink to &quot;\`str = buf:tostring()\`&quot;">​</a></h3><h3 id="str-tostring-buf" tabindex="-1"><code>str = tostring(buf)</code> <a class="header-anchor" href="#str-tostring-buf" aria-label="Permalink to &quot;\`str = tostring(buf)\`&quot;">​</a></h3><p>バッファデータから文字列を生成しますが、それを消費しません。バッファは変わらずに残ります。</p><p>バッファオブジェクトは<code>__tostring</code>メタメソッドも定義しています。これは、バッファを<code>tostring()</code>グローバル関数や文字列の代わりに受け入れる他の多くの関数に渡すことができることを意味します。<code>io.write()</code>のような関数での重要な内部使用は、中間文字列オブジェクトの生成を避けるためにショートサーキットされます。</p><h3 id="ptr-len-buf-ref-ffi" tabindex="-1"><code>ptr, len = buf:ref() FFI</code> <a class="header-anchor" href="#ptr-len-buf-ref-ffi" aria-label="Permalink to &quot;\`ptr, len = buf:ref() FFI\`&quot;">​</a></h3><p>バッファデータを指す<code>uint8_t * FFI cdata</code>ポインター<code>ptr</code>を返します。バッファデータの長さ（バイト単位）は<code>len</code>で返されます。</p><p>返されたポインタは、バッファと長さを期待するC関数に直接渡すことができます。また、バッファデータのバイト単位での読み取り（<code>local x = ptr[i]</code>）や書き込み（<code>ptr[i] = 0x40</code>）も可能です。</p><p><code>skip</code>メソッドと組み合わせることで、Cの書き込みスタイルAPIのゼロコピー使用が可能になります：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">repeat</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr, len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> then</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> break</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, ptr, len)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> then</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;write error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">skip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">until</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len</span></span></code></pre></div><p>Lua文字列とは異なり、バッファデータは暗黙的にゼロ終了されません。<code>ptr</code>をゼロ終了文字列を期待するC関数に渡すことは安全ではありません。<code>len</code>を使用していない場合は、何か間違ったことをしています。</p><h2 id="luaオブジェクトのシリアライズ" tabindex="-1">Luaオブジェクトのシリアライズ <a class="header-anchor" href="#luaオブジェクトのシリアライズ" aria-label="Permalink to &quot;Luaオブジェクトのシリアライズ&quot;">​</a></h2><p>以下の関数とメソッドは、Luaオブジェクトを文字列に高速でシリアライズ（エンコード）し、それを再びLuaオブジェクトにデコードすることを可能にします。これにより、構造化されたデータの便利な保存と転送が可能になります。</p><p>エンコードされたデータは内部バイナリフォーマットです。このデータはファイル、バイナリ透過的なデータベースに保存されるか、スレッド、プロセス、またはネットワークを越えて他のLuaJITインスタンスに送信されます。</p><p>エンコーディング速度は、多くの小さなオブジェクトをシリアライズしても、現代のデスクトップまたはサーバークラスのシステムで秒速1ギガバイトに達することがあります。デコーディング速度は主にオブジェクト生成コストによって制限されます。</p><p>シリアライザは、ほとんどのLuaタイプ、一般的なFFI数値タイプ、およびネストされた構造を処理します。関数、スレッドオブジェクト、その他のFFI cdata、完全なユーザーデータは（まだ）シリアライズできません。</p><p>エンコーダーは、ネストされた構造を木としてシリアライズします。単一のオブジェクトへの複数の参照は個別に保存され、デコード後に別々のオブジェクトを生成します。循環参照はエラーを引き起こします。</p><h3 id="シリアライズ関数とメソッド" tabindex="-1">シリアライズ関数とメソッド <a class="header-anchor" href="#シリアライズ関数とメソッド" aria-label="Permalink to &quot;シリアライズ関数とメソッド&quot;">​</a></h3><h4 id="str-buffer-encode-obj" tabindex="-1"><code>str = buffer.encode(obj)</code> <a class="header-anchor" href="#str-buffer-encode-obj" aria-label="Permalink to &quot;\`str = buffer.encode(obj)\`&quot;">​</a></h4><h4 id="buf-buf-encode-obj" tabindex="-1"><code>buf = buf:encode(obj)</code> <a class="header-anchor" href="#buf-buf-encode-obj" aria-label="Permalink to &quot;\`buf = buf:encode(obj)\`&quot;">​</a></h4><p>Luaオブジェクト<code>obj</code>をシリアライズ（エンコード）します。スタンドアロン関数は文字列<code>str</code>を返し、バッファメソッドはエンコーディングをバッファに追加します。</p><p><code>obj</code>はサポートされているLuaタイプのいずれかであればよく、Luaテーブルである必要はありません。</p><p>この関数は、サポートされていないオブジェクトタイプ、循環参照、または深くネストされたテーブルをシリアライズしようとしたときにエラーをスローすることがあります。</p><h4 id="obj-buffer-decode-str" tabindex="-1"><code>obj = buffer.decode(str)</code> <a class="header-anchor" href="#obj-buffer-decode-str" aria-label="Permalink to &quot;\`obj = buffer.decode(str)\`&quot;">​</a></h4><h4 id="obj-buf-decode" tabindex="-1"><code>obj = buf:decode()</code> <a class="header-anchor" href="#obj-buf-decode" aria-label="Permalink to &quot;\`obj = buf:decode()\`&quot;">​</a></h4><p>スタンドアロン関数は文字列<code>str</code>をデシリアライズ（デコード）し、バッファメソッドはバッファから1つのオブジェクトをデシリアライズします。どちらもLuaオブジェクト<code>obj</code>を返します。</p><p>返されるオブジェクトは、サポートされているLuaタイプのいずれかである可能性があります。</p><p>この関数は、形式が正しくないまたは不完全なエンコードデータを受け取った場合にエラーを投げることがあります。スタンドアロン関数は、シングルトップレベルオブジェクトのデコード後に残りのデータがある場合にエラーを投げます。バッファメソッドは、残りのデータをバッファに残します。</p><p>FFIタイプをデシリアライズしようとすると、FFIライブラリが組み込まれていないか、まだ読み込まれていない場合、エラーが発生します。</p><h3 id="シリアライズオプション" tabindex="-1">シリアライズオプション <a class="header-anchor" href="#シリアライズオプション" aria-label="Permalink to &quot;シリアライズオプション&quot;">​</a></h3><p><code>buffer.new()</code>に渡されたオプションテーブルには、以下のメンバー（すべて任意）が含まれている可能性があります：</p><ul><li><code>dict</code>は、シリアライズしているオブジェクトのテーブルキーとしてよく出現する文字列の辞書を保持するLuaテーブルです。これらのキーはシリアライズ中にインデックスとしてコンパクトにエンコードされます。適切に選ばれた辞書は、スペースを節約し、シリアライズ性能を向上させます。</li><li><code>metatable</code>は、シリアライズしているテーブルオブジェクトのメタテーブルの辞書を保持するLuaテーブルです。</li></ul><p><code>dict</code>は文字列の配列であり、<code>metatable</code>はテーブルの配列でなければなりません。どちらもインデックス1から始まり、穴がない（間に<code>nil</code>がない）状態です。テーブルはバッファオブジェクトにアンカーされ、内部的に双方向インデックスに変更されます（自分でこれを行わないでください、単なる配列を渡してください）。テーブルは、<code>buffer.new()</code>に渡された後に変更してはなりません。</p><p>エンコーダーとデコーダーに使用される<code>dict</code>と<code>metatable</code>テーブルは同じでなければなりません。最も一般的なエントリを前面に置きます。後方互換性を保証するためには、末尾に追加してください。古いエンコーディングも読み取れるようになります。いくつかのインデックスを<code>false</code>に設定して、明示的に後方互換性を切り捨てることもできます。これらのインデックスを使用する古いエンコーディングは、デコード時にエラーを投げます。</p><p>エンコーディング時に<code>metatable</code>辞書にないメタテーブルは無視されます。デコードは<code>nil</code>メタテーブルを持つテーブルを返します。</p><div class="info custom-block"><p class="custom-block-title">注意</p><p>オプションテーブルの解析と準備はややコストがかかります。バッファオブジェクトは一度だけ作成し、複数回再利用してください。エンコーダーバッファとデコーダーバッファを混在させないようにしてください。<code>buf:set()</code>メソッドは既に割り当てられたバッファスペースを解放するためです：</p></div><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;commonly&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;used&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keys&quot; </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf_enc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf_dec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf_enc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj):</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf_dec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str):</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h3 id="ストリーミングシリアライズ" tabindex="-1">ストリーミングシリアライズ <a class="header-anchor" href="#ストリーミングシリアライズ" aria-label="Permalink to &quot;ストリーミングシリアライズ&quot;">​</a></h3><p>特定の文脈では、大規模なデータセットの断片的なシリアライズ、すなわちストリーミングを行うことが望ましい場合があります。</p><p>このシリアライズフォーマットは、安全に連結でき、ストリーミングをサポートしています。複数のエンコーディングをバッファに単純に追加し、後で個別にデコードすることができます：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj1)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj2)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>ストリームを反復処理する方法は以下の通りです：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> #</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">buf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  -- 何かしらの処理をobjで行う。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>シリアライズフォーマットはエンコーディングに長さを前置しないため、ネットワークアプリケーションでは長さも伝送する必要があるかもしれません。</p><h3 id="シリアライズフォーマットの仕様" tabindex="-1">シリアライズフォーマットの仕様 <a class="header-anchor" href="#シリアライズフォーマットの仕様" aria-label="Permalink to &quot;シリアライズフォーマットの仕様&quot;">​</a></h3><p>このシリアライズフォーマットは、LuaJITアプリケーションの内部使用を目的として設計されています。シリアライズされたデータは上位互換性があり、サポートされているすべてのLuaJITプラットフォームで移植可能です。</p><p>これは8ビットのバイナリフォーマットであり、人が読める形式ではありません。たとえば、組み込みのゼロや、8ビットクリーンである組み込みLua文字列オブジェクトを変更せずに保存します。エンコードされたデータはストリーミング用に安全に連結され、後で一度に1つのトップレベルオブジェクトをデコードすることができます。</p><p>エンコーディングは比較的コンパクトですが、最小のスペース使用ではなく、最大のパフォーマンスにチューニングされています。一般的なバイト指向データ圧縮アルゴリズムでうまく圧縮できます。</p><p>ここで参照用に文書化されていますが、このフォーマットは明示的に、コンピュータ言語間で構造化されたデータ交換のための「公開標準」（JSONやMessagePackのような）として意図されていません。そのように使用しないでください。</p><p>以下は、トップレベルオブジェクトを開始点とする、文脈自由文法による仕様です。選択肢は<code>|</code>記号で区切られ、<code>*</code>は繰り返しを示します。グループ化は暗黙的または<code>{…}</code>で示されます。終端記号は、バイトとしてエンコードされたプレーンな16進数、または<code>.format</code>接尾辞を持ちます。</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>object    → nil | false | true</span></span>
<span class="line"><span>          | null | lightud32 | lightud64</span></span>
<span class="line"><span>          | int | num | tab | tab_mt</span></span>
<span class="line"><span>          | int64 | uint64 | complex</span></span>
<span class="line"><span>          | string</span></span>
<span class="line"><span></span></span>
<span class="line"><span>nil       → 0x00</span></span>
<span class="line"><span>false     → 0x01</span></span>
<span class="line"><span>true      → 0x02</span></span>
<span class="line"><span></span></span>
<span class="line"><span>null      → 0x03                            // NULLの軽量ユーザーデータ</span></span>
<span class="line"><span>lightud32 → 0x04 data.I                   // 32ビットの軽量ユーザーデータ</span></span>
<span class="line"><span>lightud64 → 0x05 data.L                   // 64ビットの軽量ユーザーデータ</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int       → 0x06 int.I                                 // int32_t</span></span>
<span class="line"><span>num       → 0x07 double.L</span></span>
<span class="line"><span></span></span>
<span class="line"><span>tab       → 0x08                                   // 空のテーブル</span></span>
<span class="line"><span>          | 0x09 h.U h*{object object}          // キー/値ハッシュ</span></span>
<span class="line"><span>          | 0x0a a.U a*object                    // 0基準の配列</span></span>
<span class="line"><span>          | 0x0b a.U a*object h.U h*{object object}      // 混合</span></span>
<span class="line"><span>          | 0x0c a.U (a-1)*object                // 1基準の配列</span></span>
<span class="line"><span>          | 0x0d a.U (a-1)*object h.U h*{object object}  // 混合</span></span>
<span class="line"><span>tab_mt    → 0x0e (index-1).U tab          // メタテーブル辞書エントリ</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int64     → 0x10 int.L                             // FFI int64_t</span></span>
<span class="line"><span>uint64    → 0x11 uint.L                           // FFI uint64_t</span></span>
<span class="line"><span>complex   → 0x12 re.L im.L                         // FFI複素数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>string    → (0x20+len).U len*char.B</span></span>
<span class="line"><span>          | 0x0f (index-1).U                 // 文字列辞書エントリ</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.B = 8ビット</span></span>
<span class="line"><span>.I = 32ビットリトルエンディアン</span></span>
<span class="line"><span>.L = 64ビットリトルエンディアン</span></span>
<span class="line"><span>.U = プレフィックスエンコードされた32ビット符号なし数n:</span></span>
<span class="line"><span>     0x00..0xdf   → n.B</span></span>
<span class="line"><span>     0xe0..0x1fdf → (0xe0|(((n-0xe0)&gt;&gt;8)&amp;0x1f)).B ((n-0xe0)&amp;0xff).B</span></span>
<span class="line"><span>   0x1fe0..       → 0xff n.I</span></span></code></pre></div><h2 id="エラーハンドリング" tabindex="-1">エラーハンドリング <a class="header-anchor" href="#エラーハンドリング" aria-label="Permalink to &quot;エラーハンドリング&quot;">​</a></h2><p>多くのバッファメソッドはエラーを投げる可能性があります。メモリ不足や使用上のエラーは、コードの大きな部分を外側でラップすることで最もよく捕捉されます。とにかく、その後にできることはあまりありません。</p><p>一方で、いくつかのエラーを個別にキャッチしたい場合があります。バッファメソッドは、最初の引数としてバッファオブジェクトを受け取る必要があります。Luaのコロン構文<code>obj:method()</code>はそれを暗黙的に行います。しかし、<code>pcall()</code>でメソッドをラップするには、引数を次のように渡す必要があります：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ok, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pcall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buf, obj)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ok </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  -- errでエラーを処理する。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="ffiの注意点" tabindex="-1">FFIの注意点 <a class="header-anchor" href="#ffiの注意点" aria-label="Permalink to &quot;FFIの注意点&quot;">​</a></h2><p>文字列バッファライブラリは、FFIライブラリと一緒にうまく機能するように設計されています。しかし、FFIライブラリの低レベルの性質上、注意が必要です：</p><p>まず、FFIポインターが0からインデックス付けされていることを覚えておいてください。<code>buf:reserve()</code>や<code>buf:ref()</code>によって返されるスペースは、返されたポインターから始まり、その後のlenバイトの前で終わります。</p><p>つまり、最初の有効なインデックスは<code>ptr[0]</code>であり、最後の有効なインデックスは<code>ptr[len-1]</code>です。返された長さがゼロの場合、有効なインデックスはまったくありません。返されたポインターはNULLである可能性もあります。</p><p>返されたポインターが指すスペースは、バッファがいかなる方法で（追加、消費、リセットなど）変更されない限り、有効です。ポインターはバッファオブジェクト自体のGCアンカーでもありません。</p><p>バッファデータはバイト単位で整列されていることのみが保証されています。返されたポインターをより高いアライメントのデータ型にキャストすると、アライメントされていないアクセスが発生する可能性があります。これが許可されているかどうかはCPUアーキテクチャによります（x86/x64では常にOK、その他の現代的なアーキテクチャでもほとんどOKです）。</p><p>FFIポインターや参照は、基礎となるオブジェクトのGCアンカーとしてカウントされません。例えば、<code>ffi.new()</code>で割り当てられた配列は<code>buf:set(array, len)</code>によってアンカーされますが、<code>buf:set(array+offset, len)</code>によってはアンカーされません。オフセットの追加により新しいポインターが作成されますが、オフセットがゼロであっても同じです。この場合、バッファがその内容を使用している限り、元の配列への参照が存在することを確認する必要があります。</p><p>LuaJIT VMインスタンスはシングルスレッドですが（複数のVMを作成できます）、FFIデータ構造には同時にアクセスできます。バッファに対してFFI</p><p>cdataを読み書きする際には、同時アクセスや変更を避けるために注意してください。特に、<code>buf:set(cdata, len)</code>によって参照されるメモリは、バッファリーダーがそれを使用している間、変更されてはなりません。ファイルの共有された読み取り専用メモリマッピングはOKですが、ファイルが変更されない場合に限ります。</p>`,125)]))}const u=a(t,[["render",l]]);export{c as __pageData,u as default};
