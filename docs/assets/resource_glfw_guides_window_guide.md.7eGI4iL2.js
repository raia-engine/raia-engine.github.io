import{_ as s,c as a,a2 as t,o as n}from"./chunks/framework.CuCbyi2k.js";const o=JSON.parse('{"title":"GLFWウィンドウガイド（日本語訳）","description":"","frontmatter":{},"headers":[],"relativePath":"resource/glfw/guides/window_guide.md","filePath":"resource/glfw/guides/window_guide.md","lastUpdated":1729914702000}'),p={name:"resource/glfw/guides/window_guide.md"};function l(h,i,e,d,k,E){return n(),a("div",null,i[0]||(i[0]=[t(`<h1 id="glfwウィンドウガイド-日本語訳" tabindex="-1">GLFWウィンドウガイド（日本語訳） <a class="header-anchor" href="#glfwウィンドウガイド-日本語訳" aria-label="Permalink to &quot;GLFWウィンドウガイド（日本語訳）&quot;">​</a></h1><p>このガイドでは，GLFWのウィンドウに関する機能を紹介します．このカテゴリの特定の機能の詳細については、ウィンドウのリファレンスを参照してください。また、GLFWの他の領域のガイドもあります。</p><ul><li>APIの紹介</li><li>コンテキストガイド</li><li>Vulkanガイド</li><li>モニターガイド</li><li>入力ガイド</li></ul><nav class="table-of-contents"><ul><li><a href="#ウィンドウズ・オブジェクト">ウィンドウズ・オブジェクト</a><ul><li><a href="#ウィンドウの作成">ウィンドウの作成</a></li><li><a href="#ウィンドウの破棄">ウィンドウの破棄</a></li><li><a href="#ウィンドウ作成のヒント">ウィンドウ作成のヒント</a></li></ul></li><li><a href="#ウィンドウのイベント処理">ウィンドウのイベント処理</a></li><li><a href="#ウィンドウのプロパティとイベント">ウィンドウのプロパティとイベント</a><ul><li><a href="#ユーザーポインタ">ユーザーポインタ</a></li><li><a href="#ウィンドウのクローズ方法とクローズフラグ">ウィンドウのクローズ方法とクローズフラグ</a></li><li><a href="#ウィンドウのサイズ">ウィンドウのサイズ</a></li><li><a href="#フレームバッファサイズ">フレームバッファサイズ</a></li><li><a href="#ウィンドウの表示倍率">ウィンドウの表示倍率</a></li><li><a href="#ウィンドウサイズ制限">ウィンドウサイズ制限</a></li><li><a href="#ウィンドウの位置">ウィンドウの位置</a></li><li><a href="#ウィンドウのタイトル">ウィンドウのタイトル</a></li><li><a href="#ウィンドウのアイコン">ウィンドウのアイコン</a></li><li><a href="#ウィンドウズ・モニター">ウィンドウズ・モニター</a></li><li><a href="#ウィンドウのアイコン化">ウィンドウのアイコン化</a></li><li><a href="#ウィンドウの最大化">ウィンドウの最大化</a></li><li><a href="#ウィンドウの視認性">ウィンドウの視認性</a></li><li><a href="#ウィンドウの入力フォーカス">ウィンドウの入力フォーカス</a></li><li><a href="#ウィンドウズ・アテンション・リクエスト">ウィンドウズ・アテンション・リクエスト</a></li><li><a href="#ウィンドウの損傷とリフレッシュ">ウィンドウの損傷とリフレッシュ</a></li><li><a href="#ウィンドウの透明度">ウィンドウの透明度</a></li><li><a href="#ウィンドウの属性">ウィンドウの属性</a></li></ul></li><li><a href="#バッファースワッピング">バッファースワッピング</a></li></ul></nav><h2 id="ウィンドウズ・オブジェクト" tabindex="-1">ウィンドウズ・オブジェクト <a class="header-anchor" href="#ウィンドウズ・オブジェクト" aria-label="Permalink to &quot;ウィンドウズ・オブジェクト&quot;">​</a></h2><p>GLFWwindow オブジェクトは、ウィンドウとコンテキストの両方をカプセル化します。これらは glfwCreateWindow で生成され、glfwDestroyWindow または glfwTerminate で破棄されます（残っている場合）。ウィンドウとコンテキストは不可分にリンクされているので、オブジェクトポインタはコンテキストとウィンドウハンドルの両方として使用されます。</p><p>ウィンドウに関連する様々なコールバックに提供されるイベントストリームを見るには、イベント テスト プログラムを実行してください。</p><h3 id="ウィンドウの作成" tabindex="-1">ウィンドウの作成 <a class="header-anchor" href="#ウィンドウの作成" aria-label="Permalink to &quot;ウィンドウの作成&quot;">​</a></h3><p>ウィンドウとそのOpenGLまたはOpenGL ESコンテキストはglfwCreateWindowで作成され、作成されたウィンドウオブジェクトへのハンドルが返されます。例えば、これは640×480のウィンドウモードのウィンドウを作成します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwCreateWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">640</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">480</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My Title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>ウィンドウ作成に失敗した場合は NULL を返すので、戻り値の確認が必要である。</p><p>ウィンドウハンドルは、ウィンドウに関連するすべての関数に渡され、すべての入力イベントと一緒に提供されるので、イベントハンドラはどのウィンドウがそのイベントを受け取ったかを知ることができます。</p><h4 id="フルスクリーンウィンドウ" tabindex="-1">フルスクリーンウィンドウ <a class="header-anchor" href="#フルスクリーンウィンドウ" aria-label="Permalink to &quot;フルスクリーンウィンドウ&quot;">​</a></h4><p>フルスクリーンウィンドウを作成するには、そのウィンドウが使用するモニタを指定する必要があります。ほとんどの場合、ユーザーのプライマリモニタが良い選択です。モニタの取得について詳しくは、「モニタの取得」を参照してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwCreateWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">640</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">480</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My Title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetPrimaryMonitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>フルスクリーンウィンドウは、モニターの表示領域全体をカバーし、ボーダーや装飾はありません。</p><p>ウィンドウモードのウィンドウは、glfwSetWindowMonitorでモニタを設定することでフルスクリーンにすることができ、同じ関数で設定を解除することでウィンドウにすることができます。</p><p>GLFWvidmode構造体の各フィールドは、関数パラメータまたはウィンドウヒントに対応し、組み合わせてそのウィンドウの希望するビデオモードを形成する。希望するビデオモードに最も近いサポートされているビデオモードが、ウィンドウに入力フォーカスがある限り、選択されたモニターに設定される。ビデオモードの取得に関する詳細については、ビデオモードを参照してください。</p><table tabindex="0"><thead><tr><th>ビデオモードフィールド</th><th>対応</th></tr></thead><tbody><tr><td>GLFWvidmode.width</td><td>glfwCreateWindow の width パラメータ。</td></tr><tr><td>GLFWvidmode.height</td><td>glfwCreateWindowのheightパラメータ</td></tr><tr><td>GLFWvidmode.redBits</td><td>GLFW_RED_BITS ヒント</td></tr><tr><td>GLFWvidmode.greenBits</td><td>GLFW_GREEN_BITS ヒント</td></tr><tr><td>GLFWvidmode.blueBits</td><td>GLFW_BLUE_BITS ヒント</td></tr><tr><td>GLFWvidmode.refreshRate</td><td>GLFW_REFRESH_RATE ヒント</td></tr></tbody></table><p>いったんフルスクリーンウィンドウができたら、glfwSetWindowMonitor でその解像度、リフレッシュレート、モニタを変更することができます。もし、解像度だけを変更する必要があれば、glfwSetWindowSize を呼び出すこともできます。すべての場合において、新しいビデオモードは、glfwCreateWindowによって選択されたビデオモードと同じ方法で選択されます。ウィンドウがOpenGLまたはOpenGL ESのコンテキストを持っている場合、それは影響を受けません。</p><p>デフォルトでは、モニタの元のビデオモードが復元され、入力フォーカスを失うとウィンドウがアイコン化され、ユーザがデスクトップに戻ることができるようになります。この動作は GLFW_AUTO_ICONIFY window hint で無効にすることができる。例えば、同時に複数のモニターをフルスクリーンウィンドウで覆いたい場合などである。</p><p>モニターが切断された場合、そのモニター上でフルスクリーンになっているすべてのウィンドウはウィンドウモードに切り替わります。詳しくは、モニター設定の変更を参照してください。</p><h4 id="ウィンドウズ・フル・スクリーン-ウィンドウ" tabindex="-1">&quot;ウィンドウズ・フル・スクリーン &quot;ウィンドウ <a class="header-anchor" href="#ウィンドウズ・フル・スクリーン-ウィンドウ" aria-label="Permalink to &quot;&quot;ウィンドウズ・フル・スクリーン &quot;ウィンドウ&quot;">​</a></h4><p>希望するビデオモードに最も近いものが現在のビデオモードである場合、ビデオモードは変更されないので、ウィンドウの作成が速くなり、アプリケーションの切り替えも非常にスムーズになります。これは、ウィンドウ付きフルスクリーンまたはボーダーレスフルスクリーンウィンドウと呼ばれることもあり、フルスクリーンウィンドウとしてカウントされます。このようなウィンドウを作成するには、現在のビデオモードを要求します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLFWvidmode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetVideoMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(monitor);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_RED_BITS, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">redBits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_GREEN_BITS, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">greenBits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_BLUE_BITS, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">blueBits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_REFRESH_RATE, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">refreshRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwCreateWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My Title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, monitor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>これは、ウィンドウモードのウィンドウをフルスクリーンにした場合にも機能する。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLFWvidmode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetVideoMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(monitor);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowMonitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, monitor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">refreshRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>glfwGetVideoModeは、モニタの現在のビデオモードを返すので、そのモニタに既にフルスクリーンウィンドウがあり、それをウィンドウズフルスクリーンにしたい場合、デスクトップの解像度を事前に保存しておく必要があることに注意してください。</p><h3 id="ウィンドウの破棄" tabindex="-1">ウィンドウの破棄 <a class="header-anchor" href="#ウィンドウの破棄" aria-label="Permalink to &quot;ウィンドウの破棄&quot;">​</a></h3><p>ウィンドウが不要になったら、glfwDestroyWindowで破棄してください。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwDestroyWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>ウィンドウの破棄は常に成功します。実際の破壊の前に、すべてのコールバックは削除され、ウィンドウのために配信されるそれ以降のイベントはありません。glfwTerminate が呼び出されたときに残っているすべてのウィンドウも同様に破棄されます。</p><p>フルスクリーン ウィンドウが破壊されると、そのモニタの元のビデオ モードが復元されますが、ガンマ ランプはそのまま残されます。</p><h3 id="ウィンドウ作成のヒント" tabindex="-1">ウィンドウ作成のヒント <a class="header-anchor" href="#ウィンドウ作成のヒント" aria-label="Permalink to &quot;ウィンドウ作成のヒント&quot;">​</a></h3><p>ウィンドウやコンテキストを作成する前に設定できるヒントがいくつかあります。いくつかはウィンドウ自体に影響し、その他はフレームバッファやコンテキストに影響します。これらのヒントは、ライブラリが glfwInit で初期化されるたびにデフォルト値に設定されます。整数値のヒントはglfwWindowHintで、文字列値のヒントはglfwWindowHintStringで、それぞれ個別に設定することができます。glfwDefaultWindowHintsを使用すると、すべてを一度にデフォルトに戻すことができます。</p><p>いくつかのヒントはプラットフォーム固有です。これらは、どのプラットフォームでも常に有効ですが、特定のプラットフォームにのみ影響します。他のプラットフォームでは無視されます。これらのヒントを設定するために、プラットフォーム固有のヘッダや呼び出しは必要ありません。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>ウィンドウヒントは、指定された属性を持ちたいウィンドウとコンテキストを作成する前に設定する必要があります。これらは glfwCreateWindow への追加引数として機能します。</p></div><h4 id="ハードとソフトの制約" tabindex="-1">ハードとソフトの制約 <a class="header-anchor" href="#ハードとソフトの制約" aria-label="Permalink to &quot;ハードとソフトの制約&quot;">​</a></h4><p>いくつかのウィンドウヒントはハード制約です。これらは、ウィンドウとコンテキストの作成が成功するために、利用可能な機能に正確に一致する必要があります。ハード制約でないヒントは可能な限り一致させますが、結果のコンテキストとフレームバッファはこれらのヒントが要求したものと異なる場合があります。</p><p>以下のヒントは常にハード制約である。</p><ul><li>GLFW_STEREO</li><li>GLFW_DOUBLEBUFFER</li><li>GLFW_CLIENT_API</li><li>GLFW_CONTEXT_CREATION_API</li></ul><p>以下の追加ヒントは、OpenGLコンテキストの要求時にはハード制約となるが、OpenGL ESコンテキストの要求時には無視される。</p><ul><li>GLFW_OPENGL_FORWARD_COMPAT</li><li>GLFW_OPENGL_PROFILE</li></ul><h4 id="ウィンドウに関するヒント" tabindex="-1">ウィンドウに関するヒント <a class="header-anchor" href="#ウィンドウに関するヒント" aria-label="Permalink to &quot;ウィンドウに関するヒント&quot;">​</a></h4><p>GLFW_RESIZABLE ウィンドウモードのウィンドウをユーザがサイズ変更できるかどうかを指定します。ウィンドウは、glfwSetWindowSize 関数を使用してもサイズ変更可能です。指定可能な値は GLFW_TRUE と GLFW_FALSE である。このヒントは、フルスクリーンと非装飾ウィンドウでは無視されます。</p><p>GLFW_VISIBLE は、ウィンドウモードのウィンドウを初期状態で表示するかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。このヒントは、フルスクリーンウィンドウでは無視される。</p><p>GLFW_DECORATED は、ウィンドウモードのウィンドウがボーダーやクローズウィジェットなどのウィンドウ装飾を持つかどうかを指定します。装飾がないウィンドウは、ユーザーがサイズを変更することはできないが、 いくつかのプラットフォームではクローズイベントを発生させることができる。使用可能な値は GLFW_TRUE と GLFW_FALSE である。このヒントは、フルスクリーンウィンドウでは無視される。</p><p>GLFW_FOCUSED ウィンドウモードのウィンドウを作成する際に、入力フォーカスを与えるかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。このヒントは、フルスクリーンおよび初期状態で非表示になっているウィンドウでは無視される。</p><p>GLFW_AUTO_ICONIFY は、入力フォーカスが失われたときに、フルスクリーンウィンドウが自動的にアイコン化され、以前のビデオモードに戻るかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE です。このヒントは、ウィンドウモードのウィンドウでは無視されます。</p><p>GLFW_FLOATING は、ウィンドウモードウィンドウを他の通常ウィンドウの上に浮かせるかどうかを指定します（topmost または always-on-top とも呼ばれます）。これは主にデバッグのためのものであり、フルスクリーンウィンドウを実装するためには使用できない。使用可能な値は GLFW_TRUE と GLFW_FALSE である。このヒントは、フルスクリーンウィンドウでは無視される。</p><p>GLFW_MAXIMIZED は、ウィンドウモードのウィンドウを作成するときに最大化するかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。このヒントは、フルスクリーンウィンドウでは無視される。</p><p>GLFW_CENTER_CURSOR は、新しく作成されたフルスクリーンウィンドウの上でカーソルを中央に配置するかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。このヒントは、ウィンドウモードのウィンドウでは無視されます。</p><p>GLFW_TRANSPARENT_FRAMEBUFFER は、ウィンドウフレームバッファを透明にするかどうかを指定します。有効でシステムがサポートしている場合、ウィンドウフレームバッファのアルファチャンネルは、フレームバッファと背景を結合するために使用されます。これはウィンドウの装飾には影響しない。指定可能な値は GLFW_TRUE および GLFW_FALSE である。</p><p>GLFW_FOCUS_ON_SHOW glfwShowWindowが呼ばれたとき、ウィンドウに入力フォーカスを与えるかどうかを指定します。指定可能な値は GLFW_TRUE および GLFW_FALSE です。</p><p>GLFW_SCALE_TO_MONITOR ウィンドウの内容領域が、それが配置される任意のモニタのモニタ内容尺度に基づいてサイズ変更されるべきかどうかを指定します。これは、ウィンドウが作成されたときの初期配置を含む。指定可能な値は GLFW_TRUE と GLFW_FALSE である。</p><p>このヒントは、Windows や X11 など、画面座標とピクセルが常に 1:1 で対応するプラットフォームでのみ効果を発揮します。macOS のようなプラットフォームでは、フレームバッファの解像度はウィンドウサイズとは無関係に変更されます。</p><h4 id="フレームバッファ関連ヒント" tabindex="-1">フレームバッファ関連ヒント <a class="header-anchor" href="#フレームバッファ関連ヒント" aria-label="Permalink to &quot;フレームバッファ関連ヒント&quot;">​</a></h4><p>GLFW_RED_BITS, GLFW_GREEN_BITS, GLFW_BLUE_BITS, GLFW_ALPHA_BITS, GLFW_DEPTH_BITS and GLFW_STENCIL_BITS デフォルトフレームバッファの様々な構成要素の希望するビット深度を指定する。GLFW_DONT_CARE の値は、アプリケーションに優先権がないことを意味する。</p><p>GLFW_ACCUM_RED_BITS, GLFW_ACCUM_GREEN_BITS, GLFW_ACCUM_BLUE_BITS and GLFW_ACCUM_ALPHA_BITS 蓄積バッファの様々な構成要素の希望するビット深度を指定する。GLFW_DONT_CAREの値は、アプリケーションに優先権がないことを意味する。</p><p>アキュムレーションバッファはOpenGLのレガシー機能であり、新しいコードで使用するべきではありません。</p><p>GLFW_AUX_BUFFERS は、希望する補助バッファの数を指定する。GLFW_DONT_CAREの値は、アプリケーションに優先権がないことを意味する。</p><p>補助バッファはOpenGLのレガシー機能であり、新しいコードで使用するべきではありません。</p><p>GLFW_STEREO は、OpenGLステレオスコピックレンダリングを使用するかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。これはハード制約である。</p><p>GLFW_SAMPLES は、マルチサンプリングに使用するサンプル数を指定します。0はマルチサンプリングを無効とする。GLFW_DONT_CAREの値は、アプリケーションに優先権がないことを意味する。</p><p>GLFW_SRGB_CAPABLE は、フレームバッファを sRGB 対応にするかどうかを指定します。指定可能な値は GLFW_TRUE および GLFW_FALSE である。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>OpenGL: GL_FRAMEBUFFER_SRGB enableは、システムでサポートされている場合、sRGBレンダリングを制御する。デフォルトでは、sRGBレンダリングは無効である。</p><p>OpenGL ES: システムでサポートされている場合、コンテキストは常にsRGBレンダリングが有効になっています。</p></div><p>GLFW_DOUBLEBUFFER は、フレームバッファをダブルバッファにするかどうかを指定します。ほぼ常にダブルバッファリングを使用したい。これはハード的な制約である。指定可能な値は GLFW_TRUE および GLFW_FALSE である。</p><h4 id="モニター関連ヒント" tabindex="-1">モニター関連ヒント <a class="header-anchor" href="#モニター関連ヒント" aria-label="Permalink to &quot;モニター関連ヒント&quot;">​</a></h4><p>GLFW_REFRESH_RATE フルスクリーンウィンドウに必要なリフレッシュレートを指定する。GLFW_DONT_CAREの値は、利用可能な最も高いリフレッシュレートが使用されることを意味する。このヒントは、ウィンドウモードのウィンドウでは無視される。</p><h4 id="コンテキストに関するヒント" tabindex="-1">コンテキストに関するヒント <a class="header-anchor" href="#コンテキストに関するヒント" aria-label="Permalink to &quot;コンテキストに関するヒント&quot;">​</a></h4><p>GLFW_CLIENT_API は、どのクライアント API に対してコンテキストを作成するかを指定します。指定できる値は GLFW_OPENGL_API、GLFW_OPENGL_ES_API および GLFW_NO_API です。これはハード制約である。</p><p>GLFW_CONTEXT_CREATION_API は、コンテキストの作成に使用する API を指定します。指定可能な値は GLFW_NATIVE_CONTEXT_API, GLFW_EGL_CONTEXT_API, GLFW_OSMESA_CONTEXT_API です。これはハードな制約です。クライアントAPIが要求されない場合、このヒントは無視される。</p><p>現在のコンテキストを作成するために使用された API を知っていると仮定している拡張ローダライブラリは、 このヒントを変更すると失敗する可能性があります。これは、glfwGetProcAddress を使って関数をロードさせることで解決できます。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ul><li>Wayland: EGL APIはネイティブのコンテキスト作成APIであるため、このヒントは何の効果もない。</li><li>X11: 一部のLinuxシステムでは、1つのプロセスでネイティブAPIとEGL APIの両方を使用してコンテキストを作成すると、アプリケーションのセグメンテーションが発生します。Linuxでは、今のところ、どちらかのAPIを使うようにしてください。</li><li>OSMesa: その名前が示すように、OSMesaで作成されたOpenGLコンテキストは、そのバッファがスワップされたときにウィンドウの内容を更新しません。フレームバッファの内容を取得するには、OpenGL関数またはOSMesaのネイティブアクセス関数glfwGetOSMesaColorBufferとglfwGetOSMesaDepthBufferを使用します。</li></ul></div><p>GLFW_CONTEXT_VERSION_MAJOR and GLFW_CONTEXT_VERSION_MINOR は、作成されるコンテキストが互換性を持たなければならないクライアントAPIのバージョンを指定します。これらのヒントの正確な動作は、要求されたクライアント API に依存します。</p><p>サポートされている最高バージョンのコンテキストをドライバに要求する方法はありませんが、GLFWは、これらのヒントのデフォルトであるバージョン1.0のコンテキストを要求したときに、これを提供しようと試みます。</p><p>これらのヒントを GLFW_VERSION_MAJOR および GLFW_VERSION_MINOR と混同しないでください。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ul><li>OpenGL: これらのヒントはハード的な制約ではありませんが、作成されたコンテキストのOpenGLバージョンが要求されたものよりも小さい場合、作成は失敗します。したがって、レガシーコードにはバージョン 1.0 のデフォルトを使用してもまったく問題ありませんし、バージョン 3.0 以上の下位互換性のあるコンテキストが利用可能な場合は、それを使用することもできます。</li><li>OpenGL ES: これらのヒントはハード的な制約ではありませんが、作成されたコンテキストのOpenGL ESバージョンが要求されたものよりも低い場合、作成は失敗します。さらに、2.0以降が要求された場合、OpenGL ES 1.xを返すことはできませんし、その逆もまた然りです。これは、OpenGL ES 3.xは2.0と後方互換性がありますが、OpenGL ES 2.0は1.xと後方互換性がないためです。</li><li>macOS: OS は、OpenGL バージョン 3.2 以降の前方互換性のあるコアプロファイルコンテキストのみをサポートします。バージョン 3.2 以降の OpenGL コンテキストを作成する前に、GLFW_OPENGL_FORWARD_COMPAT と GLFW_OPENGL_PROFILE ヒントをそれに応じて設定する必要があります。OpenGL 3.0 と 3.1 のコンテキストは、macOS では全くサポートされていません。</li></ul></div><p>GLFW_OPENGL_FORWARD_COMPAT は、OpenGL コンテキストが前方互換性を持つかどうかを指定します。これは、要求されたOpenGLのバージョンが3.0以上の場合にのみ使用する必要があります。OpenGL ESが要求された場合、このヒントは無視されます。</p><p>前方互換性については、OpenGLリファレンスマニュアルで詳しく説明されています。</p><p>GLFW_OPENGL_DEBUG_CONTEXT は、コンテキストをデバッグモードで作成するかどうかを指定します。 これにより、エラーや診断の報告機能が追加されることがあります。使用可能な値は GLFW_TRUE および GLFW_FALSE です。</p><p>OpenGLおよびOpenGL ESのデバッグコンテキストは、GL_KHR_debug拡張によって詳細に記述されています。</p><p>GLFW_OPENGL_PROFILE どのOpenGLプロファイルのコンテキストを作成するかを指定します。可能な値は GLFW_OPENGL_CORE_PROFILE または GLFW_OPENGL_COMPAT_PROFILE のいずれか、あるいは特定のプロファイルを要求しない場合は GLFW_OPENGL_ANY_PROFILE となる。3.2以下のOpenGLバージョンを要求する場合、GLFW_OPENGL_ANY_PROFILEを使用しなければならない。OpenGL ESが要求された場合、このヒントは無視される。</p><p>OpenGLプロファイルについては、OpenGLリファレンスマニュアルで詳しく説明されています。</p><p>GLFW_CONTEXT_ROBUSTNESS は、コンテキストが使用する堅牢性戦略を指定する。GLFW_NO_RESET_NOTIFICATION あるいは GLFW_LOSE_CONTEXT_ON_RESET のいずれか、 あるいは GLFW_NO_ROBUSTNESS で堅牢性の戦略を要求しないものとすることが可能である。</p><p>GLFW_CONTEXT_RELEASE_BEHAVIOR は、コンテキストが使用するリリース動作を指定します。指定できる値は GLFW_ANY_RELEASE_BEHAVIOR、 GLFW_RELEASE_BEHAVIOR_FLUSH あるいは GLFW_RELEASE_BEHAVIOR_NONE のいずれかである。動作が GLFW_ANY_RELEASE_BEHAVIOR の場合、コンテキスト作成 API のデフォルトの動作が使用される。GLFW_RELEASE_BEHAVIOR_FLUSH を指定すると、現在のコンテキストから解放されるたびにパイプラインがフラッシュされます。GLFW_RELEASE_BEHAVIOR_NONE を指定すると、パイプラインは解放時にフラッシュされません。</p><p>コンテキスト解放の動作は，GL_KHR_context_flush_control 拡張で詳細に記述されています．</p><p>GLFW_CONTEXT_NO_ERROR は、コンテキストによってエラーを発生させるかどうかを指定する。指定可能な値は GLFW_TRUE および GLFW_FALSE である。有効にすると、エラーが発生するような状況では、代わりに未定義の動作が発生する。</p><p>OpenGLおよびOpenGL ESのエラー無しモードは、GL_KHR_no_error拡張で詳細に記述されています。</p><h4 id="macos固有のウィンドウのヒント" tabindex="-1">macOS固有のウィンドウのヒント <a class="header-anchor" href="#macos固有のウィンドウのヒント" aria-label="Permalink to &quot;macOS固有のウィンドウのヒント&quot;">​</a></h4><p>GLFW_COCOA_RETINA_FRAMEBUFFER は、Retinaディスプレイ上でフル解像度フレームバッファを使用するかどうかを指定します。使用可能な値は GLFW_TRUE および GLFW_FALSE です。これは他のプラットフォームでは無視される。</p><p>GLFW_COCOA_FRAME_NAME は、ウィンドウフレームの自動保存に使用するUTF-8エンコード名を指定し、空の場合はウィンドウのフレームの自動保存を無効にします。これは、他のプラットフォームでは無視されます。これは、glfwWindowHintStringで設定されます。</p><p>GLFW_COCOA_GRAPHICS_SWITCHING は、Automatic Graphics Switching、つまり、システムが OpenGL コンテキスト用に統合 GPU を選択し、必要に応じて GPU 間を移動することを許可するか、または、常にディスクリート GPU で実行することを強制するかを指定します。これは、統合GPUとディスクリートGPUの両方を持つシステムのみに影響します。使用可能な値は GLFW_TRUE および GLFW_FALSE です。他のプラットフォームでは、これは無視されます。</p><p>シンプルなプログラムやツールでは、この機能を有効にして電力を節約することができますが、ゲームや高度なレンダリングを行うその他のアプリケーションでは、無効にしておくとよいでしょう。</p><p>自動グラフィックス切り替えに参加したいバンドルアプリケーションは、そのInfo.plistでNSSupportsAutomaticGraphicsSwitchingキーをtrueに設定して、これを宣言する必要もあります。</p><h4 id="x11-スペシャルウィンドウヒント" tabindex="-1">X11 スペシャルウィンドウヒント <a class="header-anchor" href="#x11-スペシャルウィンドウヒント" aria-label="Permalink to &quot;X11 スペシャルウィンドウヒント&quot;">​</a></h4><p>GLFW_X11_CLASS_NAME and GLFW_X11_INSTANCE_NAME は、ICCCM WM_CLASSウィンドウプロパティのクラス部とインスタンス部をASCIIエンコードしたものを指定する。これらは、glfwWindowHintStringで設定される。</p><h4 id="サポート値とデフォルト値" tabindex="-1">サポート値とデフォルト値 <a class="header-anchor" href="#サポート値とデフォルト値" aria-label="Permalink to &quot;サポート値とデフォルト値&quot;">​</a></h4><table tabindex="0"><thead><tr><th>ウィンドウのヒント</th><th>デフォルト値</th><th>サポートされる値</th></tr></thead><tbody><tr><td>GLFW_RESIZABLE</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_VISIBLE</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_DECORATED</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_FOCUSED</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_AUTO_ICONIFY</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_FLOATING</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_MAXIMIZED</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_CENTER_CURSOR</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_TRANSPARENT_FRAMEBUFFER</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_FOCUS_ON_SHOW</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_SCALE_TO_MONITOR</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_RED_BITS</td><td>8</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_GREEN_BITS</td><td>8</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_BLUE_BITS</td><td>8</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_ALPHA_BITS</td><td>8</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_DEPTH_BITS</td><td>24</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_STENCIL_BITS</td><td>8</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_ACCUM_RED_BITS</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_ACCUM_GREEN_BITS</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_ACCUM_BLUE_BITS</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_ACCUM_ALPHA_BITS</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_AUX_BUFFERS</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_SAMPLES</td><td>0</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_REFRESH_RATE</td><td>GLFW_DONT_CARE</td><td>0 to INT_MAX or GLFW_DONT_CARE</td></tr><tr><td>GLFW_STEREO</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_SRGB_CAPABLE</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_DOUBLEBUFFER</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_CLIENT_API</td><td>GLFW_OPENGL_API</td><td>GLFW_OPENGL_API, GLFW_OPENGL_ES_API or GLFW_NO_API</td></tr><tr><td>GLFW_CONTEXT_CREATION_API</td><td>GLFW_NATIVE_CONTEXT_API</td><td>GLFW_NATIVE_CONTEXT_API, GLFW_EGL_CONTEXT_API or GLFW_OSMESA_CONTEXT_API</td></tr><tr><td>GLFW_CONTEXT_VERSION_MAJOR</td><td>1</td><td>Any valid major version number of the chosen client API</td></tr><tr><td>GLFW_CONTEXT_VERSION_MINOR</td><td>0</td><td>Any valid minor version number of the chosen client API</td></tr><tr><td>GLFW_CONTEXT_ROBUSTNESS</td><td>GLFW_NO_ROBUSTNESS</td><td>GLFW_NO_ROBUSTNESS, GLFW_NO_RESET_NOTIFICATION or GLFW_LOSE_CONTEXT_ON_RESET</td></tr><tr><td>GLFW_CONTEXT_RELEASE_BEHAVIOR</td><td>GLFW_ANY_RELEASE_BEHAVIOR</td><td>GLFW_ANY_RELEASE_BEHAVIOR, GLFW_RELEASE_BEHAVIOR_FLUSH or GLFW_RELEASE_BEHAVIOR_NONE</td></tr><tr><td>GLFW_OPENGL_FORWARD_COMPAT</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_OPENGL_DEBUG_CONTEXT</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_OPENGL_PROFILE</td><td>GLFW_OPENGL_ANY_PROFILE</td><td>GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_COMPAT_PROFILE or GLFW_OPENGL_CORE_PROFILE</td></tr><tr><td>GLFW_COCOA_RETINA_FRAMEBUFFER</td><td>GLFW_TRUE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_COCOA_FRAME_NAME</td><td>&quot;&quot;</td><td>A UTF-8 encoded frame autosave name</td></tr><tr><td>GLFW_COCOA_GRAPHICS_SWITCHING</td><td>GLFW_FALSE</td><td>GLFW_TRUE or GLFW_FALSE</td></tr><tr><td>GLFW_X11_CLASS_NAME</td><td>&quot;&quot;</td><td>An ASCII encoded WM_CLASS class name</td></tr><tr><td>GLFW_X11_INSTANCE_NAME</td><td>&quot;&quot;</td><td>An ASCII encoded WM_CLASS instance name</td></tr></tbody></table><h2 id="ウィンドウのイベント処理" tabindex="-1">ウィンドウのイベント処理 <a class="header-anchor" href="#ウィンドウのイベント処理" aria-label="Permalink to &quot;ウィンドウのイベント処理&quot;">​</a></h2><p>イベント処理を参照してください。</p><h2 id="ウィンドウのプロパティとイベント" tabindex="-1">ウィンドウのプロパティとイベント <a class="header-anchor" href="#ウィンドウのプロパティとイベント" aria-label="Permalink to &quot;ウィンドウのプロパティとイベント&quot;">​</a></h2><h3 id="ユーザーポインタ" tabindex="-1">ユーザーポインタ <a class="header-anchor" href="#ユーザーポインタ" aria-label="Permalink to &quot;ユーザーポインタ&quot;">​</a></h3><p>各ウィンドウは、glfwSetWindowUserPointer で設定し、glfwGetWindowUserPointer で問い合わせることができるユーザポインタをもっています。これは必要な目的に使用することができ，ウィンドウの寿命が尽きるまで GLFWによって変更されることはありません．</p><p>ポインタの初期値はNULLです．</p><h3 id="ウィンドウのクローズ方法とクローズフラグ" tabindex="-1">ウィンドウのクローズ方法とクローズフラグ <a class="header-anchor" href="#ウィンドウのクローズ方法とクローズフラグ" aria-label="Permalink to &quot;ウィンドウのクローズ方法とクローズフラグ&quot;">​</a></h3><p>ユーザがウィンドウを閉じようとしたとき、例えば、閉じるウィジェットをクリックするか、Alt+F4のようなキーコードを使用すると、ウィンドウの閉じるフラグが設定されます。しかし、ウィンドウは実際には破棄されず、この状態の変化を監視しない限り、それ以上何も起こりません。</p><p>クローズフラグの現在の状態はglfwWindowShouldCloseによって返され、glfwSetWindowShouldCloseで直接設定または解除できます。よくあるパターンは、メインループの条件としてクローズフラグを使用することです。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowShouldClose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    glfwSwapBuffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    glfwPollEvents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>ユーザーがウィンドウを閉じようとしたときに通知を受けたい場合は、closeコールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowCloseCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_close_callback);</span></span></code></pre></div><p>コールバック関数は、クローズフラグが設定された後に直接呼び出されます。例えば、close リクエストをフィルタリングし、特定の条件が満たされない限り close フラグを再びクリアするために使用することができる。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_close_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time_to_close)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        glfwSetWindowShouldClose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_FALSE);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ウィンドウのサイズ" tabindex="-1">ウィンドウのサイズ <a class="header-anchor" href="#ウィンドウのサイズ" aria-label="Permalink to &quot;ウィンドウのサイズ&quot;">​</a></h3><p>ウィンドウのサイズは glfwSetWindowSize で変更することができます。ウィンドウモードのウィンドウの場合、これはウィンドウのコンテンツ領域またはコンテンツ領域のサイズをスクリーン座標で設定します。ウィンドウシステムは、ウィンドウサイズに制限を課すことがあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">640</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">480</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>フルスクリーンウィンドウの場合、指定されたサイズはウィンドウの希望するビデオモードの新しい解像度となる。新しい希望するビデオモードに最も近いビデオモードが直ちに設定される。ウィンドウは、設定されたビデオモードの解像度に合うようにサイズが変更される。</p><p>ユーザー、システム、または独自のコードによってウィンドウのサイズが変更されたときに通知を受けたい場合は、サイズ コールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowSizeCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_size_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウのサイズ変更時に、ウィンドウのコンテンツ領域の新しいサイズをスクリーン座標で受け取る。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_size_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、ウィンドウの現在のサイズを直接取得するためのglfwGetWindowSizeもあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width, height;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>glViewportや他のピクセルベースのOpenGL呼び出しにウィンドウサイズを渡さないでください。ウィンドウサイズはスクリーン座標であり、ピクセルではありません。ピクセルベースの呼び出しには、ピクセル単位であるフレームバッファサイズを使用します。</p></div><p>上記の関数はコンテントエリアのサイズで動作しますが、装飾されたウィンドウは通常この矩形の周りにタイトルバーとウィンドウフレームを持ちます。これらの領域は glfwGetWindowFrameSize で取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left, top, right, bottom;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowFrameSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">bottom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>返される値は、スクリーン座標で、コンテンツ領域の端からフルウィンドウの対応する端までの距離である。座標ではなく距離であるため、常に0または正の値である。</p><h3 id="フレームバッファサイズ" tabindex="-1">フレームバッファサイズ <a class="header-anchor" href="#フレームバッファサイズ" aria-label="Permalink to &quot;フレームバッファサイズ&quot;">​</a></h3><p>ウィンドウの大きさはスクリーン座標で測定されますが、OpenGLはピクセルで動作します。例えば、glViewportに渡すサイズはピクセルであるべきです。あるマシンではスクリーン座標とピクセルが同じですが、他のマシンでは同じではありません。ウィンドウのフレームバッファのサイズをピクセル単位で取得するための関数がもう1つあります。</p><p>もし、ウィンドウのフレームバッファのサイズがユーザーやシステムによって変更されたときに通知を受けたい場合は、サイズコールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetFramebufferSizeCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, framebuffer_size_callback);</span></span></code></pre></div><p>コールバック関数は、フレームバッファのサイズ変更時に新しいサイズを受け取り、例えばOpenGLのビューポートを更新するために使用することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> framebuffer_size_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    glViewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、ウィンドウのフレームバッファの現在のサイズを直接取得するためのglfwGetFramebufferSizeもあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width, height;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetFramebufferSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glViewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height);</span></span></code></pre></div><p>フレームバッファのサイズは、ウィンドウのサイズとは無関係に変化することがあります。例えば、ウィンドウを通常のモニタと高DPIのモニタの間でドラッグした場合などです。</p><h3 id="ウィンドウの表示倍率" tabindex="-1">ウィンドウの表示倍率 <a class="header-anchor" href="#ウィンドウの表示倍率" aria-label="Permalink to &quot;ウィンドウの表示倍率&quot;">​</a></h3><p>ウィンドウのコンテンツスケールはglfwGetWindowContentScaleで取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xscale, yscale;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowContentScale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xscale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">yscale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>コンテンツスケールは、現在のDPIとプラットフォームのデフォルトDPIとの比率です。これは、テキストやUI要素で特に重要です。この比率でスケーリングされたUIのピクセル寸法があなたのマシンで適切に見えるなら、他のマシンではDPIやスケーリング設定に関係なく、妥当な大きさで表示されるはずです。これは、システムのDPIとスケーリング設定がある程度正しいことが前提になります。</p><p>各モニターが独自のコンテンツスケールを持つことができるシステムでは、ウィンドウのコンテンツスケールは、システムがウィンドウをどのモニター上にあると見なすかに依存します。</p><p>システム設定の変更または異なるスケールのモニタに移動したために、ウィンドウのコンテンツスケールが変更されたときに通知を受けたい場合、コンテンツスケールコールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowContentScaleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_content_scale_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウの新しいコンテンツスケールを受け取ります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_content_scale_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xscale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> yscale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set_interface_scale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xscale, yscale);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>ピクセルとスクリーン座標が常に1:1に対応するプラットフォームでは、ウィンドウは異なるコンテンツスケールのモニターに移動したときに同じサイズに見えるようにリサイズされる必要がある。ウィンドウの作成時とコンテンツスケールの変更時の両方で自動的にこれを行うには、GLFW_SCALE_TO_MONITOR ウィンドウヒントを設定する。</p><h3 id="ウィンドウサイズ制限" tabindex="-1">ウィンドウサイズ制限 <a class="header-anchor" href="#ウィンドウサイズ制限" aria-label="Permalink to &quot;ウィンドウサイズ制限&quot;">​</a></h3><p>ウィンドウモードのウィンドウの最小および最大サイズは、glfwSetWindowSizeLimitsによって強制することができます。アスペクト比が設定されていない限り、ユーザは指定された制限内の任意のサイズとアスペクト比にウィンドウをリサイズすることができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowSizeLimits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>最小サイズのみ、あるいは最大サイズのみを指定する場合は、もう一方のペアをGLFW_DONT_CAREに設定する。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowSizeLimits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">640</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">480</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, GLFW_DONT_CARE, GLFW_DONT_CARE);</span></span></code></pre></div><p>ウィンドウのサイズ制限を無効にするには、すべてをGLFW_DONT_CAREに設定します。</p><p>ウィンドウモード・ウィンドウのコンテンツ領域のアスペクト比は、 glfwSetWindowAspectRatioで強制することができる。サイズ制限が設定されていない限り、ユーザーはウィンドウのサイズを自由に変更することができますが、サイズはアスペクト比を維持するために制限されます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowAspectRatio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>アスペクト比は、幅と高さにそれぞれ対応する分子と分母で指定します。ウィンドウのアスペクト比を維持したい場合は、現在のサイズを比率として使用します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width, height;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowAspectRatio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, width, height);</span></span></code></pre></div><p>ウィンドウのアスペクト比制限を無効にするには、両方の条件をGLFW_DONT_CAREに設定する。</p><p>ウィンドウのサイズ制限とアスペクト比の両方を設定することができるが、それらが衝突した場合、結果は不定である。</p><h3 id="ウィンドウの位置" tabindex="-1">ウィンドウの位置 <a class="header-anchor" href="#ウィンドウの位置" aria-label="Permalink to &quot;ウィンドウの位置&quot;">​</a></h3><p>ウィンドウモードのウィンドウの位置は、glfwSetWindowPosで変更することができます。これは、ウィンドウの内容領域の左上隅が、指定されたスクリーン座標になるようにウィンドウを移動します。ウィンドウシステムは、ウィンドウの配置に制限を加えるかもしれません。</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowPos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>ユーザー、システム、または独自のコードによってウィンドウが移動されたときに通知を受けたい場合は、位置コールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowPosCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_pos_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウを移動したときのコンテンツ領域の左上隅の新しい位置をスクリーン座標で受け取る。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_pos_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> xpos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ypos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、ウィンドウのコンテンツ領域の現在位置を直接取得するためのglfwGetWindowPosもあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xpos, ypos;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowPos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xpos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ypos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="ウィンドウのタイトル" tabindex="-1">ウィンドウのタイトル <a class="header-anchor" href="#ウィンドウのタイトル" aria-label="Permalink to &quot;ウィンドウのタイトル&quot;">​</a></h3><p>すべてのGLFWウィンドウはタイトルを持ちますが、装飾されていないウィンドウやフルスクリーンウィンドウはタイトルを表示しないか、タスクバーや同様のインターフェイスにのみ表示することができます。glfwSetWindowTitleでUTF-8エンコードされたウィンドウのタイトルを設定することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My Window&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>指定された文字列は、関数が戻る前にコピーされるので、それを保持する必要はない。</p><p>ソースファイルがUTF-8でエンコードされている限り、ソース内で任意のUnicode文字を直接使用することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ラストエグザイル&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>C++11、C11をお使いの場合は、UTF-8文字列リテラルを使用することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, u8</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This is always a UTF-8 string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="ウィンドウのアイコン" tabindex="-1">ウィンドウのアイコン <a class="header-anchor" href="#ウィンドウのアイコン" aria-label="Permalink to &quot;ウィンドウのアイコン&quot;">​</a></h3><p>一部のプラットフォームでは、装飾されたウィンドウにはアイコンが表示されます。glfwSetWindowIconで候補画像のリストを指定することで、このアイコンを設定することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWimage </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">images</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">images</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> load_icon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my_icon.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">images</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> load_icon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my_icon_small.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowIcon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, images);</span></span></code></pre></div><p>画像データは32ビット，リトルエンディアン，非前乗算のRGBA，すなわち各チャンネル8ビットで，赤チャンネルが先にある。画素は左上から順番に正規の列として配置される。</p><p>デフォルトのウィンドウアイコンに戻すには、空の画像配列を渡します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowIcon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="ウィンドウズ・モニター" tabindex="-1">ウィンドウズ・モニター <a class="header-anchor" href="#ウィンドウズ・モニター" aria-label="Permalink to &quot;ウィンドウズ・モニター&quot;">​</a></h3><p>フルスクリーンウィンドウは、特定のモニタに関連付けられます。glfwGetWindowMonitorでこのモニタのハンドルを取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GLFWmonitor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> monitor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowMonitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>このモニターハンドルは、glfwGetMonitors によって返されるもののうちの 1 つです。</p><p>ウィンドウモードのウィンドウの場合、この関数はNULLを返します。これは、フルスクリーンウィンドウとウィンドウドモードウィンドウを区別する方法です。</p><p>glfwSetWindowMonitorを使用すると、モニタ間やフルスクリーンとウィンドウモードの間でウィンドウを移動することができます。同じモニタまたは別のモニタでウィンドウをフルスクリーンにする場合、希望するモニタ、解像度、リフレッシュレートを指定します。位置の引数は無視されます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLFWvidmode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetVideoMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(monitor);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowMonitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, monitor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">refreshRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>ウィンドウ化する場合は、任意の位置と大きさを指定する。引数のリフレッシュレートは無視される。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowMonitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, xpos, ypos, width, height, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>これにより、装飾、フローティング、サイズ変更、サイズやアスペクト比の制限など、以前のウィンドウの設定が復元されます。元々ウィンドウであったものを元のサイズと位置に戻すには、フルスクリーンにする前にこれらを保存し、上記のように渡します。</p><h3 id="ウィンドウのアイコン化" tabindex="-1">ウィンドウのアイコン化 <a class="header-anchor" href="#ウィンドウのアイコン化" aria-label="Permalink to &quot;ウィンドウのアイコン化&quot;">​</a></h3><p>glfwIconifyWindowでウィンドウをアイコン化(最小化)することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwIconifyWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>フルスクリーンウィンドウがアイコン化されると、ユーザーまたはアプリケーションがウィンドウを復元するまで、そのモニタの元のビデオモードが復元されます。</p><p>アイコン化されたウィンドウは、glfwRestoreWindowで復元することができます。この関数は、ウィンドウを最大化した状態から復元することもできます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwRestoreWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>フルスクリーンウィンドウが復元されると、そのモニターにも希望のビデオモードが復元されます。</p><p>ユーザー、システム、または独自のコードによってウィンドウがアイコン化または復元されたときに通知を受けたい場合は、iconifyコールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowIconifyCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_iconify_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウのアイコン化状態の変化を受け取ります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_iconify_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> iconified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (iconified)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window was iconified</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window was restored</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、glfwGetWindowAttribで現在のアイコン化状態を取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iconified </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_ICONIFIED);</span></span></code></pre></div><h3 id="ウィンドウの最大化" tabindex="-1">ウィンドウの最大化 <a class="header-anchor" href="#ウィンドウの最大化" aria-label="Permalink to &quot;ウィンドウの最大化&quot;">​</a></h3><p>glfwMaximizeWindowにより、ウィンドウを最大化（ズーム）することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwMaximizeWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>フルスクリーンウィンドウは最大化できないので、この関数にフルスクリーンウィンドウを渡しても何も起こりません。</p><p>最大化されたウィンドウは、glfwRestoreWindowで復元することができます。この関数はアイコン化されたウィンドウも復元します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwRestoreWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>ユーザー、システム、または独自のコードによってウィンドウが最大化または復元されたときに通知を受けたい場合は、最大化コールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowMaximizeCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_maximize_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウの最大化状態の変化を受け取ります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_maximize_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> maximized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (maximized)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window was maximized</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window was restored</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、glfwGetWindowAttribで現在の最大化状態を取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maximized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_MAXIMIZED);</span></span></code></pre></div><p>デフォルトでは、新しく作成されたウィンドウは最大化されない。ウィンドウを作成する前にウィンドウヒント GLFW_MAXIMIZED を設定することにより、この動作を変更することができる。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_MAXIMIZED, GLFW_TRUE);</span></span></code></pre></div><h3 id="ウィンドウの視認性" tabindex="-1">ウィンドウの視認性 <a class="header-anchor" href="#ウィンドウの視認性" aria-label="Permalink to &quot;ウィンドウの視認性&quot;">​</a></h3><p>ウィンドウモードのウィンドウはglfwHideWindowで隠すことができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwHideWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>これにより、ウィンドウはタスクバー、ドック、ウィンドウリストから削除されるなど、ユーザーから完全に見えなくなります。フルスクリーンウィンドウは隠すことができず、フルスクリーンウィンドウでglfwHideWindowを呼び出しても何も起こりません。</p><p>隠されたウィンドウは、glfwShowWindowで表示することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwShowWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>デフォルトでは、この関数は入力フォーカスもそのウィンドウに設定する。GLFW_FOCUS_ON_SHOW ウィンドウヒントを設定して、新しく作成されたすべてのウィンドウのこの動作を変更するか、 glfwSetWindowAttrib を使用して既存のウィンドウの動作を変更します。</p><p>また、glfwGetWindowAttribで現在の可視性状態を取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> visible </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_VISIBLE);</span></span></code></pre></div><p>デフォルトでは、新しく作成されたウィンドウは表示される。ウィンドウを作成する前にウィンドウヒント GLFW_VISIBLE を設定することにより、この動作を変更することができる。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_VISIBLE, GLFW_FALSE);</span></span></code></pre></div><p>非表示に作成されたウィンドウは、表示されるまでユーザーからは完全に見えません。これは、ウィンドウを表示する前に、例えば特定の場所に移動するなど、ウィンドウをさらに設定する必要がある場合に便利です。</p><h3 id="ウィンドウの入力フォーカス" tabindex="-1">ウィンドウの入力フォーカス <a class="header-anchor" href="#ウィンドウの入力フォーカス" aria-label="Permalink to &quot;ウィンドウの入力フォーカス&quot;">​</a></h3><p>glfwFocusWindowにより、ウィンドウに入力フォーカスを与え、前面に表示させることができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwFocusWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>ウィンドウが強制的に一番上に表示されると、ユーザーにとって非常に邪魔になることを心に留めておいてください。ユーザーの注意を喚起するための、より邪魔にならない方法については、注意喚起要求を参照してください。</p><p>ユーザー、システム、または独自のコードによってウィンドウが入力フォーカスを獲得または喪失したときに通知を受けたい場合は、フォーカス コールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowFocusCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, window_focus_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウの入力フォーカスの状態の変化を受け取る。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_focus_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> focused</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (focused)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window gained input focus</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The window lost input focus</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、glfwGetWindowAttribで現在の入力フォーカスの状態を取得することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> focused </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_FOCUSED);</span></span></code></pre></div><p>デフォルトでは、新しく作成されたウィンドウには入力フォーカスが与えられる。ウィンドウを作成する前にウィンドウヒント GLFW_FOCUSED を設定することにより、この動作を変更することができる。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_FOCUSED, GLFW_FALSE);</span></span></code></pre></div><h3 id="ウィンドウズ・アテンション・リクエスト" tabindex="-1">ウィンドウズ・アテンション・リクエスト <a class="header-anchor" href="#ウィンドウズ・アテンション・リクエスト" aria-label="Permalink to &quot;ウィンドウズ・アテンション・リクエスト&quot;">​</a></h3><p>割り込みをかけずにイベントを通知したい場合、glfwRequestWindowAttentionでアテンションを要求することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwRequestWindowAttention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>システムは指定されたウィンドウを、またはこれがサポートされていないプラットフォームでは、アプリケーション全体を強調表示します。ユーザーが注目すると、システムは自動的にリクエストを終了します。</p><h3 id="ウィンドウの損傷とリフレッシュ" tabindex="-1">ウィンドウの損傷とリフレッシュ <a class="header-anchor" href="#ウィンドウの損傷とリフレッシュ" aria-label="Permalink to &quot;ウィンドウの損傷とリフレッシュ&quot;">​</a></h3><p>ウィンドウの内容が破損し、リフレッシュする必要がある場合に通知を受けたい場合は、ウィンドウのリフレッシュ コールバックを設定します。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowRefreshCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m_handle, window_refresh_callback);</span></span></code></pre></div><p>コールバック関数は、ウィンドウの内容を更新する必要があるときに呼び出されます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> window_refresh_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFWwindow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    draw_editor_ui</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    glfwSwapBuffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Aero、Compiz、Aquaなどの合成ウィンドウシステムで、ウィンドウの内容が画面外に保存される場合、このコールバックは、ウィンドウまたはフレームバッファのサイズが変更されたときにのみ呼び出される可能性があります。</p></div><h3 id="ウィンドウの透明度" tabindex="-1">ウィンドウの透明度 <a class="header-anchor" href="#ウィンドウの透明度" aria-label="Permalink to &quot;ウィンドウの透明度&quot;">​</a></h3><p>GLFWは、フレームバッファの透過とウィンドウ全体の透過の2種類のウィンドウの透過をサポートしています．1つのウィンドウで両方の方法を使用することはできません。これを行った場合の結果は未定義である．</p><p>どちらの方法もプラットフォームがそれをサポートする必要があり、GLFWがサポートするすべてのプラットフォームのすべてのバージョンがこれを行うわけではないので、ウィンドウが本当に透明であるかどうかをチェックするメカニズムがあります。</p><p>ウィンドウフレームバッファは GLFW_TRANSPARENT_FRAMEBUFFER ウィンドウヒントでピクセル単位、フレーム単位で透明にすることができる。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwWindowHint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);</span></span></code></pre></div><p>システムでサポートされている場合、ウィンドウのコンテンツ領域は、フレームバッファのピクセル単位のアルファチャンネルを使用して背景と合成されます。これには、システム上でデスクトップ合成が有効になっていることが必要です。これはウィンドウの装飾には影響しません。</p><p>ウィンドウフレームバッファが正常に透過されたかどうかは、GLFW_TRANSPARENT_FRAMEBUFFER ウィンドウ属性で確認することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_TRANSPARENT_FRAMEBUFFER))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // window framebuffer is currently transparent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>GLFWには、gearsというフレームバッファの透明化を有効にした例が付属しています。</p><p>装飾を含むウィンドウ全体の不透明度は、glfwSetWindowOpacityで設定することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowOpacity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>不透明度（またはアルファ値）は0と1の間の正の有限の数で、0（ゼロ）は完全に透明、1（イチ）は完全に不透明になります。新しく作成されたウィンドウの初期不透明度値は1です。</p><p>ウィンドウの現在の不透明度は、glfwGetWindowOpacityで問い合わせることができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> glfwGetWindowOpacity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>システムがウィンドウ全体の透明化をサポートしていない場合、この関数は常に1を返します。</p><p>GLFWには、opacityと呼ばれる実行時にウィンドウ全体の透明度を制御できるテストプログラムが付属しています。</p><h3 id="ウィンドウの属性" tabindex="-1">ウィンドウの属性 <a class="header-anchor" href="#ウィンドウの属性" aria-label="Permalink to &quot;ウィンドウの属性&quot;">​</a></h3><p>ウィンドウには glfwGetWindowAttrib を使用して返すことができる多くの属性があります。ユーザーの操作によって変化する状態（たとえば、入力フォーカスがあるかどうか）を反映するものもあれば、ウィンドウの固有の特性（たとえば、どのようなボーダーを持つか）を反映するものもあります。ウィンドウに関連するものと、OpenGLまたはOpenGL ESのコンテキストに関連するものがあります。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwGetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_FOCUSED))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // window has input focus</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>GLFW_DECORATED, GLFW_RESIZABLE, GLFW_FLOATING, GLFW_AUTO_ICONIFY, GLFW_FOCUS_ON_SHOWウィンドウ属性はglfwSetWindowAttribで変更することができます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSetWindowAttrib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window, GLFW_RESIZABLE, GLFW_FALSE);</span></span></code></pre></div><h4 id="ウィンドウ関連属性" tabindex="-1">ウィンドウ関連属性 <a class="header-anchor" href="#ウィンドウ関連属性" aria-label="Permalink to &quot;ウィンドウ関連属性&quot;">​</a></h4><p>GLFW_FOCUSED は、指定されたウィンドウに入力フォーカスがあるかどうかを示す。詳細は、「ウィンドウの入力フォーカス」を参照してください。</p><p>GLFW_ICONIFIED は、指定されたウィンドウがアイコン化されているかどうかを示す。詳しくは、ウィンドウのアイコン化を参照してください。</p><p>GLFW_MAXIMIZED は、指定されたウィンドウが最大化されているかどうかを示す。詳しくは、ウィンドウの最大化を参照してください。</p><p>GLFW_HOVERED は、カーソルが現在ウィンドウのコンテンツ領域の真上にあり、間に他のウィンドウがないかどうかを示す。詳細は、「カーソルの入力/離脱イベント」を参照してください。</p><p>GLFW_VISIBLE は、指定されたウィンドウが表示されているかどうかを示す。詳細は、「ウィンドウの可視性」を参照してください。</p><p>GLFW_RESIZABLE は、指定されたウィンドウがユーザーによってリサイズ可能かどうかを示す。これは、作成前に GLFW_RESIZABLE window hint で設定するか、作成後に glfwSetWindowAttrib で設定することができる。</p><p>GLFW_DECORATED 指定されたウィンドウがボーダー、クローズウィジェットなどの装飾を持つかどうかを示す。これは、作成前に GLFW_DECORATED window hint で設定するか、作成後に glfwSetWindowAttrib で設定することができる。</p><p>GLFW_AUTO_ICONIFY は、指定されたフルスクリーンウィンドウが、 フォーカスロスやクローズウィジェットなどの際にアイコン化されるかどうかを 示します。これは、作成前に GLFW_AUTO_ICONIFY window hint で設定するか、作成後に glfwSetWindowAttrib で設定することができる。</p><p>GLFW_FLOATING 指定されたウィンドウがフローティングであるかどうかを示す。これは、作成前に GLFW_FLOATING ウィンドウヒントで設定するか、作成後に glfwSetWindowAttrib で設定することができる。</p><p>GLFW_TRANSPARENT_FRAMEBUFFER は、指定されたウィンドウが透明なフレームバッファを持っているかどうか、つまりウィンドウのフレームバッファのアルファチャンネルを使用してウィンドウの内容が背景と合成されるかどうかを示します。詳細はウィンドウの透過性を参照してください。</p><p>GLFW_FOCUS_ON_SHOW glfwShowWindowが呼ばれたときに、ウィンドウに入力フォーカスを与えるかどうかを指定します。これは、作成前に GLFW_FOCUS_ON_SHOW ウィンドウヒントで設定するか、作成後に glfwSetWindowAttrib で設定することができます。</p><h4 id="コンテキスト関連属性" tabindex="-1">コンテキスト関連属性 <a class="header-anchor" href="#コンテキスト関連属性" aria-label="Permalink to &quot;コンテキスト関連属性&quot;">​</a></h4><p>GLFW_CLIENT_API は、ウィンドウのコンテキストが提供するクライアント API を表します。 GLFW_OPENGL_API, GLFW_OPENGL_ES_API あるいは GLFW_NO_API のいずれかです。</p><p>GLFW_CONTEXT_CREATION_API は、ウィンドウのコンテキストを作成するために使用されるコンテキスト作成APIを示します。; either GLFW_NATIVE_CONTEXT_API, GLFW_EGL_CONTEXT_API or GLFW_OSMESA_CONTEXT_API.</p><p>GLFW_CONTEXT_VERSION_MAJOR, GLFW_CONTEXT_VERSION_MINOR and GLFW_CONTEXT_REVISION は、ウィンドウのコンテキストのクライアント API バージョンを示す。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>これらの属性を GLFW_VERSION_MAJOR, GLFW_VERSION_MINOR および GLFW_VERSION_REVISION と混同しないようにしてください。</p></div><p>GLFW_OPENGL_FORWARD_COMPAT は、ウィンドウのコンテキストがOpenGLの前方互換性のあるものであればGLFW_TRUE、そうでない場合はGLFW_FALSEとなります。</p><p>GLFW_OPENGL_DEBUG_CONTEXT は、ウィンドウのコンテキストがデバッグモードであればGLFW_TRUE、そうでなければGLFW_FALSEです。</p><p>GLFW_OPENGL_PROFILE は、コンテキストによって使用されるOpenGLプロファイルを示します。コンテキストが既知のプロファイルを使用している場合は GLFW_OPENGL_CORE_PROFILE または GLFW_OPENGL_COMPAT_PROFILE であり、 OpenGLプロファイルが不明であるかコンテキストが OpenGL ES コンテキストである場合は GLFW_OPENGL_ANY_PROFILE になる。返されたプロファイルは、コンテキストフラグのプロファイルビットと一致しないかもしれないことに注意してください、なぜなら、ビットが設定されていないとき、GLFWはプロファイルを検出する他の手段を試すからです。</p><p>GLFW_CONTEXT_RELEASE_BEHAVIOR は、コンテキストが使用するリリースを示す。指定できる値は GLFW_ANY_RELEASE_BEHAVIOR、 GLFW_RELEASE_BEHAVIOR_FLUSH あるいは GLFW_RELEASE_BEHAVIOR_NONE のいずれかである。動作が GLFW_ANY_RELEASE_BEHAVIOR の場合、コンテキスト作成 API のデフォルトの動作が使用される。GLFW_RELEASE_BEHAVIOR_FLUSH を指定すると、現在のコンテキストから解放されるたびにパイプラインがフラッシュされます。GLFW_RELEASE_BEHAVIOR_NONE を指定すると、パイプラインは解放時にフラッシュされません。</p><p>GLFW_CONTEXT_NO_ERROR は、コンテキストによってエラーが生成されるかどうかを示す。使用可能な値は GLFW_TRUE および GLFW_FALSE である。有効にすると、エラーが発生するような状況では、代わりに未定義の動作が発生する。</p><p>GLFW_CONTEXT_ROBUSTNESS は、コンテキストによって使用される堅牢性ストラテジーを示す。ウィンドウのコンテキストが堅牢性をサポートしている場合は GLFW_LOSE_CONTEXT_ON_RESET または GLFW_NO_RESET_NOTIFICATION で、そうでない場合は GLFW_NO_ROBUSTNESS である。</p><h4 id="フレームバッファ関連属性" tabindex="-1">フレームバッファ関連属性 <a class="header-anchor" href="#フレームバッファ関連属性" aria-label="Permalink to &quot;フレームバッファ関連属性&quot;">​</a></h4><p>GLFWはデフォルトフレームバッファ（すなわち、ウィンドウに接続されたフレームバッファ）の属性を公開していません。</p><p>OpenGLまたはOpenGL ESのバージョン3.0以降を使用している場合、glGetFramebufferAttachmentParameteriv関数は、赤、緑、青、アルファ、深度およびステンシルバッファチャネルのビット数を取得するために使用することができます。それ以外の場合は、glGetIntegerv関数を使用することができます。</p><p>MSAAサンプルの数は、常にglGetIntegervで取得されます。フレームバッファオブジェクトをサポートするコンテキストでは、現在バインドされているフレームバッファのサンプル数が返されます。</p><table tabindex="0"><thead><tr><th>属性</th><th>glGetIntegerv</th><th>glGetFramebufferAttachmentParameteriv</th></tr></thead><tbody><tr><td>Red bits</td><td>GL_RED_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE</td></tr><tr><td>Green bit</td><td>GL_GREEN_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE</td></tr><tr><td>Blue bits</td><td>GL_BLUE_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE</td></tr><tr><td>Alpha bit</td><td>GL_ALPHA_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE</td></tr><tr><td>Depth bit</td><td>GL_DEPTH_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE</td></tr><tr><td>Stencil bits</td><td>GL_STENCIL_BITS</td><td>GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE</td></tr><tr><td>MSAA samples</td><td>GL_SAMPLES</td><td>Not provided by this function</td></tr></tbody></table><p>glGetFramebufferAttachmentParameteriv を呼び出すと、赤、緑、青、アルファのサイズは GL_BACK_LEFT から、深度とステンシルのサイズはそれぞれ GL_DEPTH と GL_STENCIL アタッチメントから問い合わせがあります。</p><h2 id="バッファースワッピング" tabindex="-1">バッファースワッピング <a class="header-anchor" href="#バッファースワッピング" aria-label="Permalink to &quot;バッファースワッピング&quot;">​</a></h2><p>GLFWウィンドウは、デフォルトでダブルバッファリングされています。つまり、フロントバッファとバックバッファの2つのレンダリングバッファを持つということです。フロントバッファは表示されるもので、バックバッファはレンダリングされるものです。</p><p>フレーム全体のレンダリングが完了したら、バックバッファとフロントバッファを入れ替えて、レンダリング済みのものを表示し、新しいフレームのレンダリングを開始する必要があります。これは glfwSwapBuffers で行われます。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSwapBuffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><p>時々、バッファスワップがいつ行われるかを選択することが有用です。関数glfwSwapIntervalを用いると、glfwSwapBuffersが呼ばれた時点から、バッファを交換するまでにドライバが待つべき最小限のモニタリフレッシュ回数を選択することが可能です。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glfwSwapInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>間隔が 0 の場合、glfwSwapBuffers が呼ばれたとき、リフレッシュを待たずに、すぐにスワップが実行されます。そうでなければ、各バッファスワップの間に少なくともインターバルリトレースが経過します。ゼロのスワップ間隔を使用することは、垂直リトレースを待つためにかかる時間を測定することが望ましくない場合、ベンチマーク目的のために有用である。しかし、1つのスワップ間隔を使用すると、テアリングを回避することができます。</p><p>ドライバによっては、アプリケーションが要求するスワップ間隔を上書きするユーザ制御の設定があるため、すべてのマシンでこれが機能するとは限らないことに注意してください。</p><p>WGL_EXT_swap_control_tear または GLX_EXT_swap_control_tear 拡張のいずれかをサポートするコンテキストは、負のスワップ間隔も受け入れ、フレームが少し遅れて到着した場合でも、ドライバがすぐにスワップすることを可能にします。これは、目に見える涙のリスクと、より大きなフレームレートの安定性をトレードします。これらの拡張は glfwExtensionSupported で確認することができます。</p>`,311)]))}const g=s(p,[["render",l]]);export{o as __pageData,g as default};
